<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>6-网络系统</title>
      <link href="/posts/505cf207.html"/>
      <url>/posts/505cf207.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-可靠UDP"><a href="#1-可靠UDP" class="headerlink" title="1. 可靠UDP"></a>1. 可靠UDP</h2><ol><li>序列号设计<ul><li>16位循环序号：每65536包循环一次</li><li>序列号压缩：使用差值编码减少头部开销</li></ul></li><li>ACK&#x2F;NACK机制<ul><li>累计确认：ACK携带已连续接收的最大序号</li><li>选择性确认（SACK）：明确告知丢失包位置</li><li>否定确认（NACK）：接收方主动请求重传</li></ul></li><li>滑动窗口机制<ul><li>发送窗口：限制已发送未确认的数据量（通常16-256个包）</li><li>接收窗口：动态调整的缓冲区管理</li><li>RTT动态计算：根据网络延迟调整超时时间</li></ul></li><li>ARQ协议（自动重传请求）<ul><li>停止等待ARQ：发送每个包后等待ACK，超时重传</li><li>回退N帧（Go-Back-N）：滑动窗口机制，批量发送多个包</li><li>选择性重传（Selective Repeat）：仅重传丢失的特定包</li></ul></li><li>前向纠错（FEC）<ul><li>数据包异或：生成冗余包（如包3&#x3D;包1⊕包2）</li><li>Reed-Solomon编码：适合高丢包率场景（如视频流）</li><li>权衡：增加20%-30%冗余包可修复90%丢包情况</li></ul></li><li>流量控制<ul><li>接收方通过ACK包携带剩余缓冲区大小</li><li>动态窗口调整算法：类似TCP的AIMD（加法增大乘法减小）</li></ul></li></ol><h2 id="2-时钟同步"><a href="#2-时钟同步" class="headerlink" title="2. 时钟同步"></a>2. 时钟同步</h2><ul><li>使用NTP算法</li><li>但NTP算法存在缺点：即假设上行和下行链路是稳定的</li><li>基于流的时间同步与消除高阶模式<ol><li><strong>客户端请求</strong>：客户端在“时间请求”数据包上标记当前本地时间并发送给服务器。</li><li><strong>服务器响应</strong>：服务器收到数据包后，标记服务器时间并返回。</li><li><strong>时间差计算</strong>：客户端计算时间差，公式为：$\text{时间差} &#x3D; \frac{\text{(当前时间 - 发送时间)}}{2}$（即计算出offset）</li><li><strong>立即更新时钟</strong>：第一个结果立即用于更新时钟。</li><li><strong>重复过程</strong>：客户端重复步骤1-3（类似于NTP的过程）五次或更多次。</li><li><strong>累积和排序</strong>：将数据包接收结果累积，并按延迟升序排序。</li><li><strong>消除异常值</strong>：丢弃所有大约超过中位数1.5倍的样本，并对剩余样本使用算术平均进行平均。</li></ol></li></ul><h2 id="3-RPC"><a href="#3-RPC" class="headerlink" title="3. RPC"></a>3. RPC</h2><h3 id="RPC：远程过程调用（Remote-Procedure-Call）"><a href="#RPC：远程过程调用（Remote-Procedure-Call）" class="headerlink" title="RPC：远程过程调用（Remote Procedure Call）"></a>RPC：远程过程调用（Remote Procedure Call）</h3><img src="/img/GAMES104/6-网络系统/RPC.png" height=350 /><h3 id="为什么要RPC？"><a href="#为什么要RPC？" class="headerlink" title="为什么要RPC？"></a>为什么要RPC？</h3><ul><li><em>如果需要自己编写的话需要定义网络消息包，需要考虑如何解析（不同平台可能有大小端差异）等等</em></li><li>目标：提供易于编程的网络通信，使客户端-服务器通信变得透明。</li><li>保留集中式代码的“感觉”：<ul><li>程序员不需要考虑网络问题。</li><li>使通信看起来像本地过程调用。</li></ul></li><li>无需担心网络的序列化&#x2F;反序列化。</li><li>无需担心网络的复杂性。</li></ul><h3 id="RPC-Stubs-存根"><a href="#RPC-Stubs-存根" class="headerlink" title="RPC Stubs(存根)"></a>RPC Stubs(存根)</h3><ul><li><strong>客户端存根</strong>：<ul><li>是一种在客户端看起来像是可调用的服务器过程的程序。</li><li>客户端程序认为它正在调用服务器，但实际上是在调用客户端存根。</li></ul></li><li><strong>服务器端存根</strong>：<ul><li>看起来像是对服务器的调用方。</li><li>服务器程序认为它被客户端调用，但实际上是由服务器端存根调用的。</li></ul></li><li><strong>存根通信</strong>：<ul><li>存根之间发送消息，使 RPC 透明地发生。</li></ul></li></ul><img src="/img/GAMES104/6-网络系统/RPC_Stubs.png" height=350 /><h3 id="存根编译器"><a href="#存根编译器" class="headerlink" title="存根编译器"></a>存根编译器</h3><ul><li>当客户端连接上服务器时，会相互注册所有的RPC生成RPC存根，然后会调用存根编译器进行编译</li><li>每次系统调用时会去调用存根（查找函数是否存在），存根会将参数序列化后发送给服务器，服务器收到后会反序列化参数，然后调用服务器端的函数，最后将返回值序列化后发送给客户端，客户端收到后会反序列化返回值，然后返回给客户端</li></ul><ul><li><strong>功能</strong>：<ul><li>“存根编译器”读取接口定义语言（IDL）声明，并为每个服务器过程生成两个存根程序。</li></ul></li><li><strong>服务器程序员职责</strong>：<ul><li>实现服务的过程，并将其与服务器端存根链接。</li></ul></li><li><strong>客户端程序员职责</strong>：<ul><li>实现客户端程序，并将其与客户端存根链接。</li></ul></li><li><strong>管理通信</strong>：<ul><li>存根管理客户端和服务器之间远程通信的所有细节。</li></ul></li></ul><h3 id="RPC调用过程"><a href="#RPC调用过程" class="headerlink" title="RPC调用过程"></a>RPC调用过程</h3><img src="/img/GAMES104/6-网络系统/RPC调用过程.png" height=350 />]]></content>
      
      
      <categories>
          
          <category> GAMES104 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13-二叉树</title>
      <link href="/posts/f126649d.html"/>
      <url>/posts/f126649d.html</url>
      
        <content type="html"><![CDATA[<hr><ul><li><a href="https://www.cnblogs.com/namelij/p/15222567.html">二叉树遍历</a></li><li>三种遍历：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dfsByStack</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">if</span> (root) st.<span class="built_in">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 前序访问位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意压栈顺序：先右后左，保证取出顺序是左右</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 深入左子树直到最底部</span></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 中序访问位置</span></span><br><span class="line">        cur = cur-&gt;right;           <span class="comment">// 转向右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">if</span> (root) st.<span class="built_in">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        result.<span class="built_in">push_back</span>(cur-&gt;val);  <span class="comment">// 根节点先存储</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意压栈顺序：先左后右，结果最后反转即为后序</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 反转得到左右根顺序</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>层序遍历：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bfsByQueue</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (root) q.<span class="built_in">push</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> level_size = q.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level_size; ++i) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            level.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二叉搜索树中第K小的元素-–-中序遍历"><a href="#二叉搜索树中第K小的元素-–-中序遍历" class="headerlink" title="二叉搜索树中第K小的元素 – 中序遍历"></a>二叉搜索树中第K小的元素 – 中序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意条件st.size() &gt; 0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; st;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || st.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        root = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        --k;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        root = root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求根节点到叶节点所有路径组合成的数字之和-–-深搜"><a href="#求根节点到叶节点所有路径组合成的数字之和-–-深搜" class="headerlink" title="求根节点到叶节点所有路径组合成的数字之和 – 深搜"></a>求根节点到叶节点所有路径组合成的数字之和 – 深搜</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 注意使用preSum</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> preSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = preSum * <span class="number">10</span> + root-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left, sum) + <span class="built_in">dfs</span>(root-&gt;right, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树最近公共祖先-–-深搜递归注意条件判断"><a href="#二叉树最近公共祖先-–-深搜递归注意条件判断" class="headerlink" title="二叉树最近公共祖先 –  深搜递归注意条件判断"></a>二叉树最近公共祖先 –  深搜递归注意条件判断</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">    TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">    <span class="comment">// 如果左右子树都找到了最低公共祖先，则根节点即为最低公共祖先</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 如果左子树没有找到最低公共祖先，则最低公共祖先在右子树中，反之在左子树中</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转二叉树"><a href="#反转二叉树" class="headerlink" title="反转二叉树"></a>反转二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mirrorTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* temp = root-&gt;left;</span><br><span class="line">    root-&gt;left = <span class="built_in">mirrorTree</span>(root-&gt;right);</span><br><span class="line">    root-&gt;right = <span class="built_in">mirrorTree</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀树-–-高效地存储和检索字符串数据集中的键"><a href="#前缀树-–-高效地存储和检索字符串数据集中的键" class="headerlink" title="前缀树 – 高效地存储和检索字符串数据集中的键"></a>前缀树 – 高效地存储和检索字符串数据集中的键</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    vector&lt;Trie*&gt; next;</span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> node = node-&gt;next[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">isEnd</span>(<span class="literal">false</span>), <span class="built_in">next</span>(<span class="number">26</span>, <span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c] == <span class="literal">nullptr</span>)</span><br><span class="line">                node-&gt;next[c] = <span class="keyword">new</span> <span class="built_in">Tire</span>();</span><br><span class="line">            node = node-&gt;next[c];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node == <span class="literal">nullptr</span> ? <span class="literal">false</span> : node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchPrefix</span>(prefix) == <span class="literal">nullptr</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5-AI系统</title>
      <link href="/posts/773319c1.html"/>
      <url>/posts/773319c1.html</url>
      
        <content type="html"><![CDATA[<ol><li>导航（见寻路系统）</li><li>转向</li><li>人群模拟<ul><li>基于力的避障（速度场） </li><li>基于速度的避障：RVO&#x2F;ORVO避障</li></ul></li><li>感知</li><li>经典决策算法<ul><li>有限状态机FSM</li><li>层次状态机HFSM</li><li>行为树BT<ul><li>缺点：<ul><li>需要从根节点遍历（可以优化增加event）</li><li>模拟的行为无目的性</li></ul></li></ul></li></ul></li><li>HTN：Hierarchical Task Network层次任务网络</li></ol><ul><li><p>例子：</p><img src="/img/GAMES104/5-AI系统/HTN1.png" height=350 /></li><li><p>架构：</p><img src="/img/GAMES104/5-AI系统/HTN2.png" height=350 /><img src="/img/GAMES104/5-AI系统/HTN3.png" height=350 /></li><li><p>和行为树节点不同在会有Precondition和Effect </p><img src="/img/GAMES104/5-AI系统/PrimitiveTask.png" height=350 /></li><li><p>具有任务优先级</p><img src="/img/GAMES104/5-AI系统/CompoundTask.png" height=350 /></li><li><p>HTN域由多个任务组成：</p><img src="/img/GAMES104/5-AI系统/HTNDomain.png" height=350 /></li><li><p>执行过程：</p><img src="/img/GAMES104/5-AI系统/Planning1.png" height=350 /><img src="/img/GAMES104/5-AI系统/Planning2.png" height=350 /></li><li><p>会假设执行成功，world state会保存假设执行成功后改变的信息</p><img src="/img/GAMES104/5-AI系统/Planning3.png" height=350 /><img src="/img/GAMES104/5-AI系统/Planning4.png" height=350 /><img src="/img/GAMES104/5-AI系统/Planning5.png" height=350 /><img src="/img/GAMES104/5-AI系统/Planning6.png" height=350 /><img src="/img/GAMES104/5-AI系统/Planning7.png" height=350 /><img src="/img/GAMES104/5-AI系统/Replan.png" height=350 /><img src="/img/GAMES104/5-AI系统/结论.png" height=350 /></li></ul>]]></content>
      
      
      <categories>
          
          <category> GAMES104 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12-技巧</title>
      <link href="/posts/2ccc368b.html"/>
      <url>/posts/2ccc368b.html</url>
      
        <content type="html"><![CDATA[<h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169-多数元素"></a>169-多数元素</h3><ul><li>Boyer-Moore投票法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMajority</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> candidate = nums[<span class="number">0</span>], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            candidate = n;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n != candidate) &#123;</span><br><span class="line">            --cnt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂求余算法"><a href="#快速幂求余算法" class="headerlink" title="快速幂求余算法"></a>快速幂求余算法</h3><ul><li>时间复杂度O(logn), a^b%c</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>, a = a % c;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>) res = (res * a) % c;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">        a = (a * a) % c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序数组查找第一个和最后一个位置"><a href="#排序数组查找第一个和最后一个位置" class="headerlink" title="排序数组查找第一个和最后一个位置"></a>排序数组查找第一个和最后一个位置</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意查找target左右边界的写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target, <span class="type">bool</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == target) &#123;</span><br><span class="line">            <span class="comment">// 核心代码</span></span><br><span class="line">            ans = m;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num[m] &lt; target) &#123;</span><br><span class="line">            l = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    res[<span class="number">0</span>] = <span class="built_in">binarySearch</span>(nums, target, <span class="literal">false</span>);</span><br><span class="line">    res[<span class="number">1</span>] = <span class="built_in">binarySearch</span>(nums, target, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找重复数-–-二分，环"><a href="#寻找重复数-–-二分，环" class="headerlink" title="寻找重复数 – 二分，环"></a>寻找重复数 – 二分，环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> find = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        find = nums[find];</span><br><span class="line">        <span class="keyword">if</span> (slow == find) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11-排序</title>
      <link href="/posts/2dc8de0b.html"/>
      <url>/posts/2dc8de0b.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-快排"><a href="#1-快排" class="headerlink" title="1-快排"></a>1-快排</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> i = left;</span><br><span class="line">        <span class="type">int</span> j = right;</span><br><span class="line">        <span class="type">int</span> pivot = arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot) j--;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) arr[i] = arr[j];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) arr[j] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[i] = pivot;</span><br><span class="line">        <span class="built_in">QuickSort</span>(arr, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(arr, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2-归并排序"></a>2-归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merg</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> middle, <span class="type">int</span> heigt)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size = heigt - low + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(size, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = low, j = middle + <span class="number">1</span>, idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle &amp;&amp; j &lt;= heigt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= arr[j])</span><br><span class="line">            temp[idx++] = arr[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            temp[idx++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= middle) &#123;</span><br><span class="line">        temp[idx++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= heigt) &#123;</span><br><span class="line">        temp[idx++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= heigt; i++) &#123;</span><br><span class="line">        arr[i] = temp[idx++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> heigt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; heigt) &#123;</span><br><span class="line">        <span class="type">int</span> middle = (low + heigt) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">MergSort</span>(arr, low, middle);</span><br><span class="line">        <span class="built_in">MergSort</span>(arr, middle + <span class="number">1</span>, heigt);</span><br><span class="line">        <span class="built_in">Merg</span>(arr, low, middle, heigt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unity</title>
      <link href="/posts/c8a4b253.html"/>
      <url>/posts/c8a4b253.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-UE5移动同步机制"><a href="#1-UE5移动同步机制" class="headerlink" title="1-UE5移动同步机制"></a>1-UE5移动同步机制</h2><ol><li><strong>客户端（自主代理）</strong>  <ul><li><strong>本地控制</strong>  <ul><li>运行移动组件物理逻辑（<code>PerformMovement</code>），生成移动数据包（<code>FSavedMove_Character</code>）。  </li><li>将数据包存入队列（<code>SavedMoves</code>），通过<code>ServerMove RPC</code>向服务器发送精简数据。</li></ul></li></ul></li><li><strong>服务器（授权Actor）</strong>  <ul><li><strong>数据验证与同步</strong>  <ul><li>接收<code>ServerMove</code>，复现客户端移动（<code>PerformMovement</code>）。</li></ul></li><li><strong>一致性校验</strong>：对比客户端报告的最终位置与实际计算结果。  <ul><li><strong>一致</strong> → 返回确认信号。  </li><li><strong>不一致</strong> → 通过<code>ClientAdjustPosition RPC</code>发送校正指令。</li></ul></li><li>广播同步数据：将位置、旋转、状态封装为<code>ReplicatedMovement</code>结构，发送至其他客户端。</li></ul></li><li><strong>其他客户端（模拟代理）</strong>  <ul><li><strong>直接应用同步数据</strong>：  <ul><li>使用<code>ReplicatedMovement</code>更新代理状态，通过<strong>网络平滑</strong>优化视觉表现（如插值过渡）。</li></ul></li></ul></li><li><strong>客户端校正处理</strong>  <ul><li>若收到<code>ClientAdjustPosition</code>：  </li><li>强制应用服务器移动结果，清空<code>SavedMoves</code>队列中已过时操作。  </li><li>重新追踪未处理动作，确保本地状态与服务器一致。</li></ul></li></ol><h2 id="2-抗锯齿算法"><a href="#2-抗锯齿算法" class="headerlink" title="2-抗锯齿算法"></a>2-抗锯齿算法</h2><ul><li><p><strong>超级采样抗锯齿-SSAA (Super Sampling Anti-aliasing)</strong>  </p><ul><li><strong>原理</strong>：以N倍分辨率渲染场景，最后下采样到目标分辨率  </li><li><strong>渲染阶段</strong>：光栅化前处理（几何处理阶段）  </li><li><strong>优点</strong>：画质最佳，消除所有类型锯齿  </li><li><strong>缺点</strong>：显存消耗巨大（4xSSAA需4倍显存），性能消耗最高</li></ul></li><li><p><strong>多重采样抗锯齿-MSAA (Multi-Sampling Anti-aliasing)</strong>  </p><ul><li><strong>原理</strong>：对SSAA进行优化，在每个像素内进行多次采样  </li><li><strong>渲染阶段</strong>：光栅化阶段（深度&#x2F;模板测试后）  </li><li><strong>优点</strong>：比SSAA节省40%性能，保持边缘平滑  </li><li><strong>缺点</strong>：无法处理透明纹理锯齿，对Deferred Rendering不友好</li></ul></li><li><p><strong>快速近似抗锯齿-FXAA (Fast Approximate Anti-aliasing)</strong>  </p><ul><li><strong>原理</strong>：基于后处理的图像分析，识别高频边缘进行模糊，每个像素进行插值混合</li><li><strong>渲染阶段</strong>：后处理阶段（最终图像输出前）  </li><li><strong>优点</strong>：速度最快（2-3ms内完成），全屏覆盖  </li><li><strong>缺点</strong>：造成细节模糊，文字&#x2F;UI元素质量下降</li></ul></li><li><p><strong>时间性抗锯齿-TAA (Temporal Anti-aliasing)</strong>  </p><ul><li><strong>原理</strong>：利用历史帧数据进行时间域累积采样  </li><li><strong>渲染阶段</strong>：后处理 + 运动向量计算  </li><li><strong>优点</strong>：有效消除动态闪烁（Specular Aliasing）  </li><li><strong>缺点</strong>：运动物体可能产生鬼影（Ghosting）</li></ul></li></ul><h2 id="3-MipMap"><a href="#3-MipMap" class="headerlink" title="3-MipMap"></a>3-MipMap</h2><ul><li><strong>MipMap</strong>：一种纹理压缩技术，通过对纹理进行多级采样，实现对纹理细节的动态调整，以提高渲染性能和视觉效果</li><li>在shader中如何确定MipMap层级：<a href="https://blog.csdn.net/u013746357/article/details/107975128">纹理采样时如何确定正确的mipmap level</a>（使用uv对xy轴的偏导数来确定）</li></ul><ul><li>GPU通过计算UV坐标在屏幕空间中的变化率（即相邻像素的UV差值）来量化纹理的缩放程度 <ul><li><code>ddx(uv)</code>：同一行相邻像素的UV差值（水平方向变化率）；<code>ddy(uv)</code>：同一列相邻像素的UV差值（垂直方向变化率）。  这两者的物理意义是：<strong>一个屏幕像素在纹理空间中覆盖的UV范围</strong>。例如：  <ul><li>若UV在屏幕上均匀变化，<code>ddx(uv)</code>和<code>ddy(uv)</code>为固定值。  </li><li>若物体远离相机，相邻像素的UV差值会增大（屏幕像素覆盖更多纹理区域）。</li></ul></li><li>此计算在<strong>像素着色器</strong>中完成，因为ddx&#x2F;ddy需要访问相邻像素的UV值（顶点着色器无法获取）。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 计算纹理空间的变化率  </span></span><br><span class="line">float2 dx = <span class="built_in">ddx</span>(uv) * textureSize;  <span class="comment">// 纹理像素单位的变化率  </span></span><br><span class="line">float2 dy = <span class="built_in">ddy</span>(uv) * textureSize;  <span class="comment">//（`textureSize`是纹理的分辨率，用于将UV差值转换为实际texel数量）  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 计算最大变化率 </span></span><br><span class="line"><span class="type">float</span> rho = <span class="built_in">max</span>(<span class="built_in">length</span>(dx), <span class="built_in">length</span>(dy));   <span class="comment">//rho越大，表示屏幕像素覆盖的纹理区域越大（需要更高层级的Mipmap）。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 转换为Mipmap层级 </span></span><br><span class="line"><span class="type">float</span> lod = <span class="built_in">log2</span>(rho);    </span><br><span class="line"><span class="comment">// 若rho=1（1个texel覆盖1个像素），lod=0（使用原图）。  </span></span><br><span class="line"><span class="comment">// 若rho=4（4x4 texel覆盖1个像素），lod=2（使用第2级Mipmap，即原图的1/4分辨率）。  </span></span><br></pre></td></tr></table></figure><h2 id="4-对象池"><a href="#4-对象池" class="headerlink" title="4-对象池"></a>4-对象池</h2><hr><h3 id="一、数据结构选择策略"><a href="#一、数据结构选择策略" class="headerlink" title="一、数据结构选择策略"></a>一、数据结构选择策略</h3><ol><li><p><strong>队列(Queue)</strong>  </p><ul><li><strong>优势</strong>：FIFO特性保持对象复用顺序，避免内存碎片  </li><li><strong>示例</strong>：子弹、特效等高频创建&#x2F;销毁对象  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Queue&lt;GameObject&gt; pool = <span class="keyword">new</span> Queue&lt;GameObject&gt;();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>字典(Dictionary)分类</strong>  </p><ul><li><strong>场景</strong>：需按预制体类型管理的多类对象池  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, Queue&lt;GameObject&gt;&gt; typePools = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, Queue&lt;GameObject&gt;&gt;();</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>栈(Stack)</strong>  </p><ul><li><strong>适用场景</strong>：需优先重用最近回收对象（如频繁切换的UI元素）</li></ul></li></ol><hr><h3 id="二、回收机制与自动化"><a href="#二、回收机制与自动化" class="headerlink" title="二、回收机制与自动化"></a>二、回收机制与自动化</h3><ol><li><p><strong>手动回收</strong>  </p><ul><li><strong>显式调用</strong>：通过<code>Release</code>方法归还对象，需业务逻辑控制  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReleaseBullet</span>(<span class="params">GameObject bullet</span>)</span> &#123;</span><br><span class="line">    bullet.SetActive(<span class="literal">false</span>);</span><br><span class="line">    pool.Enqueue(bullet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>自动回收</strong>  </p><ul><li><strong>超时检测</strong>：通过协程定期检查未激活对象  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IEnumerator <span class="title">AutoRecycle</span>(<span class="params"><span class="built_in">float</span> lifetime</span>)</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params">lifetime</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span> (!isActive) Release(<span class="keyword">this</span>.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>事件驱动</strong>：利用<code>OnDisable</code>或自定义析构器  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDisable</span>()</span> &#123;</span><br><span class="line">    ObjectPool.Instance.Release(<span class="keyword">this</span>.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="三、性能优化关键点"><a href="#三、性能优化关键点" class="headerlink" title="三、性能优化关键点"></a>三、性能优化关键点</h3><ol><li><p><strong>预热策略</strong>  </p><ul><li><strong>启动时预加载</strong>：避免运行时首次使用卡顿  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prewarm</span>(<span class="params"><span class="built_in">int</span> count</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = Instantiate(prefab);</span><br><span class="line">        obj.SetActive(<span class="literal">false</span>);</span><br><span class="line">        pool.Enqueue(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>动态扩容算法</strong>  </p><ul><li><strong>指数退避</strong>：按当前容量的150%扩容，避免频繁调整  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExpandPool</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> newSize = Mathf.Min(currentSize * <span class="number">3</span> / <span class="number">2</span>, maxCapacity);</span><br><span class="line">    <span class="comment">// 实例化新增对象并加入池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>状态重置优化</strong>  </p><ul><li><strong>延迟重置</strong>：在对象被取出时初始化而非回收时  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GameObject <span class="title">Get</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = pool.Dequeue();</span><br><span class="line">    obj.transform.position = spawnPoint; <span class="comment">// 重置位置</span></span><br><span class="line">    obj.GetComponent&lt;Rigidbody&gt;().velocity = Vector3.zero; <span class="comment">// 重置物理状态</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="四、Unity完整伪代码示例"><a href="#四、Unity完整伪代码示例" class="headerlink" title="四、Unity完整伪代码示例"></a>四、Unity完整伪代码示例</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象池管理器（单例模式）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectPool</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ObjectPool Instance;</span><br><span class="line">    </span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PoolConfig</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> GameObject prefab;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> prewarmCount = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> maxCapacity = <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> PoolConfig[] configs;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;GameObject, Queue&lt;GameObject&gt;&gt; poolDict = <span class="keyword">new</span> Dictionary&lt;GameObject, Queue&lt;GameObject&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>()</span> &#123;</span><br><span class="line">        Instance = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> config <span class="keyword">in</span> configs) &#123;</span><br><span class="line">            <span class="keyword">var</span> queue = <span class="keyword">new</span> Queue&lt;GameObject&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt;config.prewarmCount; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> obj = Instantiate(config.prefab);</span><br><span class="line">                obj.SetActive(<span class="literal">false</span>);</span><br><span class="line">                queue.Enqueue(obj);</span><br><span class="line">            &#125;</span><br><span class="line">            poolDict.Add(config.prefab, queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GameObject <span class="title">Get</span>(<span class="params">GameObject prefab, Vector3 pos</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!poolDict.ContainsKey(prefab)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> pool = poolDict[prefab];</span><br><span class="line">        <span class="keyword">if</span>(pool.Count == <span class="number">0</span> &amp;&amp; pool.Count &lt; config.maxCapacity) &#123;</span><br><span class="line">            ExpandPool(prefab); <span class="comment">// 动态扩容</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> obj = pool.Dequeue();</span><br><span class="line">        obj.transform.position = pos;</span><br><span class="line">        obj.SetActive(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Release</span>(<span class="params">GameObject obj</span>)</span> &#123;</span><br><span class="line">        obj.SetActive(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">var</span> prefab = GetPrefabFromObj(obj); <span class="comment">// 通过元数据获取预制体类型</span></span><br><span class="line">        poolDict[prefab].Enqueue(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h3><ol><li><strong>线程安全</strong>：多线程环境需加锁（如<code>lock</code>关键字）  </li><li><strong>内存泄漏</strong>：定期检查游离对象，设置最大存活时间  </li><li><strong>可视化调试</strong>：在Editor中显示池状态  </li><li><strong>分层管理</strong>：对高频&#x2F;低频对象使用独立池</li></ol><h2 id="5-UI框架"><a href="#5-UI框架" class="headerlink" title="5-UI框架"></a>5-UI框架</h2><ul><li>参考资料：<a href="https://blog.csdn.net/wjj616806129/article/details/85208718">UI框架设计</a></li><li>注意用栈来管理UI层级</li><li>抽象一个基类出来，包含UI的基本功能</li></ul><h2 id="6-红点系统"><a href="#6-红点系统" class="headerlink" title="6-红点系统"></a>6-红点系统</h2><ul><li>参考资料：<a href="https://blog.csdn.net/qq_54351806/article/details/140640489">红点系统实现</a></li><li>要点:<ul><li>使用前缀树来管理红点的层级关系：可以快速定位某个节点的所有子节点，便于批量更新</li><li>观察者模式：当某个节点的状态发生变化时，通过事件通知其所有父节点更新状态</li></ul></li><li>优化点：<ul><li>对使用字符串作为键的字典进行优化：避免频繁字符串分割，使用预处理的哈希表存储节点路径</li><li>脏标记：当某个节点的状态发生变化时，标记其所有父节点为脏节点，在下一帧更新时批量更新（避免重复父类触发刷新）</li></ul></li></ul><h2 id="7-GC总结"><a href="#7-GC总结" class="headerlink" title="7-GC总结"></a>7-GC总结</h2><h3 id="Unity的GC过程详解"><a href="#Unity的GC过程详解" class="headerlink" title="Unity的GC过程详解"></a><strong>Unity的GC过程详解</strong></h3><p>Unity使用<strong>Boehm-Demers-Weiser垃圾收集器</strong>，基于<strong>标记-清除算法</strong>，其核心流程如下：  </p><ol><li><strong>标记阶段</strong>：遍历所有“根对象”（如全局变量、静态字段、活动线程栈中的引用等），递归标记所有可达对象。  </li><li><strong>清除阶段</strong>：释放未被标记的“垃圾”对象内存，但<strong>不进行内存压缩</strong>，导致内存碎片问题。  </li><li><strong>增量GC优化</strong>：从Unity 2019开始支持增量GC，将标记-清除过程拆分为多帧执行，减少单帧卡顿。但增量GC可能因对象引用频繁变化导致性能回退。  </li><li><strong>分代策略</strong>：Unity的Mono运行时支持简单分代（0代频繁回收，1&#x2F;2代较少），但实际分代效果有限。IL2CPP后端优化了GC效率，但仍依赖分代逻辑。  </li><li><strong>托管堆扩展</strong>：当堆内存不足时，GC会先尝试回收，若仍不足则扩展堆内存，但扩展后内存不会返还给操作系统，可能造成内存浪费。</li></ol><hr><h3 id="Lua的GC过程详解"><a href="#Lua的GC过程详解" class="headerlink" title="Lua的GC过程详解"></a><strong>Lua的GC过程详解</strong></h3><p>Lua采用<strong>标记-清除算法</strong>，核心流程包括：  </p><ol><li><strong>标记阶段</strong>：从根对象（全局表、注册表、活动协程等）出发，使用<strong>三色标记法</strong>（白→灰→黑）递归标记可达对象。  </li><li><strong>清除阶段</strong>：释放白色（不可达）对象内存，但<strong>不压缩内存</strong>，可能导致碎片。  </li><li><strong>增量模式</strong>：将标记-清除分步执行，避免长时间停顿（通过<code>collectgarbage(&quot;step&quot;)</code>手动控制）。  </li><li><strong>分代模式（Lua 5.4+）</strong>：将对象分为年轻代（频繁回收）和老年代（较少回收），通过<code>collectgarbage(&quot;generational&quot;)</code>启用。  </li><li><strong>弱表机制</strong>：通过<code>__mode</code>元方法声明弱引用键&#x2F;值，GC自动回收无强引用的对象，常用于缓存管理。</li></ol><hr><h3 id="C-的GC过程详解"><a href="#C-的GC过程详解" class="headerlink" title="C#的GC过程详解"></a><strong>C#的GC过程详解</strong></h3><p>C#的GC基于<strong>分代压缩模型</strong>，具体流程为：  </p><ol><li><strong>分代回收</strong>：托管堆分为0、1、2代，新对象在0代。GC优先回收0代（频率最高），存活对象晋升到下一代。  </li><li><strong>标记阶段</strong>：从根对象（静态字段、局部变量等）出发标记可达对象。  </li><li><strong>压缩阶段</strong>：在回收后整理内存，消除碎片（0代频繁压缩，2代较少压缩）。  </li><li><strong>大对象堆（LOH）</strong>：超过85KB的对象分配在LOH（属于2代），不压缩，可能引发碎片问题。  </li><li><strong>Finalizer处理</strong>：实现<code>Finalize</code>的对象需两次GC才能释放，第一次调用析构函数，第二次回收内存。</li></ol><hr><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>C#</strong></th><th><strong>Unity</strong></th><th><strong>Lua</strong></th></tr></thead><tbody><tr><td><strong>核心算法</strong></td><td>分代标记-压缩</td><td>标记-清除（Boehm GC）</td><td>标记-清除（支持分代&#x2F;增量）</td></tr><tr><td><strong>内存压缩</strong></td><td>是（代内压缩）</td><td>否</td><td>否</td></tr><tr><td><strong>分代支持</strong></td><td>是（0&#x2F;1&#x2F;2代）</td><td>部分支持（Mono简单分代）</td><td>是（Lua 5.4+分代模式）</td></tr><tr><td><strong>增量回收</strong></td><td>否</td><td>是（2019+增量GC）</td><td>是（默认增量模式）</td></tr><tr><td><strong>特殊机制</strong></td><td>LOH、Finalizer</td><td>增量GC、Native堆分离</td><td>弱表、三色标记法</td></tr><tr><td><strong>碎片问题</strong></td><td>低（压缩优化）</td><td>高（Boehm GC无压缩）</td><td>中（依赖开发者管理弱表）</td></tr></tbody></table><h2 id="8-光照模型"><a href="#8-光照模型" class="headerlink" title="8-光照模型"></a>8-光照模型</h2><ul><li>参考资料：<a href="https://zhuanlan.zhihu.com/p/442023993">光照模型</a></li></ul><h2 id="9-网络相关"><a href="#9-网络相关" class="headerlink" title="9-网络相关"></a>9-网络相关</h2><h3 id="1-检测玩家断线，需要考虑网络抖动"><a href="#1-检测玩家断线，需要考虑网络抖动" class="headerlink" title="1) 检测玩家断线，需要考虑网络抖动"></a>1) 检测玩家断线，需要考虑网络抖动</h3><ol><li>心跳包机制<ul><li>客户端：定期向服务器发送心跳包（如每 5 秒发送一次）。</li><li>服务器：记录每个客户端的最后心跳时间。</li><li>如果服务器在一定时间内（如 15 秒）未收到客户端的心跳包，则判定该玩家断线</li></ul></li><li>超时机制<ul><li>服务器设置一个合理的超时时间（如 20 秒）。如果连续多次心跳包丢失（如 3 次），才判定为断线，可以根据网络状况动态调整超时时间。</li></ul></li><li>重试机制<ul><li>服务器在检测到心跳包丢失后，发送重试请求给客户端。</li><li>如果客户端收到重试请求，立即发送心跳包确认在线状态。</li><li>如果多次重试失败（如 3 次），判定为断线。</li></ul></li><li>辅助检测<ul><li>如果玩家在一段时间内未发送任何游戏行为数据（如移动、攻击等），结合心跳包机制进行综合判断。</li></ul></li><li>网络抖动处理<ul><li>滑动窗口机制：服务器维护一个滑动窗口，记录最近的几次心跳包到达时间。如果心跳包偶尔丢失，但后续的心跳包正常到达，则不判定为断线。</li><li>延迟判定：不立即判定断线，而是等待更长时间（如 2 倍超时时间）再确认。</li></ul></li><li>客户端辅助检测<ul><li>客户端定期检查网络连接状态（如通过 ping 或 traceroute）。如果客户端检测到断线，主动发送断线通知给服务器。</li></ul></li></ol><h3 id="2-怎么优化网络抖动"><a href="#2-怎么优化网络抖动" class="headerlink" title="2) 怎么优化网络抖动"></a>2) 怎么优化网络抖动</h3><ol><li>使用buffer<ul><li>通过队列缓冲处理网络数据包，客户端以固定频率（如每个tick）从队列中取出数据包处理，而非立即处理。这能平滑因网络延迟波动（抖动）导致的瞬时卡顿。</li></ul></li><li>客户端预测与服务器校正<ul><li>通过客户端权威预测技术，本地玩家的操作立即生效，同时服务器验证并纠正错误，减少因网络延迟带来的感知延迟。并利用插值平滑过渡避免瞬间跳跃。</li></ul></li><li>数据压缩与带宽优化<ul><li>量化同步数据：对位置、旋转等属性进行精度限制（如保留小数点后2位），减少单次同步数据量</li><li>动态更新频率：根据实体重要性动态调整同步频率。例如，远距离玩家降低位置更新频率，近距离玩家提高频率</li></ul></li><li>时间补偿与抖动补偿算法<ul><li>服务器时间同步：使用网络时间协议（NTP）同步服务器时间，减少客户端时间误差</li></ul></li><li>物理同步优化<ul><li>确定性物理：使用固定时间步长（FixedTimestep）运行物理引擎，并在所有客户端保持相同的随机种子</li></ul></li></ol><h3 id="3-如果遇到了一个客户端有网络延迟因此发送给服务端的数据有延迟怎么办"><a href="#3-如果遇到了一个客户端有网络延迟因此发送给服务端的数据有延迟怎么办" class="headerlink" title="3) 如果遇到了一个客户端有网络延迟因此发送给服务端的数据有延迟怎么办"></a>3) 如果遇到了一个客户端有网络延迟因此发送给服务端的数据有延迟怎么办</h3><ul><li>视觉欺骗：在技能释放时立即播放前摇动画，等服务器确认后再触发伤害判定，提升操作响应感</li><li>输入缓冲：将玩家连续操作（如连招）暂存为队列，网络恢复后批量发送</li></ul><ol><li>状态同步：<ul><li>客户端预测与服务器校正：客户端在发送操作指令后立即本地模拟结果（如移动、技能释放），同时服务器接收后进行权威验证。若结果不一致，服务器下发校正数据，客户端需平滑过渡到正确状态。</li><li>服务器回退补偿（Rewind）：服务器缓存过去一段时间内的游戏状态（如0.5秒），当收到延迟指令时，回退到指令生成时刻的状态重新模拟，确保判定准确性</li></ul></li><li>帧同步：<ul><li>缓冲区动态调整：客户端维护一个指令缓冲区，根据网络延迟动态调整缓冲区大小。高延迟时增大缓冲区（如从3帧扩展至5帧），避免因丢帧导致卡顿</li><li>确定性回滚（Rollback）：客户端本地持续模拟未来帧，当收到服务器确认帧时，回滚并重新模拟差异帧。要求所有逻辑运算具备确定性（如固定随机种子、避免浮点误差）</li><li>预测空指令填补：在未收到服务器帧时，客户端假设当前帧为空指令继续模拟，待服务器数据到达后对比修正。适用于移动类操作的容错</li></ul></li></ol><h3 id="4-断线重连"><a href="#4-断线重连" class="headerlink" title="4) 断线重连"></a>4) 断线重连</h3><h4 id="1-问题背景"><a href="#1-问题背景" class="headerlink" title="1. 问题背景"></a><strong>1. 问题背景</strong></h4><p>在多人在线烹饪游戏中，网络稳定性是关键。玩家可能会因为网络波动或意外掉线，导致游戏体验中断。为了提升用户体验，我们设计了一套断线重连机制，确保玩家能够快速恢复游戏。</p><h4 id="2-实现方案"><a href="#2-实现方案" class="headerlink" title="2. 实现方案"></a><strong>2. 实现方案</strong></h4><ul><li><strong>断线检测</strong>：通过心跳机制检测网络连接状态。客户端定期向服务器发送心跳包，服务器在收到心跳包后回复确认。如果服务器在规定时间内未收到心跳包，会认为客户端掉线。</li><li><strong>重连机制</strong>：<ul><li><strong>重连触发</strong>：客户端在检测到断线后立即启动重连流程。</li><li><strong>重连间隔</strong>：设置合理的重连间隔（如5秒），避免频繁重连导致服务器压力过大。</li><li><strong>重连超时</strong>：设置重连超时时间（如60秒），如果超时未成功重连，则提示用户手动重连。</li></ul></li><li><strong>状态同步</strong>：<ul><li><strong>状态保存</strong>：服务器在客户端断线时保存玩家的状态信息，包括位置、分数、物品等。</li><li><strong>状态恢复</strong>：重连后，服务器将保存的状态信息发送给客户端，确保玩家能够继续游戏。</li></ul></li></ul><h4 id="3-优化建议"><a href="#3-优化建议" class="headerlink" title="3. 优化建议"></a><strong>3. 优化建议</strong></h4><ul><li><strong>缓存机制</strong>：服务器为每个玩家维护一个缓存池，保存断线期间的状态变化。重连后，将缓存的状态变化推送给客户端。</li><li><strong>会话管理</strong>：为每个玩家分配唯一的会话ID，用于识别和管理玩家的连接状态。</li><li><strong>用户界面提示</strong>：在客户端显示重连提示，告知玩家当前的网络状态。</li></ul><h3 id="5-网线被拔掉后，TCP连接还存在吗？"><a href="#5-网线被拔掉后，TCP连接还存在吗？" class="headerlink" title="5) 网线被拔掉后，TCP连接还存在吗？"></a>5) 网线被拔掉后，TCP连接还存在吗？</h3><ul><li><strong>连接状态变化</strong>：  <ul><li><strong>物理层中断</strong>：网线断开导致底层链路不通，双方无法收发任何数据包（包括TCP报文）。  </li><li><strong>TCP保活机制（Keep-Alive）</strong>：若开启此机制，TCP会定期发送探测报文。若长时间无响应（默认约2小时无数据交互），连接会被标记为断开。  </li><li><strong>未开启保活</strong>：若应用未启用保活，连接会一直处于“已建立”状态，直到一方主动关闭或重启。</li></ul></li></ul><ul><li>连接仍然存在：当网线被拔掉后，TCP连接在一定时间内仍然存在。这是因为TCP协议是面向连接的，连接的建立和释放需要经过特定的过程。即使物理连接中断，TCP协议栈会尝试通过重传机制来恢复连接。</li><li>超时断开：如果长时间无法恢复连接，TCP协议栈会检测到连接不可达，最终会释放连接。通常，这个超时时间可以根据系统配置有所不同，一般在几分钟到几十分钟不等。</li></ul><ul><li><strong>最终结果</strong>：  <ul><li>连接在逻辑上仍存在（操作系统未主动关闭），但因物理层中断无法通信，实际已不可用。</li></ul></li></ul><h3 id="6-进程被kill后TCP连接是否存在？"><a href="#6-进程被kill后TCP连接是否存在？" class="headerlink" title="6) 进程被kill后TCP连接是否存在？"></a>6) 进程被kill后TCP连接是否存在？</h3><ul><li><strong>进程终止的影响</strong>：  <ul><li><strong>正常终止（如调用<code>exit()</code>）</strong>：操作系统关闭进程打开的所有文件描述符（包括Socket），触发TCP四次挥手，连接正常关闭。  </li><li><strong>强制终止（如<code>kill -9</code>）</strong>：进程立即终止，但操作系统仍会回收资源，关闭Socket并发送FIN包，连接正常终止。</li></ul></li><li><strong>总结</strong>：无论进程如何终止，内核最终会关闭连接，因此连接不存在。</li></ul><h2 id="10-UGUI优化："><a href="#10-UGUI优化：" class="headerlink" title="10-UGUI优化："></a>10-UGUI优化：</h2><ol><li>动静分离</li><li>图集合并，减少DrawCall</li><li>Overdraw优化：使用九宫格切图（Sliced模式）减少透明区域的绘制；关闭非必要UI元素的RaycastTarget（默认开启），减少射线检测开销</li><li>压缩优化：优先使用ASTC压缩格式，平衡清晰度与内存占用；非透明图采用无Alpha通道的压缩格式</li><li>对象池优化：减少频繁的Instantiate和Destroy操作，使用对象池管理UI元素</li></ol><h2 id="11-AB打包相关"><a href="#11-AB打包相关" class="headerlink" title="11-AB打包相关"></a>11-AB打包相关</h2><h3 id="1-基础流程"><a href="#1-基础流程" class="headerlink" title="1. 基础流程"></a>1. 基础流程</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 默认直接打包</span></span><br><span class="line">[<span class="meta">MenuItem(<span class="string">&quot;AssetBundle/Build Windows&quot;</span>)</span>] <span class="comment">// 需要放入Editor文件夹底下</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">BuildAssetBundle</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> outputPath = Application.streamingAssetsPath;</span><br><span class="line">    <span class="keyword">if</span> (!Directory.Exists(outputPath))</span><br><span class="line">    &#123;</span><br><span class="line">        Directory.CreateDirectory(outputPath);</span><br><span class="line">    &#125;</span><br><span class="line">    BuildPipeline.BuildAssetBundles(outputPath, BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 通过代码指定打包</span></span><br><span class="line"><span class="comment">//    1) 生成AssetBundleBuild对象</span></span><br><span class="line"><span class="comment">//    2) 指定一些参数后设置需要打包的资源路径</span></span><br><span class="line"><span class="comment">//    3) 调用BuildAssetBundles方法打包</span></span><br><span class="line">List&lt;AssetBundleBuild&gt; builds = <span class="keyword">new</span> List&lt;AssetBundleBuild&gt;();</span><br><span class="line">AssetBundleBuild build = <span class="keyword">new</span> AssetBundleBuild();</span><br><span class="line">build.assetBundleName = <span class="string">&quot;ui&quot;</span>;               <span class="comment">// 设置ab包名称</span></span><br><span class="line">build.assetBundleVariant = <span class="string">&quot;unity3d&quot;</span>;       <span class="comment">// 设置变体</span></span><br><span class="line">build.assetNames = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;Assets/Prefabs/Test.prefab&quot;</span> &#125;;  <span class="comment">// 设置资源路径</span></span><br><span class="line">builds.Add(build);</span><br><span class="line">BuildPipeline.BuildAssetBundles(outputPath, builds.ToArray(), BuildAssetBundleOptions.None, BuildTarget.StandaloneWindows);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 加载AB包资源</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    AssetBundle assetBundle = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/ui.unity3d&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (assetBundle != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(<span class="string">&quot;加载成功！&quot;</span>);</span><br><span class="line">        GameObject gameObject = assetBundle.LoadAsset&lt;GameObject&gt;(<span class="string">&quot;TestPanel&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载AB包子资源</span></span><br><span class="line">        Sprite[] sprites = assetBundle.LoadAssetWithSubAssets&lt;Sprite&gt;(<span class="string">&quot;logo_web&quot;</span>);</span><br><span class="line"></span><br><span class="line">        GameObject.Instantiate(gameObject, transform);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 场景和资源要分开AB包</span></span><br><span class="line"><span class="keyword">using</span> UnityEngine.SceneManagement;</span><br><span class="line">AssetBundle assetBundle = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/scenes.unity3d&quot;</span>);</span><br><span class="line">SceneManager.LoadScene(<span class="string">&quot;TestScene&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 依赖包的加载-通过manifest文件</span></span><br><span class="line"><span class="comment">// 先把StreamingAssets文件夹同名的文件当作AB资源加载</span></span><br><span class="line">AssetBundle dependon = AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;StreamingAssets&quot;</span>);</span><br><span class="line"><span class="comment">// 获取manifest</span></span><br><span class="line">AssetBundleManifest manifest = dependon.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line"><span class="comment">// 通过manifest获取所有该资源的依赖</span></span><br><span class="line"><span class="built_in">string</span>[] dependons = manifest.GetAllDependencies(<span class="string">&quot;ui.unity3d&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dependons.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    AssetBundle.LoadFromFile(Application.streamingAssetsPath + <span class="string">&quot;/&quot;</span> + dependons[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-资源路径"><a href="#2-资源路径" class="headerlink" title="2. 资源路径"></a>2. 资源路径</h3><ul><li><code>Application.streamingAssetsPath</code>：是一个<strong>只读路径</strong>，指向游戏包内的“StreamingAssets”文件夹。这个文件夹用于存储那些在游戏打包时需要一起打包的文件，例如音频、视频和图像文件。在运行游戏时，它们是只读的，不能被修改。这个路径对于读取不需要修改的静态文件很有用。</li><li><code>Application.persistentDataPath</code>：是一个<strong>可读写路径</strong>，指向游戏的持久存储位置。这个路径可以用于存储玩家的游戏数据、配置文件和其他持久数据，例如存档和预设。这个路径是在每个游戏平台上不同的，因此如果您需要在不同的游戏平台上读写数据，则需要适当地处理这个路径。（用于处理数据持久化，或作为热更新下载内容的存放目录，因为它可读可写）</li></ul><h3 id="3-压缩方式"><a href="#3-压缩方式" class="headerlink" title="3. 压缩方式"></a>3. 压缩方式</h3><ul><li><em>（LZMA压缩）</em><code>BuildAssetBundleOptions.None</code>：是一种默认的压缩形式，这种标准压缩格式是一个单一LZMA流序列化数据文件，并且在使用前需要解压缩整个包体。LZMA压缩是比较流行的压缩格式，能使压缩后文件达到最小，但是解压相对缓慢，导致加载时需要较长的解压时间。</li><li><em>（LZ4压缩）</em><code>BuildAssetBundleOptions.ChunkBasedCompression</code>：Unity支持LZ4压缩，能使得压缩量更大，而且在使用资源包前不需要解压整个包体。LZ4压缩是一种“Chunk-based”算法，因此当对象从LZ4压缩包中加载时，只有这个对象的对应模块被解压即可，这速度更快，意味着不需要等待解压整个包体。LZ4压缩格式是在Unity5.3版本中开始引入的，之前的版本不可用。</li><li><em>（不压缩）</em><code>BuildAssetBundleOptions.UncompressedAssetBundle</code>：不压缩的方式打包后包体会很大，导致很占用空间，但是一旦下载Assetbundle，访问非常快。不推荐这种方式打包，因为现在的加载功能做的很友好了，完全可以用加载界面来进行后台加载资源，而且时间也不长。</li></ul><h3 id="4-打包框架相关"><a href="#4-打包框架相关" class="headerlink" title="4. 打包框架相关"></a>4. 打包框架相关</h3><h4 id="1-为什么需要BuildSetting-xml文件配置"><a href="#1-为什么需要BuildSetting-xml文件配置" class="headerlink" title="(1) 为什么需要BuildSetting.xml文件配置"></a>(1) 为什么需要BuildSetting.xml文件配置</h4><ul><li><code>BuildSetting</code> 文件中定义了项目名称、打包根目录和具体的打包项。每个打包项（<code>BuildItem</code>）包含了资源路径、资源类型、Bundle 类型和后缀名。打包的基本策略是根据这些配置自动化生成对应的AB包文件。<ul><li>指定资源路径（AssetPath）：定义需要打包的资源所在路径。</li><li>指定资源类型（ResourceType）：区分直接打包的资源（Direct）和依赖资源（Dependency）。</li><li>指定打包粒度（BundleType）：决定资源是以文件为单位打包（File）、以目录为单位打包（Directory），还是以全局打包（All）。</li><li>指定资源后缀（Suffix）：过滤需要打包的资源类型（如.cs、.dll等）。</li></ul></li><li>此外还可以配置不同平台（Windows和Mac）不同的打包策略<ul><li>比如不同平台可能有不同的性能要求，因此可以在打包时为不同平台设置不同的压缩方式</li><li>比如某些资源可能只针对特定平台，例如高分辨率的纹理或特殊格式的音频文件。这时可以在 <code>BuildItem</code> 中加入条件，设置仅针对特定平台的打包规则</li></ul></li><li>示例：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BuildItem</span> <span class="attr">AssetPath</span>=<span class="string">&quot;Assets/AssetBundle/Common/&quot;</span> <span class="attr">ResourceType</span>=<span class="string">&quot;Direct&quot;</span> <span class="attr">BundleType</span>=<span class="string">&quot;File&quot;</span> <span class="attr">Suffix</span>=<span class="string">&quot;.renderTexture&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BuildItem</span> <span class="attr">AssetPath</span>=<span class="string">&quot;Assets/AssetBundle/Atlas/&quot;</span> <span class="attr">ResourceType</span>=<span class="string">&quot;Direct&quot;</span> <span class="attr">BundleType</span>=<span class="string">&quot;Directory&quot;</span> <span class="attr">Suffix</span>=<span class="string">&quot;.png|.spriteatlas&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-具体流程"><a href="#2-具体流程" class="headerlink" title="(2) 具体流程"></a>(2) 具体流程</h4><ul><li>在 <code>Builder</code> 类中定义了完整的打包流程，其中包含以下关键步骤：<ol><li><strong>加载打包设置</strong>：通过 <code>LoadSetting</code> 方法加载并解析 XML 格式的打包配置文件，确保所有打包规则都被正确读取和初始化。</li><li><strong>搜集资源和依赖</strong>：打包前通过 <code>Collect()</code> 方法搜集需要打包的资源和它们的依赖。在这个过程中，项目会遍历所有 <code>BuildItem</code> 规则，找到符合条件的文件并检查它们的依赖关系。依赖关系是通过 <code>AssetDatabase.GetDependencies</code> 方法获得的，这些信息会被用来打包完整的资源链。此时还需判断哪些资源是公共资源即依赖是否被多个资源引用，若被多个资源引用则需要单独打包。</li><li><strong>生成 AB 名称</strong>：根据资源路径和粒度类型（文件、目录或全项目打包）生成唯一的 AB 名称。不同类型的资源打包规则决定了最终的 Bundle 名称。例如，<code>File</code> 类型会直接使用文件名，而 <code>Directory</code> 类型会根据目录名生成对应的 AB 名称。</li><li><strong>打包 AssetBundle</strong>：通过 <code>BuildBundle()</code> 方法调用 Unity 的 <code>BuildPipeline.BuildAssetBundles</code> 方法打包所有资源。在打包完成后，还会生成一个 <code>manifest</code> 文件，记录打包文件的详细信息（资源名称、依赖关系等），以便运行时加载。</li><li><strong>清理多余文件</strong>：调用ClearAssetBundle方法删除不必要的文件。</li><li><strong>打包Manifest</strong>：调用BuildManifest方法将资源描述文件打包成AssetBundle。里面包含了所有打包的资源信息，具体包括资源路径、AB名称、依赖关系等。</li></ol></li></ul><h4 id="3-Manifest文件"><a href="#3-Manifest文件" class="headerlink" title="(3) Manifest文件"></a>(3) Manifest文件</h4><ul><li><p>在Unity的AssetBundle打包机制中，manifest文件分为<strong>单个AB包的局部manifest</strong>和<strong>全局主manifest</strong>两种类型，以下是具体示例和逻辑解析：</p></li><li><p><strong>一、局部manifest文件（每个AB包独立生成）</strong>：每个AssetBundle都会生成一个对应的.manifest文件，该文件记录了该AB包的元数据信息，包括：</p><ul><li><strong>CRC校验码</strong>：验证文件完整性</li><li><strong>哈希值</strong>：用于版本标识</li><li><strong>依赖关系</strong>：该AB包依赖的其他AB包名称</li><li><strong>包含的Asset清单</strong>：资源路径列表</li></ul></li><li><p>示例：假设打包生成<code>material.unity3d</code>和<code>texture.unity3d</code>两个AB包，它们的局部manifest文件内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// material.unity3d.manifest</span></span><br><span class="line">ManifestFileVersion: <span class="number">0</span></span><br><span class="line">CRC: <span class="number">1234567890</span></span><br><span class="line">Hashes:</span><br><span class="line">  AssetFileHash: <span class="number">8</span>b6db55a2344f068cf8a9be0a662ba15</span><br><span class="line">Assets:</span><br><span class="line">  Asset_0: Assets/Materials/Red.mat</span><br><span class="line">Dependencies:</span><br><span class="line">  texture.unity3d</span><br><span class="line"></span><br><span class="line"><span class="comment">// texture.unity3d.manifest</span></span><br><span class="line">ManifestFileVersion: <span class="number">0</span></span><br><span class="line">CRC: <span class="number">0</span>987654321</span><br><span class="line">Hashes:</span><br><span class="line">  AssetFileHash: <span class="number">37</span>ad974993dbaa77485dd2a0c38f347a</span><br><span class="line">Assets:</span><br><span class="line">  Asset_0: Assets/Textures/Red_Texture.png</span><br><span class="line">Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>作用：开发者可通过该文件检查AB包内容是否被篡改，或对比版本差异。</p></li><li><p><strong>二、全局主manifest文件（唯一的总清单）</strong>：主manifest文件由Unity自动生成，通常以打包输出目录命名（如<code>AssetBundles.manifest</code>），其核心功能包括：</p><ul><li><strong>完整AB包列表</strong>：记录所有生成的AB包名称</li><li><strong>全量依赖关系</strong>：描述所有AB包之间的依赖拓扑</li><li><strong>哈希版本控制</strong>：每个AB包的哈希值用于增量更新</li></ul></li><li><p>示例：当打包目录中存在<code>material.unity3d</code>和<code>texture.unity3d</code>时，主manifest内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ManifestFileVersion: <span class="number">0</span></span><br><span class="line">AssetBundleManifest:</span><br><span class="line">  AssetBundleInfos:</span><br><span class="line">    Info_0:</span><br><span class="line">      Name: material.unity3d</span><br><span class="line">      Dependencies: &#123;texture.unity3d&#125;</span><br><span class="line">    Info_1:</span><br><span class="line">      Name: texture.unity3d</span><br><span class="line">      Dependencies: &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>运行时加载逻辑</strong>：通过加载主manifest，可动态获取任意AB包的依赖链。例如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载主manifest</span></span><br><span class="line">AssetBundle mainBundle = AssetBundle.LoadFromFile(<span class="string">&quot;AssetBundles&quot;</span>);</span><br><span class="line">AssetBundleManifest manifest = mainBundle.LoadAsset&lt;AssetBundleManifest&gt;(<span class="string">&quot;AssetBundleManifest&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取material.unity3d的所有依赖</span></span><br><span class="line"><span class="built_in">string</span>[] dependencies = manifest.GetAllDependencies(<span class="string">&quot;material.unity3d&quot;</span>); </span><br><span class="line"><span class="comment">// 返回 [&quot;texture.unity3d&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="4-加载AB包时为什么要字典数据结构"><a href="#4-加载AB包时为什么要字典数据结构" class="headerlink" title="(4) 加载AB包时为什么要字典数据结构"></a>(4) 加载AB包时为什么要字典数据结构</h4><ul><li>字典值是路径，键是AB包对象，AB包对象里面有引用计数成员变量</li><li>作用：<ul><li>快速查找：通过AB包的URL可以快速找到对应的AB包对象。 </li><li>引用计数管理：每个AB包对象都有一个引用计数成员变量，用于管理AB包的加载和卸载。</li></ul></li><li>引用计数管理：<ul><li>加载时增加引用计数：<ul><li>当AB包被加载时，调用AddReference方法增加引用计数。</li><li>如果AB包已经在字典中存在，则直接增加引用计数。</li></ul></li><li>卸载时减少引用计数：<ul><li>当AB包不再需要时，调用ReduceReference方法减少引用计数。</li><li>当引用计数为0时，AB包会被卸载。</li></ul></li><li>映射关系：通过BundleManager的GetFileUrl方法，可以将AB包的名字转换为路径。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>概率论</title>
      <link href="/posts/155618b9.html"/>
      <url>/posts/155618b9.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-随机事件与概率"><a href="#1-随机事件与概率" class="headerlink" title="1. 随机事件与概率"></a>1. 随机事件与概率</h2><ul><li>条件概率：$P(A \mid B) &#x3D; \frac{P(A \cap B)}{P(B)}$</li><li>全概率公式：$P(A) &#x3D; P(A|B)P(B) + P(A|\overline{B})P(\overline{B})$</li><li>贝叶斯公式：<br>$$<br>P(B \mid A) &#x3D; \frac{P(A \cap B)}{P(A)} &#x3D; \frac{P(B)P(A \mid B)}{P(B)P(A \mid B) + P(\overline{B})P(A \mid \overline{B})}<br>$$<ul><li>结合条件概率和全概率公式</li></ul></li><li>独立性：$P(A \cap B) &#x3D; P(A)P(B)$</li></ul><h2 id="2-一维随机变量及其分布"><a href="#2-一维随机变量及其分布" class="headerlink" title="2. 一维随机变量及其分布"></a>2. 一维随机变量及其分布</h2><ul><li>分别列与分布函数<ul><li>分布函数：$F(x) &#x3D; P(X \leq x)$</li></ul></li><li>离散型随机变量的分布<ul><li>伯努利分布：$P(X&#x3D;k) &#x3D; C_{n}^{k}p^k(1-p)^{1-k}$</li><li>二项分布：$P(X&#x3D;k) &#x3D; p^k(1-p)^{n-k}$</li><li>泊松分布：$P(X&#x3D;k) &#x3D; \frac{\lambda^k e^{-\lambda}}{k!}$</li></ul></li><li>概率密度函数：是指随机变量取值在某个区间内的概率，通过对分布函数求导得到<ul><li>离散型随机变量的概率密度函数：$f(x) &#x3D; P(X&#x3D;x)$</li><li>连续型随机变量的概率密度函数：$f(x) &#x3D; \frac{dF(x)}{dx}$</li></ul></li><li>连续型随机变量的分布<ul><li>均匀分布：$f(x) &#x3D; \frac{1}{b-a}$，$F(x) &#x3D; \frac{x-a}{b-a}$</li><li>指数分布：$f(x) &#x3D; \lambda e^{-\lambda x}$，$F(x) &#x3D; 1 - e^{-\lambda x}$</li><li>正态分布：$f(x) &#x3D; \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}$，$F(x) &#x3D; \frac{1}{2}\left[1 + \text{erf}\left(\frac{x-\mu}{\sqrt{2}\sigma}\right)\right]$</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/posts/5751eea2.html"/>
      <url>/posts/5751eea2.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1-Lambda表达式"></a>1-Lambda表达式</h2><ul><li>参考资料：<a href="https://blog.csdn.net/m0_60134435/article/details/136151698">Lambda表达式详解</a></li><li>Lambda表达式虽然是一种语法糖，但它本质上也是一种函数对象，也就是重载了 operator() 的类的对象。每一个 Lambda表达式都对应一个唯一的匿名类，这个类的名称由编译器自动生成，因此我们无法直接获取或使用。</li><li>Lambda表达式的捕获列表实际上是匿名类的数据成员，Lambda表达式的参数列表和返回值类型实际上是匿名类的 operator() 的参数列表和返回值类型，Lambda表达式的函数体实际上是匿名类的 operator() 的函数体。</li></ul><h2 id="2-C-多线程"><a href="#2-C-多线程" class="headerlink" title="2-C++多线程"></a>2-C++多线程</h2><ul><li>参考资料：<a href="https://blog.csdn.net/weixin_45031801/article/details/142705048">C++多线程详解</a></li></ul><h3 id="1-mutex与lock-guard"><a href="#1-mutex与lock-guard" class="headerlink" title="1) mutex与lock_guard"></a>1) mutex与lock_guard</h3><ul><li>通常不直接使用 mutex，用lock_guard更加安全, 更加方便。lock_guard简化了 lock&#x2F;unlock 的写法, lock_guard在构造时自动锁定互斥量, 而在退出作用域时会析构自动解锁, 保证了上锁解锁的正确操作, 正是典型的 RAII 机制</li></ul><h3 id="2-thread相关"><a href="#2-thread相关" class="headerlink" title="2) thread相关"></a>2) thread相关</h3><ul><li>threah 类是禁止拷贝的，不允许拷贝构造和拷贝赋值，但是可以移动构造和移动赋值，可以将一个线程对象关联线程的状态转移给其他线程对象，并且转移期间不影响线程的执行</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread t1;</span><br><span class="line"><span class="comment">//... </span></span><br><span class="line">t1 = <span class="built_in">thread</span>(func, <span class="number">10</span>);</span><br><span class="line">t<span class="number">1.</span><span class="built_in">join</span>();</span><br></pre></td></tr></table></figure><h3 id="3-条件变量"><a href="#3-条件变量" class="headerlink" title="3) 条件变量"></a>3) 条件变量</h3><ul><li>优先使用带标志位的 wait 函数，避免虚假唤醒</li><li>获取锁后如果条件不满足，应该立即调用 wait 函数，释放锁，让其他线程有机会获取锁，避免死锁</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 定义共享变量和相关的同步工具</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">std::mutex mtx; <span class="comment">// 互斥锁</span></span><br><span class="line">std::condition_variable cv; <span class="comment">// 条件变量</span></span><br><span class="line"><span class="type">bool</span> is_ready = <span class="literal">false</span>;  <span class="comment">// 添加全局标志位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        count++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;计数增加到: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        is_ready = <span class="literal">true</span>;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> is_ready; &#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;当前计数是: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        is_ready = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-生产者-消费者模式"><a href="#4-生产者-消费者模式" class="headerlink" title="4) 生产者-消费者模式"></a>4) 生产者-消费者模式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 共享缓冲区</span></span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"><span class="comment">// 最大缓冲区大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> BUFFER_SIZE = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 互斥锁和条件变量</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv_producer;</span><br><span class="line">std::condition_variable cv_consumer;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 生产者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> product = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 等待缓冲区有空位</span></span><br><span class="line">        cv_producer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> buffer.<span class="built_in">size</span>() &lt; BUFFER_SIZE; &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 生产数据并放入缓冲区</span></span><br><span class="line">        product++;</span><br><span class="line">        buffer.<span class="built_in">push</span>(product);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; produced: &quot;</span> &lt;&lt; product &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 通知消费者有数据可取</span></span><br><span class="line">        cv_consumer.<span class="built_in">notify_all</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 释放锁，生产间隔一段时间（模拟生产过程）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 消费者线程函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 等待缓冲区有数据</span></span><br><span class="line">        cv_consumer.<span class="built_in">wait</span>(lock, []() &#123; <span class="keyword">return</span> !buffer.<span class="built_in">empty</span>(); &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 消费数据</span></span><br><span class="line">        <span class="type">int</span> consumed_product = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Consumer &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot; consumed: &quot;</span> &lt;&lt; consumed_product &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 通知生产者缓冲区有空位</span></span><br><span class="line">        cv_producer.<span class="built_in">notify_all</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 释放锁，消费间隔一段时间（模拟消费过程）</span></span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">150</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建生产者和消费者线程</span></span><br><span class="line">    <span class="function">std::thread <span class="title">producer1</span><span class="params">(producer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">producer2</span><span class="params">(producer, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer1</span><span class="params">(consumer, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer2</span><span class="params">(consumer, <span class="number">2</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 让主线程等待生产者和消费者线程（通常不会结束）</span></span><br><span class="line">    producer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    producer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    consumer<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-异步编程"><a href="#3-异步编程" class="headerlink" title="3-异步编程"></a>3-异步编程</h2><ul><li>参考资料：<a href="https://xas-sunny.blog.csdn.net/article/details/140827401">C++异步操作</a></li></ul><h2 id="4-原子操作与内存屏障"><a href="#4-原子操作与内存屏障" class="headerlink" title="4-原子操作与内存屏障"></a>4-原子操作与内存屏障</h2><ul><li>参考资料：<a href="https://zhuanlan.zhihu.com/p/27554789673">原子操作与内存屏障</a></li><li>CAS（Compare and Swap）：CAS 是一种无锁的原子操作，它比较内存中的值与预期值是否相等，如果相等则将内存中的值更新为新值。CAS 操作通常由硬件指令实现，具有高效的执行速度。</li></ul><h2 id="5-RAII"><a href="#5-RAII" class="headerlink" title="5-RAII"></a>5-RAII</h2><ul><li>参考资料: <a href="https://xas-sunny.blog.csdn.net/article/details/142737361">RAII详解</a></li></ul><h2 id="6-内存管理相关"><a href="#6-内存管理相关" class="headerlink" title="6-内存管理相关"></a>6-内存管理相关</h2><ul><li><p>参考资料：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/344377490">C++内存管理</a></li><li><a href="https://xas-sunny.blog.csdn.net/article/details/127481057">C++内存函数</a></li><li><a href="https://blog.csdn.net/qq_58158950/article/details/142751390">malloc与mmap</a></li></ul></li><li><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成</p><ul><li>brk，直接将数据段(.data)的最高地址指针_edata往高地址推；</li><li>mmap，在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</li></ul></li><li><p>这两种方式分配的都是虚拟内存，没有分配物理内存</p></li><li><p>malloc小于128k的内存，使用brk分配内存（内存池），malloc大于128k的内存，使用mmap分配内存</p></li><li><p>频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。</p></li><li><p>brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗。</p></li><li><p>memcpy，memmove，memset，memcmp</p></li><li><p>memcpy不能拷贝重叠区域而memmove可以</p></li><li><p>小端存储：低地址存放低位，高地址存放高位；大端存储：低地址存放高位，高地址存放低位（一般PC默认小端）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下写法可以判断大小端</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span>* p = (<span class="type">char</span>*)&amp;a;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;小端&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;大端&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虚拟内存，也就是把不连续的物理内存块映射到虚拟地址空间（virtual address space）。使内存页对于应用程序来说看起来是连续的。</li></ul><h2 id="7-智能指针"><a href="#7-智能指针" class="headerlink" title="7-智能指针"></a>7-智能指针</h2><ul><li>智能指针就是帮助管理动态分配的内存的，它会帮助自动释放new出来的内存，从而避免内存泄漏:</li><li>参考资料：<ul><li><a href="https://xas-sunny.blog.csdn.net/article/details/140594215">智能指针1</a></li><li><a href="https://blog.csdn.net/cpp_learner/article/details/118912592">智能指针2</a></li><li><a href="https://www.cnblogs.com/sunsky303/p/16497592.html">智能指针3</a></li></ul></li><li>unique_ptr：由于指针或引用在离开作用域是不会调用析构函数的，但对象在离开作用域会调用析构函数。unique_ptr本质是一个类，将拷贝构造函数和赋值构造函数声明为delete就可以实现独占式，只允许移动构造和移动赋值</li><li>shared_ptr（unique也是）线程不安全但引用计数线程安全<ul><li>引用计数安全：因原子操作，多线程增减引用计数是安全的</li><li>对象操作不安全：同一shared_ptr实例的修改需同步，否则可能导致数据竞争</li></ul></li><li>推荐用make_shared而不是new的原因：<ul><li>内存分配优化：<ul><li>new需要两次独立的内存分配，分配对象内存（new T）和分配控制块（引用计数、弱引用计数等）-&gt; 这种不连续的内存分配可能导致内存碎片化</li><li>make_shared将对象和控制块合并为单次内存分配，直接在堆上分配一块连续内存，包含对象和控制块。这不仅减少内存碎片，还提升缓存局部性（CPU缓存命中率更高）</li></ul></li><li>缓存命中率更高</li><li>异常安全：make_shared保证构造和分配原子化，避免异常导致资源未释放</li></ul></li></ul><h2 id="8-初始化列表"><a href="#8-初始化列表" class="headerlink" title="8-初始化列表"></a>8-初始化列表</h2><ul><li>如果不使用初始化列表，成员变量会先调用默认构造函数，然后在构造函数体内通过赋值运算符赋值；（对于类类型成员变量，未使用初始化列表时确实会先调用默认构造函数再赋值，内置类型如int则不需要）</li><li>使用初始化列表时，成员变量直接调用拷贝构造函数或带参数的构造函数，避免了一次默认构造 + 赋值的开销</li><li>const成员，引用成员，没有默认构造函数的成员，必须使用初始化列表进行初始化</li></ul><h2 id="9-STL"><a href="#9-STL" class="headerlink" title="9-STL"></a>9-STL</h2><ul><li>当我们使用C++的容器时，我们往往需要提供两个参数，一个是容器的类型，另一个是容器的分配器。其中第二个参数有默认参数，即C++自带的分配器（allocator）</li><li>new操作将内存分配和对象构造组合在一起，而allocator的意义在于将内存分配和构造分离。这样就可以分配大块内存，而只在真正需要时才执行对象创建操作，从而提高内存管理效率</li></ul><h3 id="1-vector相关："><a href="#1-vector相关：" class="headerlink" title="1. vector相关："></a>1. vector相关：</h3><ul><li>里面存对象指针而不是对象的好处：支持多态性，vector可以存储指向基类的指针，而这些指针可以指向派生类的对象，从而实现多态性；避免存储派生类对象时发生对象切片（派生类对象被切割为基类对象）</li><li>如果直接删除元素会导致迭代器失效，为了避免这个情况可以用list代替vector；也可以延迟删除，在需要删除元素时，将其标记为待删除，然后在适当的时候再进行删除操作；也可以索引遍历再删除后调整索引</li><li>resize操作可能会使迭代器失效，对于所有的容器类型，如果resize操作压缩了容器，则指向已删除的元素的迭代器失效</li><li><a href="https://blog.csdn.net/qq_31638535/article/details/146308267">vector存储地址相关</a><ul><li>vector 的头部可能在栈上（局部变量）或堆上（new 分配）；vector 的数据部分始终在堆上，不会受 vector 头部位置影响</li><li>resize() 和 reserve() 只影响堆上的数据，不影响头部位置</li><li>作为函数返回值时，现代 C++ 会自动优化 vector 的移动或拷贝，不会泄漏内存</li><li>尽量让 vector 负责自身的内存管理，避免使用指针存储 vector</li><li>vector存储类对象时如果发生扩容且类对象定义了移动构造函数则扩容拷贝时对象会被移动，而不是拷贝否则会调用拷贝构造函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;    <span class="comment">// vector&lt;int&gt; c(10, 0);一样的效果</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; *b = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">b-&gt;<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">b-&gt;<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; &amp;a &lt;&lt; endl;                 <span class="comment">// vector对象地址，在栈上</span></span><br><span class="line">cout &lt;&lt; a.<span class="built_in">data</span>() &lt;&lt; endl;           <span class="comment">// vector对象中第一个元素的地址，在堆上</span></span><br><span class="line">cout &lt;&lt; &amp;a[<span class="number">0</span>] &lt;&lt; endl;              <span class="comment">// vector对象中第一个元素的地址，在堆上</span></span><br><span class="line">cout &lt;&lt; &amp;a[<span class="number">1</span>] &lt;&lt; endl;              <span class="comment">// vector对象中第二个元素的地址，在堆上</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;b &lt;&lt; endl;                 <span class="comment">// vector指针地址，在栈上</span></span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;                  <span class="comment">// vector指针指向的vector对象地址，在堆上</span></span><br><span class="line">cout &lt;&lt; &amp;b[<span class="number">0</span>] &lt;&lt; endl;              <span class="comment">// vector指针指向的vector对象地址，在堆上</span></span><br><span class="line">cout &lt;&lt; b-&gt;<span class="built_in">data</span>() &lt;&lt; endl;          <span class="comment">// vector对象中第一个元素的地址，在堆上</span></span><br><span class="line">cout &lt;&lt; &amp;(*b)[<span class="number">0</span>] &lt;&lt; endl;           <span class="comment">// vector对象中第一个元素的地址，在堆上</span></span><br><span class="line">cout &lt;&lt; &amp;(*b)[<span class="number">1</span>] &lt;&lt; endl;           <span class="comment">// vector对象中第二个元素的地址，在堆上</span></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// 000000FFE70FFA08</span></span><br><span class="line"><span class="comment">// 000002471790E810</span></span><br><span class="line"><span class="comment">// 000002471790E810</span></span><br><span class="line"><span class="comment">// 000002471790E814</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"><span class="comment">// 000000FFE70FFA48</span></span><br><span class="line"><span class="comment">// 000002471790D420</span></span><br><span class="line"><span class="comment">// 000002471790D420</span></span><br><span class="line"><span class="comment">// 000002471790A300</span></span><br><span class="line"><span class="comment">// 000002471790A300</span></span><br><span class="line"><span class="comment">// 000002471790A304</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-（unordered-map-set）哈希表相关："><a href="#2-（unordered-map-set）哈希表相关：" class="headerlink" title="2. （unordered_map&#x2F;set）哈希表相关："></a>2. （unordered_map&#x2F;set）哈希表相关：</h3><ul><li>解决哈希冲突后想获取原来元素需要比对哈希值和key，而哈希表的value是一个链表，链表中的元素是哈希冲突的元素，因此需要遍历链表才能找到原来的元素</li></ul><h2 id="10-虚函数相关"><a href="#10-虚函数相关" class="headerlink" title="10-虚函数相关"></a>10-虚函数相关</h2><ul><li>构造函数是初始化对象（包括vptr）的过程。在构造函数执行时，对象的内存布局尚未完成，vptr还未正确指向虚表，此时无法通过虚表调用函数。（比如基类指针指向子类对象，此时由于调用构造函数被重写了需要虚指针去查找虚表，但是还没构造就没有虚指针所以矛盾了）</li><li>对象可以有多个虚指针：当一个类有多个基类时，每个基类都有自己的虚表。因此，派生类的对象会有多个虚指针，分别指向不同的虚表</li><li>菱形继承下：<ul><li>比如B，C各自继承A，D继承了A：此时内存中BC各有一份对A的拷贝</li><li>解决方案：B和C各自继承A的虚基类，D继承B和C，这样内存中只会存在一份A在D的末尾</li><li>中间类BC通过通过虚基类指针（vbptr）指向虚基类表，表中存储偏移量以定位唯一的A实例，D则直接访问A</li></ul></li></ul><h2 id="11-左值右值相关："><a href="#11-左值右值相关：" class="headerlink" title="11-左值右值相关："></a>11-左值右值相关：</h2><ul><li>参考资料：<a href="https://www.cnblogs.com/KillerAery/p/12802771.html">左值右值</a></li><li>左值（lvalue） ：指持久存在（有变量名）的对象或返还值类型为左值引用的返还值，是不可移动的;右值（rvalue） ：包含了 将亡值、纯右值，是可移动（可被右值引用类型匹配）的值</li><li>字符字面量是唯一不可算入右值的字面量，因为它实际存储在静态内存区，是持久存在的</li><li>右值引用类型只是用于匹配右值，而并非表示一个右值。因此，尽量不要声明右值引用类型的变量，而只在函数形参使用它以匹配右值</li><li>C++右值引用作用:（1）延长右值的生命周期，优化C++的性能（2）引入移动语义</li><li>常量左值引用可以接受右值: <code>const int&amp; a = 10;</code></li><li>std::move 的主要作用是将一个对象转换为右值引用，从而允许移动构造函数或移动赋值运算符接管该对象的资源。它不会真正“移动”对象，而是通过类型转换让对象可以被移动语义所利用</li></ul><h2 id="12-万能引用，引用折叠，完美转发"><a href="#12-万能引用，引用折叠，完美转发" class="headerlink" title="12-万能引用，引用折叠，完美转发:"></a>12-万能引用，引用折叠，完美转发:</h2><ul><li>参考资料：<a href="https://zhuanlan.zhihu.com/p/369203981">万能引用，引用折叠，完美转发</a></li></ul><h2 id="13-四种强制类型转换"><a href="#13-四种强制类型转换" class="headerlink" title="13-四种强制类型转换:"></a>13-四种强制类型转换:</h2><ul><li>参考资料：<a href="https://blog.csdn.net/weixin_45031801/article/details/142147962">强制类型转换</a></li></ul><h2 id="14-关键字相关（const-volatile-register-inline）："><a href="#14-关键字相关（const-volatile-register-inline）：" class="headerlink" title="14-关键字相关（const, volatile, register, inline）："></a>14-关键字相关（const, volatile, register, inline）：</h2><ul><li>参考资料：<a href="https://blog.csdn.net/suifengme/article/details/141299556">各种关键字</a></li><li>noexcept：性能优化，减少异常处理开销</li><li>explicit：防止隐式构造和隐式类型转换</li><li>const如果是在局部声明还是存储在栈中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123; <span class="comment">// 没有使用 explicit</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数调用，值为：&quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;打印 MyClass 对象&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">42</span>); <span class="comment">// 42 会被隐式转换为 MyClass 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-移动-拷贝构造函数，移动-拷贝赋值运算符"><a href="#15-移动-拷贝构造函数，移动-拷贝赋值运算符" class="headerlink" title="15-移动&#x2F;拷贝构造函数，移动&#x2F;拷贝赋值运算符:"></a>15-移动&#x2F;拷贝构造函数，移动&#x2F;拷贝赋值运算符:</h2><ul><li>参考资料：<a href="https://developer.aliyun.com/article/1350271">移动构造函数&#x2F;移动赋值运算符</a><ul><li>移动赋值运算符返回左值引用是为了支持链式赋值即:<code>obj1 = obj2 = std:move(obj3);</code></li><li>移动赋值运算符的参数虽然是右值引用，但在函数的作用域内，它实际上可以被视为一个左值，因为你可以取它的地址:<code>if (this != &amp;other) &#123;&#125;</code></li><li>移动语义: 将对象持有的资源或内容转移给另一个对象</li></ul></li><li>参考资料：<a href="https://zhuanlan.zhihu.com/p/573937462">拷贝构造函数&#x2F;赋值运算符重载</a><ul><li>拷贝构造函数形参设置成const是为了保护源对象不被修改，还有可以支持右值传入</li><li>拷贝构造函数形参使用引用是为了防止值传递时无限调用</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// 用于 std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* data; <span class="comment">// 指向动态分配的整数数组</span></span><br><span class="line">    <span class="type">int</span> size;  <span class="comment">// 数组大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> size) : <span class="built_in">size</span>(size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;普通构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">size</span>(other.size) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="built_in">copy</span>(other.data, other.data + size, data);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">size</span>(other.size), <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>; <span class="comment">// 防止析构时释放原对象的资源</span></span><br><span class="line">        other.size = <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; <span class="comment">// 防止自赋值</span></span><br><span class="line">            <span class="keyword">delete</span>[] data; <span class="comment">// 释放当前对象的资源</span></span><br><span class="line">            size = other.size;</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">            <span class="built_in">copy</span>(other.data, other.data + size, data);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝赋值运算符调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> &#123; <span class="comment">// 性能优化，减少异常处理开销</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123; <span class="comment">// 防止自赋值</span></span><br><span class="line">            <span class="keyword">delete</span>[] data; <span class="comment">// 释放当前对象的资源</span></span><br><span class="line">            size = other.size;</span><br><span class="line">            data = other.data;</span><br><span class="line">            other.data = <span class="literal">nullptr</span>; <span class="comment">// 防止析构时释放原对象的资源</span></span><br><span class="line">            other.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;移动赋值运算符调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 调用普通构造函数</span></span><br><span class="line">    MyClass obj2 = obj1; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    MyClass obj3 = <span class="built_in">move</span>(obj1); <span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    obj2 = obj3; <span class="comment">// 调用拷贝赋值运算符</span></span><br><span class="line">    obj3 = <span class="built_in">move</span>(obj2); <span class="comment">// 调用移动赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-指针与引用"><a href="#16-指针与引用" class="headerlink" title="16-指针与引用"></a>16-指针与引用</h2><ul><li>引用是指针的语法糖，在汇编层面是通过指针实现的，引用可以理解为指针常量</li><li>不同点从：<ul><li>定义：指针是存储变量地址，引用是变量的别名</li><li>初始化：指针可以初始化为nullptr，引用必须在定义时初始化</li><li>可变性：指针可以改变指向，引用不可改变</li><li>操作：指针可以++和多级且可以*p解引用，引用不能这些操作</li><li>使用场景：指针一般动态内存管理（new），引用在运算符重载时返回可以链式调用</li></ul></li></ul><h2 id="17-const"><a href="#17-const" class="headerlink" title="17-const"></a>17-const</h2><ul><li>const和*：const在左定值，在右定方向</li></ul><h2 id="18-AVL与红黑树"><a href="#18-AVL与红黑树" class="headerlink" title="18-AVL与红黑树"></a>18-AVL与红黑树</h2><ul><li>AVL：平衡二叉搜索树，左右子树高度差不超过1，删除操作会比较频繁变换树</li><li>红黑树：删除操作不频繁变换树</li></ul><h2 id="19-指针，数组，函数"><a href="#19-指针，数组，函数" class="headerlink" title="19-指针，数组，函数"></a>19-指针，数组，函数</h2><ul><li><code>int *p = new int(10);</code>：表示堆上分配一个int类型的变量，值为10</li><li><code>int *p = new int[10];</code>：表示大小为10的一维数组</li><li><code>int *p[10]</code>：（[]优先级高于*）表示大小为10的一维数组，每个元素都是int指针，初始化时需要逐个循环初始化不能直接new int[10]</li><li><code>int (*p)[10] = new int[10][10];</code>：表示大小为10x10的二维数组</li><li><code>int *p()</code>：表示函数，返回值为int*</li><li><code>int (*p)()</code>：表示函数指针，指向返回值为int的函数</li></ul><h3 id="总结对比表"><a href="#总结对比表" class="headerlink" title="总结对比表"></a><strong>总结对比表</strong></h3><table><thead><tr><th><strong>声明</strong></th><th><strong>类型</strong></th><th><strong>含义</strong></th><th><strong>动态内存释放方式</strong></th></tr></thead><tbody><tr><td><code>int *p = new int(10);</code></td><td><code>int*</code></td><td>堆上单个 <code>int</code>，值为 10</td><td><code>delete p;</code></td></tr><tr><td><code>int *p = new int[10];</code></td><td><code>int*</code></td><td>堆上 <code>int[10]</code> 一维数组</td><td><code>delete[] p;</code></td></tr><tr><td><code>int *p[10]</code></td><td><code>int*[10]</code></td><td>栈上的指针数组（每个元素需单独初始化）</td><td>循环 <code>delete</code> 或 <code>delete[]</code></td></tr><tr><td><code>int (*p)[10]</code></td><td>数组指针</td><td>指向二维数组的指针（第二维必须为编译期常量）</td><td><code>delete[] p;</code></td></tr><tr><td><code>int *p()</code></td><td>函数声明</td><td>函数返回 <code>int*</code></td><td>无（函数无动态内存）</td></tr><tr><td><code>int (*p)()</code></td><td>函数指针</td><td>指向返回 <code>int</code> 的函数</td><td>无（指针本身在栈上）</td></tr></tbody></table><h2 id="19-内存映射"><a href="#19-内存映射" class="headerlink" title="19-内存映射"></a>19-内存映射</h2><h3 id="一、内存映射的本质与作用"><a href="#一、内存映射的本质与作用" class="headerlink" title="一、内存映射的本质与作用"></a><strong>一、内存映射的本质与作用</strong></h3><ol><li><p><strong>什么是内存映射？</strong><br>内存映射是一种将<strong>文件或设备</strong>直接映射到进程虚拟地址空间的技术。通过<code>mmap</code>系统调用，文件内容可以被视为内存数组，进程通过指针直接读写文件，无需传统的<code>read</code>&#x2F;<code>write</code>系统调用。其核心优势在于<strong>减少数据拷贝次数</strong>，提升I&#x2F;O效率。  </p><ul><li><strong>文件映射</strong>：将磁盘文件映射到内存，修改会同步到文件（如数据库文件加载）；  </li><li><strong>匿名映射</strong>：分配不与文件关联的内存（如<code>malloc</code>大块内存时使用）。</li></ul></li><li><p><strong>内存映射的流程</strong>  </p><ul><li>进程调用<code>mmap</code>，内核分配虚拟地址空间；  </li><li>物理内存按需加载（首次访问触发缺页中断，从磁盘加载文件或分配匿名页）；  </li><li>修改的页面由内核异步回写磁盘。</li></ul></li></ol><h3 id="二、分页机制的核心逻辑"><a href="#二、分页机制的核心逻辑" class="headerlink" title="二、分页机制的核心逻辑"></a><strong>二、分页机制的核心逻辑</strong></h3><ol><li><p><strong>分页机制的作用</strong><br>分页是虚拟内存的基础，将虚拟地址划分为固定大小的页（如4KB），通过页表（Page Table）映射到物理内存页。其核心目标是<strong>透明管理物理内存</strong>，实现内存隔离与按需加载。  </p><ul><li><strong>缺页中断</strong>：访问未加载的页时触发，内核从磁盘加载数据到物理页；  </li><li><strong>页面置换</strong>：内存不足时通过算法（如LRU）淘汰页面。</li></ul></li><li><p><strong>分页的层级结构</strong>  </p><ul><li><strong>多级页表</strong>：压缩页表空间（如四级页表x86_64）；  </li><li><strong>TLB缓存</strong>：加速地址翻译。</li></ul></li></ol><h3 id="三、内存映射与分页的区别"><a href="#三、内存映射与分页的区别" class="headerlink" title="三、内存映射与分页的区别"></a><strong>三、内存映射与分页的区别</strong></h3><table><thead><tr><th><strong>维度</strong></th><th><strong>内存映射</strong></th><th><strong>分页机制</strong></th></tr></thead><tbody><tr><td><strong>核心目标</strong></td><td>高效文件访问与共享内存</td><td>虚拟地址到物理地址的透明转换</td></tr><tr><td><strong>触发方式</strong></td><td>显式调用<code>mmap</code>&#x2F;<code>munmap</code></td><td>隐式处理（所有内存访问均需分页）</td></tr><tr><td><strong>数据来源</strong></td><td>文件或匿名内存</td><td>物理内存或交换区</td></tr><tr><td><strong>缺页处理</strong></td><td>加载文件内容或分配匿名页</td><td>加载匿名页或换入物理页</td></tr><tr><td><strong>性能优化</strong></td><td>减少用户态-内核态数据拷贝</td><td>通过TLB和局部性原理减少访问延迟</td></tr><tr><td><strong>典型应用</strong></td><td>大文件处理、进程间通信（共享内存）</td><td>所有进程的内存管理基础</td></tr></tbody></table><h2 id="20-死锁"><a href="#20-死锁" class="headerlink" title="20-死锁"></a>20-死锁</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果代码这样写会发生死锁：</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx<span class="number">1.l</span>ock();</span><br><span class="line">    mtx<span class="number">2.l</span>ock();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mtx<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">    mtx<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx<span class="number">2.l</span>ock();</span><br><span class="line">    mtx<span class="number">1.l</span>ock();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mtx<span class="number">1.</span><span class="built_in">unlock</span>();</span><br><span class="line">    mtx<span class="number">2.</span><span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决方案：</p><ul><li>调换锁的顺序</li><li>原子化操作：同时获取两个锁，避免死锁</li><li>使用try_lock()：尝试获取锁，如果失败则释放锁，避免死锁</li></ul><h2 id="21-算法"><a href="#21-算法" class="headerlink" title="21-算法"></a>21-算法</h2><ul><li>两个栈实现队列：<ul><li>一个栈用于入队，一个栈用于出队</li><li>出队时，如果出队栈为空，则将入队栈的元素全部弹出并压入出队栈</li><li>出队栈不为空，则直接弹出栈顶元素</li></ul></li></ul><h2 id="22-string相关"><a href="#22-string相关" class="headerlink" title="22-string相关"></a>22-string相关</h2><ul><li><code>&quot;ssss&quot;</code>是字符串字面量，存储在静态内存区，是不可变的</li><li><code>string s = &quot;ssss&quot;</code>会把字符串字面量拷贝到栈&#x2F;堆上，是可变的</li><li>string有SSO优化，当字符串长度小于一定阈值时，会直接存储在栈上，否则会存储在堆上<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_location</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* p = s.<span class="built_in">c_str</span>();</span><br><span class="line">    std::cout &lt;&lt; (<span class="type">void</span>*)p &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; &amp;x &lt;&lt; endl;</span><br><span class="line">    std::string s1 = <span class="string">&quot;short&quot;</span>; </span><br><span class="line">    <span class="function">std::string <span class="title">s2</span><span class="params">(<span class="number">100</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">check_location</span>(s1);</span><br><span class="line">    <span class="built_in">check_location</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 000000A7587DFC04</span></span><br><span class="line"><span class="comment">// 000000A7587DFC30</span></span><br><span class="line"><span class="comment">// 000001FA36DC14B0</span></span><br></pre></td></tr></table></figure></li><li>string, char[], char*</li></ul><h3 id="一、终极对比表"><a href="#一、终极对比表" class="headerlink" title="一、终极对比表"></a>一、终极对比表</h3><table><thead><tr><th>特性</th><th><code>char[]</code> 数组</th><th><code>char*</code> 指针</th><th><code>std::string</code></th></tr></thead><tbody><tr><td><strong>内存管理</strong></td><td>栈&#x2F;静态区固定大小</td><td>指向已存在内存（无所有权）</td><td>堆内存动态管理（自动扩容）</td></tr><tr><td><strong>‘\0’ 规则</strong></td><td><strong>必须显式包含</strong></td><td>依赖指向内容（通常需要）</td><td>内部自动维护（用户不可见）</td></tr><tr><td><strong>可变性</strong></td><td>内容可修改</td><td>依赖指向内存属性</td><td>内容可修改</td></tr><tr><td><strong>长度获取</strong></td><td><code>strlen(arr)</code> (需遍历)</td><td><code>strlen(ptr)</code> (需遍历)</td><td><code>.length()</code> (O(1)时间复杂度)</td></tr><tr><td><strong>越界风险</strong></td><td>高（固定大小）</td><td>高（依赖手动管理）</td><td>低（自动扩容）</td></tr><tr><td><strong>内存位置</strong></td><td>栈&#x2F;数据段</td><td>可指向任意位置</td><td>堆内存</td></tr><tr><td><strong>典型初始化</strong></td><td><code>char arr[6] = &quot;hello&quot;;</code></td><td><code>const char* p = &quot;world&quot;;</code></td><td><code>std::string s = &quot;cpp&quot;;</code></td></tr><tr><td><strong>内容修改示例</strong></td><td><code>arr[0] = &#39;H&#39;;</code> ✅</td><td><code>p[0] = &#39;W&#39;;</code> ❌ (字面量只读)</td><td><code>s[0] = &#39;C&#39;;</code> ✅</td></tr><tr><td><strong>生命周期</strong></td><td>作用域结束自动释放</td><td>不管理指向内存的生命周期</td><td>对象析构时自动释放</td></tr></tbody></table><hr><h3 id="二、-0-规则详解"><a href="#二、-0-规则详解" class="headerlink" title="二、\0 规则详解"></a>二、<code>\0</code> 规则详解</h3><h4 id="1-char-数组"><a href="#1-char-数组" class="headerlink" title="1. char[] 数组"></a>1. <code>char[]</code> 数组</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例（自动添加\0）</span></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 实际大小6字节，包含&#x27;\0&#x27;</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(str1);  <span class="comment">// 输出6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例（忘记预留\0空间）</span></span><br><span class="line"><span class="type">char</span> str2[<span class="number">5</span>] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;; <span class="comment">// 没有空间存放\0</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">strlen</span>(str2);  <span class="comment">// 未定义行为（可能越界读取）</span></span><br></pre></td></tr></table></figure><h4 id="2-char-指针"><a href="#2-char-指针" class="headerlink" title="2. char* 指针"></a>2. <code>char*</code> 指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确使用（指向字符串字面量）</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 字面量自带\0</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">strlen</span>(p1);   <span class="comment">// 输出5（计算到\0前）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险示例（指向非常量内存）</span></span><br><span class="line"><span class="type">char</span> temp[] = &#123;<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;; <span class="comment">// 没有\0</span></span><br><span class="line"><span class="type">char</span>* p2 = temp;  <span class="comment">// 指向非终止数组</span></span><br><span class="line">std::cout &lt;&lt; p2;  <span class="comment">// 输出&quot;World&quot;后继续打印乱码直到遇到内存中的0</span></span><br></pre></td></tr></table></figure><h4 id="3-std-string"><a href="#3-std-string" class="headerlink" title="3. std::string"></a>3. <code>std::string</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string s1 = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 自动存储为&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;,&#x27;\0&#x27;</span></span><br><span class="line">s<span class="number">1.</span><span class="built_in">push_back</span>(<span class="string">&#x27;!&#x27;</span>);  <span class="comment">// 变为&quot;Hello!&quot;，自动维护新\0</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = s<span class="number">1.</span><span class="built_in">c_str</span>();  <span class="comment">// 保证有\0结尾</span></span><br></pre></td></tr></table></figure><hr><h3 id="三、内存布局对比"><a href="#三、内存布局对比" class="headerlink" title="三、内存布局对比"></a>三、内存布局对比</h3><h4 id="1-char-6-arr-Hello-的内存"><a href="#1-char-6-arr-Hello-的内存" class="headerlink" title="1. char[6] arr = &quot;Hello&quot;; 的内存"></a>1. <code>char[6] arr = &quot;Hello&quot;;</code> 的内存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">地址 | 值      | ASCII</span><br><span class="line">0x100 | &#x27;H&#x27;    | 0x48</span><br><span class="line">0x101 | &#x27;e&#x27;    | 0x65</span><br><span class="line">0x102 | &#x27;l&#x27;    | 0x6C</span><br><span class="line">0x103 | &#x27;l&#x27;    | 0x6C</span><br><span class="line">0x104 | &#x27;o&#x27;    | 0x6F</span><br><span class="line">0x105 | &#x27;\0&#x27;   | 0x00</span><br></pre></td></tr></table></figure><h4 id="2-std-string-s-Hi-的内存"><a href="#2-std-string-s-Hi-的内存" class="headerlink" title="2. std::string s = &quot;Hi&quot;; 的内存"></a>2. <code>std::string s = &quot;Hi&quot;;</code> 的内存</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">堆内存布局（典型实现）：</span><br><span class="line">0x2000 | 数据头（长度、容量等）</span><br><span class="line">0x2008 | &#x27;H&#x27;    | 0x48</span><br><span class="line">0x2009 | &#x27;i&#x27;    | 0x69</span><br><span class="line">0x200A | &#x27;\0&#x27;   | 0x00 </span><br></pre></td></tr></table></figure><h4 id="3-char-p-new-char-3-A-B-C-的危险情况"><a href="#3-char-p-new-char-3-A-B-C-的危险情况" class="headerlink" title="3. char* p = new char[3]{&#39;A&#39;,&#39;B&#39;,&#39;C&#39;}; 的危险情况"></a>3. <code>char* p = new char[3]&#123;&#39;A&#39;,&#39;B&#39;,&#39;C&#39;&#125;;</code> 的危险情况</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">堆内存：</span><br><span class="line">0x3000 | &#x27;A&#x27; 0x41</span><br><span class="line">0x3001 | &#x27;B&#x27; 0x42</span><br><span class="line">0x3002 | &#x27;C&#x27; 0x43</span><br><span class="line">0x3003 | ??? 随机值</span><br></pre></td></tr></table></figure><p>当使用<code>strlen(p)</code>时，会从0x3000开始遍历，直到遇到0x00为止，可能访问非法内存。</p><hr><h3 id="四、常见错误案例"><a href="#四、常见错误案例" class="headerlink" title="四、常见错误案例"></a>四、常见错误案例</h3><h4 id="错误1：忘记预留-0空间"><a href="#错误1：忘记预留-0空间" class="headerlink" title="错误1：忘记预留\0空间"></a>错误1：忘记预留<code>\0</code>空间</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 需要6字节空间（导致缓冲区溢出）</span></span><br></pre></td></tr></table></figure><h4 id="错误2：误修改字符串字面量"><a href="#错误2：误修改字符串字面量" class="headerlink" title="错误2：误修改字符串字面量"></a>错误2：误修改字符串字面量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p = <span class="string">&quot;readonly&quot;</span>;  <span class="comment">// C++11起必须用const char*</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="string">&#x27;R&#x27;</span>;  <span class="comment">// 运行时崩溃（写入只读内存页）</span></span><br></pre></td></tr></table></figure><h4 id="错误3：std-string与C字符串混用"><a href="#错误3：std-string与C字符串混用" class="headerlink" title="错误3：std::string与C字符串混用"></a>错误3：<code>std::string</code>与C字符串混用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);        <span class="comment">// 错误！应使用s.c_str()</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>()); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><h2 id="23-特化与偏特化"><a href="#23-特化与偏特化" class="headerlink" title="23-特化与偏特化"></a>23-特化与偏特化</h2><p>在C++面试中被问及模板特化（Specialization）与偏特化（Partial Specialization）时，可以从以下几个关键点展开回答，结合应用场景和代码示例，既展示理论深度又体现实践能力：</p><hr><h3 id="1-核心概念与定义"><a href="#1-核心概念与定义" class="headerlink" title="1. 核心概念与定义"></a><strong>1. 核心概念与定义</strong></h3><ul><li><p><strong>模板特化</strong>：为模板的<strong>特定类型参数</strong>提供定制化实现，覆盖通用模板的行为。分为两类：</p><ul><li><strong>全特化</strong>：所有模板参数都指定为具体类型。例如：<code>template&lt;&gt; class MyClass&lt;int&gt;</code>，其中所有泛型参数被明确指定为<code>int</code>。</li><li><strong>函数模板只能全特化</strong>，无法偏特化（但可通过重载模拟类似效果）。</li></ul></li><li><p><strong>偏特化</strong>：仅针对模板参数的<strong>部分类型或属性</strong>进行特化，保留部分泛型特性。例如：</p><ul><li><strong>类型组合特化</strong>：<code>template&lt;class T&gt; class MyPair&lt;T, int&gt;</code>（当第二个参数为<code>int</code>时触发）。</li><li><strong>属性特化</strong>：针对指针、引用、<code>const</code>等类型修饰符（如<code>template&lt;class T&gt; class MyClass&lt;T*&gt;</code>）。</li></ul></li></ul><hr><h3 id="2-应用场景与示例"><a href="#2-应用场景与示例" class="headerlink" title="2. 应用场景与示例"></a><strong>2. 应用场景与示例</strong></h3><ul><li><p><strong>全特化的典型应用</strong>：</p><ul><li><strong>优化性能</strong>：例如为<code>int</code>类型提供高效实现，避免通用模板的额外开销。</li><li><strong>特殊逻辑处理</strong>：例如<code>std::vector&lt;bool&gt;</code>使用位压缩存储，与通用<code>std::vector</code>不同。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T val)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Generic: &quot;</span> &lt;&lt; val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化版本（针对double）</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span> val) &#123; cout &lt;&lt; <span class="string">&quot;Double: &quot;</span> &lt;&lt; val; &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>偏特化的典型应用</strong>：</p><ul><li><strong>类型约束</strong>：例如处理指针或容器类型时，避免重复代码。</li><li><strong>部分参数固定</strong>：例如<code>template&lt;typename T1&gt; class MyClass&lt;T1, int&gt;</code>，固定第二个参数为<code>int</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123; <span class="comment">/*...*/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化：当T2为int时</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T1, <span class="type">int</span>&gt; &#123; <span class="comment">/*...*/</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-语法与优先级规则"><a href="#3-语法与优先级规则" class="headerlink" title="3. 语法与优先级规则"></a><strong>3. 语法与优先级规则</strong></h3><ul><li><p><strong>语法区别</strong>：</p><ul><li>全特化：模板参数列表为空（<code>template&lt;&gt;</code>），显式指定所有类型。</li><li>偏特化：模板参数列表非空，保留部分泛型参数（如<code>template&lt;class T&gt;</code>）。</li></ul></li><li><p><strong>优先级顺序</strong>：</p><ul><li>全特化 &gt; 偏特化 &gt; 通用模板。编译器选择<strong>最具体匹配的版本</strong>。</li></ul></li></ul><hr><h3 id="4-常见问题与误区"><a href="#4-常见问题与误区" class="headerlink" title="4. 常见问题与误区"></a><strong>4. 常见问题与误区</strong></h3><ul><li><p><strong>函数模板不能偏特化</strong>：C++标准不支持函数模板偏特化，需通过重载或特化实现类似效果。</p></li><li><p><strong>特化与重载的区别</strong>：</p><ul><li>特化是模板的定制化实现，重载是独立函数的不同版本。</li><li>特化版本必须与通用模板在<strong>同一命名空间</strong>，且不参与重载决议。</li></ul></li><li><p><strong>避免滥用</strong>：特化可能增加代码复杂度，优先考虑通用模板的灵活性。</p></li></ul><hr><h3 id="5-对比总结（表格形式）"><a href="#5-对比总结（表格形式）" class="headerlink" title="5. 对比总结（表格形式）"></a><strong>5. 对比总结（表格形式）</strong></h3><table><thead><tr><th><strong>特性</strong></th><th><strong>全特化</strong></th><th><strong>偏特化</strong></th></tr></thead><tbody><tr><td><strong>适用范围</strong></td><td>类模板、函数模板</td><td>仅类模板</td></tr><tr><td><strong>参数数量</strong></td><td>全部参数固定</td><td>部分参数固定或属性约束</td></tr><tr><td><strong>语法</strong></td><td><code>template&lt;&gt;</code></td><td><code>template&lt;部分参数&gt;</code></td></tr><tr><td><strong>典型用途</strong></td><td>特定类型优化、特殊逻辑</td><td>类型组合、指针&#x2F;引用处理</td></tr><tr><td><strong>优先级</strong></td><td>高于通用模板</td><td>介于全特化和通用模板之间</td></tr></tbody></table><hr><h3 id="6-实际应用案例"><a href="#6-实际应用案例" class="headerlink" title="6. 实际应用案例"></a><strong>6. 实际应用案例</strong></h3><ul><li><strong>STL中的应用</strong>：<ul><li><code>std::vector&lt;bool&gt;</code>通过全特化优化存储空间。</li><li>迭代器特性（<code>iterator_traits</code>）通过偏特化区分指针与类类型迭代器。</li></ul></li><li><strong>元编程</strong>：通过特化实现类型萃取（如<code>is_same</code>、<code>is_pointer</code>等）。</li></ul><h2 id="24-系统调用与过程调用"><a href="#24-系统调用与过程调用" class="headerlink" title="24-系统调用与过程调用"></a>24-系统调用与过程调用</h2><h3 id="1-执行环境与特权级别"><a href="#1-执行环境与特权级别" class="headerlink" title="1. 执行环境与特权级别"></a>1. <strong>执行环境与特权级别</strong></h3><ul><li><strong>系统调用</strong>：<br>用户程序通过系统调用从<strong>用户态（用户模式）</strong>切换到<strong>内核态（核心态）</strong>，需要提升硬件特权级别（如x86架构中从Ring 3到Ring 0）。在此状态下，操作系统内核可直接访问硬件资源（如磁盘、内存）并执行特权指令。  </li><li><strong>过程调用</strong>：<br>始终在<strong>用户态</strong>执行，调用方和被调用方处于同一特权级别，仅涉及用户程序内部的函数跳转，无需状态切换。</li></ul><hr><h3 id="2-实现机制"><a href="#2-实现机制" class="headerlink" title="2. 实现机制"></a>2. <strong>实现机制</strong></h3><ul><li><strong>系统调用</strong>：  <ul><li>通过<strong>软中断（如<code>int 0x80</code>）</strong>或<strong>专用指令（如<code>syscall</code>）</strong>触发，由操作系统内核接管控制权。  </li><li>参数通过<strong>寄存器</strong>或<strong>内核栈</strong>传递，调用号（如<code>__NR_read</code>）用于在内核的系统调用表中查找对应的处理函数。</li></ul></li><li><strong>过程调用</strong>：  <ul><li>直接通过<strong>函数地址跳转（如<code>call</code>指令）</strong>实现，参数通过<strong>用户栈</strong>传递，调用地址在编译时确定。  </li><li>属于静态调用，被调用代码与调用代码在同一程序内。</li></ul></li></ul><hr><h3 id="3-权限与资源访问"><a href="#3-权限与资源访问" class="headerlink" title="3. 权限与资源访问"></a>3. <strong>权限与资源访问</strong></h3><ul><li><strong>系统调用</strong>：<br>需要操作系统的权限验证，可访问受保护的内核资源（如文件系统、设备驱动）。例如，<code>open()</code>需要内核验证文件权限后才允许操作。  </li><li><strong>过程调用</strong>：<br>仅能访问用户程序自身的资源（如局部变量、堆内存），无需特殊权限。</li></ul><hr><h3 id="4-开销与性能"><a href="#4-开销与性能" class="headerlink" title="4. 开销与性能"></a>4. <strong>开销与性能</strong></h3><ul><li><strong>系统调用</strong>：<br>涉及<strong>上下文切换</strong>（保存用户态寄存器状态、切换到内核栈）、<strong>安全检查</strong>（如参数合法性验证），以及可能的进程调度延迟，<strong>开销较大</strong>（通常为微秒级）。  </li><li><strong>过程调用</strong>：<br>无状态切换，仅需保存和恢复少量寄存器，<strong>开销极小</strong>（纳秒级）。</li></ul><hr><h3 id="5-返回与调度"><a href="#5-返回与调度" class="headerlink" title="5. 返回与调度"></a>5. <strong>返回与调度</strong></h3><ul><li><strong>系统调用</strong>：  <ul><li>返回时可能触发<strong>进程重新调度</strong>（如采用抢占式调度），若当前进程优先级降低，可能被挂起。  </li><li>错误通过<strong>错误码（如<code>errno</code>）</strong>返回，需用户程序显式处理。</li></ul></li><li><strong>过程调用</strong>：  <ul><li>直接返回到调用点继续执行，不涉及进程调度。  </li><li>错误通常通过返回值或异常机制处理。</li></ul></li></ul><hr><h3 id="6-代码层次与可移植性"><a href="#6-代码层次与可移植性" class="headerlink" title="6. 代码层次与可移植性"></a>6. <strong>代码层次与可移植性</strong></h3><ul><li><strong>系统调用</strong>：  <ul><li>属于<strong>系统级代码</strong>，实现依赖于具体操作系统和硬件架构（如Linux的<code>syscall</code>指令与Windows的调用方式不同），可移植性差。</li></ul></li><li><strong>过程调用</strong>：  <ul><li>属于<strong>用户级代码</strong>，由编译器直接生成，与操作系统无关，可移植性高。</li></ul></li></ul><hr><h3 id="7-嵌套与并发限制"><a href="#7-嵌套与并发限制" class="headerlink" title="7. 嵌套与并发限制"></a>7. <strong>嵌套与并发限制</strong></h3><ul><li><strong>系统调用</strong>：  <ul><li>通常不允许在同一个进程中发生<strong>嵌套或递归调用</strong>，可能导致内核栈溢出。</li></ul></li><li><strong>过程调用</strong>：  <ul><li>支持任意层数的嵌套或递归，仅受用户栈空间限制。</li></ul></li></ul><hr><h3 id="对比总结（表格形式）"><a href="#对比总结（表格形式）" class="headerlink" title="对比总结（表格形式）"></a><strong>对比总结（表格形式）</strong></h3><table><thead><tr><th><strong>维度</strong></th><th><strong>系统调用</strong></th><th><strong>过程调用</strong></th></tr></thead><tbody><tr><td><strong>执行环境</strong></td><td>用户态→内核态切换，特权级别提升</td><td>始终在用户态</td></tr><tr><td><strong>触发方式</strong></td><td>软中断（<code>int 0x80</code>）或<code>syscall</code>指令</td><td>直接函数跳转（<code>call</code>）</td></tr><tr><td><strong>权限</strong></td><td>需内核验证，可访问硬件资源</td><td>仅限用户程序内部资源</td></tr><tr><td><strong>开销</strong></td><td>高（上下文切换、安全检查）</td><td>低（仅寄存器操作）</td></tr><tr><td><strong>可移植性</strong></td><td>依赖操作系统和硬件，移植性差</td><td>与平台无关，移植性高</td></tr><tr><td><strong>错误处理</strong></td><td>通过错误码（如<code>errno</code>）</td><td>返回值或异常机制</td></tr><tr><td><strong>嵌套&#x2F;递归</strong></td><td>通常禁止</td><td>支持</td></tr></tbody></table><hr><h3 id="面试回答示例"><a href="#面试回答示例" class="headerlink" title="面试回答示例"></a><strong>面试回答示例</strong></h3><p>“系统调用与过程调用的核心区别在于<strong>执行环境</strong>和<strong>资源访问权限</strong>。系统调用需要从用户态切换到内核态，通过软中断或专用指令触发，由操作系统内核执行特权操作（如文件读写），涉及上下文切换和安全检查，因此开销较大。而过程调用是用户程序内部的函数跳转，无需特权切换，执行效率更高。此外，系统调用可能引发进程重新调度，且代码实现依赖操作系统，可移植性较差。”</p><h2 id="00-其他"><a href="#00-其他" class="headerlink" title="00-其他"></a>00-其他</h2><ul><li>vector.size()返回的是无符号数要注意</li><li><cassert> assert</li><li>运算的时候注意static_cast&lt;long&#x2F;float&gt;</li><li>fabs计算浮点数绝对值</li><li>为什么要地址对齐<ul><li>为了提高效率，计算机从内存中取数据是按照一个固定长度的。以32位机为例，它每次取32个位，也就是4个字节（每字节8位）。字节对齐有什么好处？以int型数据为例，如果它在内存中存放的位置按4字节对齐，也就是说1个int的数据全部落在计算机一次取数的区间内，那么只需要取一次就可以了。如果不对齐，这个int数据刚好跨越了取数的边界，这样就需要取两次才能取出</li></ul></li><li>不用内部函数如何确定int的大小<ul><li>利用指针和数组，用指针指向数组后++然后相减得到的值就是int的大小</li></ul></li><li>inline关键字：<ul><li>以下类型的函数通常不能使用 inline 关键字：<ul><li>递归函数：由于递归函数调用自身，编译器无法在编译时确定函数体的大小。</li><li>虚函数：在类中声明为虚函数的成员函数，因为它们的调用是在运行时动态解析的。</li><li>带有复杂控制流的函数：如包含 goto、switch 或其他复杂控制结构的函数，编译器可能会选择不内联。</li><li>声明为 extern 的函数：因为这些函数的定义可能在其他文件中，编译器无法确定其内联的可行性。</li></ul></li></ul></li><li>具体类型占用字节大小和编译器有关（比如GCC, MSVC）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C-Sharp</title>
      <link href="/posts/d68507da.html"/>
      <url>/posts/d68507da.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-多线程相关"><a href="#1-多线程相关" class="headerlink" title="1. 多线程相关"></a>1. 多线程相关</h2><ul><li>参考文章：<ul><li><a href="https://cloud.tencent.com/developer/article/2318142">多线程编程和并发处理</a></li><li><a href="https://www.cnblogs.com/forges/p/18757082">C#多线程同步机制</a></li><li><a href="https://www.cnblogs.com/guanshan/p/guan2021-4-26_001.html">C#多线程同步机制-较全面</a></li></ul></li></ul><h3 id="1-1-多线程概念"><a href="#1-1-多线程概念" class="headerlink" title="1.1 多线程概念"></a>1.1 多线程概念</h3><ol><li>进程&#x2F;线程概念</li></ol><ul><li>进程：资源分配的基本单位</li><li>线程：CPU调度的基本单位</li></ul><ol start="2"><li>单核与多核</li></ol><ul><li>单核CPU中的进程和多线程都是并发的而非并行的</li></ul><ol start="3"><li>为什么要多线程</li></ol><ul><li>性能提升，响应性，资源共享，并发处理，复杂任务分解，提高资源利用率</li></ul><h3 id="1-2-代码相关"><a href="#1-2-代码相关" class="headerlink" title="1.2 代码相关"></a>1.2 代码相关</h3><ol><li>Thread类</li><li>ThreadPool类</li><li>Task类</li></ol><h3 id="1-3-线程优先级"><a href="#1-3-线程优先级" class="headerlink" title="1.3 线程优先级"></a>1.3 线程优先级</h3><ul><li>C#中默认创建的线程是前台线程，全部前台线程执行完后，程序会自动退出</li><li>可以通过设置线程的IsBackground属性为true，将线程设置为后台线程，这样前台线程执行完后台线程也会直接结束</li><li>线程优先级：<ul><li>线程优先级是一个枚举类型，有以下几个值：<ul><li>Lowest：最低优先级</li><li>BelowNormal：低于正常优先级</li><li>Normal：正常优先级</li><li>AboveNormal：高于正常优先级</li><li>Highest：最高优先级</li></ul></li><li>线程优先级的设置：<ul><li>可以通过Thread类的Priority属性来设置线程的优先级，例如：<ul><li>Thread thread &#x3D; new Thread(() &#x3D;&gt; { &#x2F;* 线程代码 *&#x2F; });</li><li>thread.Priority &#x3D; ThreadPriority.Highest;</li></ul></li></ul></li></ul></li></ul><h3 id="1-4-lock关键字"><a href="#1-4-lock关键字" class="headerlink" title="1.4 lock关键字"></a>1.4 lock关键字</h3><ul><li>使用锁机制可能会引入性能开销，因为在一个线程访问锁定代码块时，其他线程会被阻塞。</li><li>lock对象，推荐私有静态只读的引用类型：<code>private static readonly object lockObject = new object();  // 正确做法</code></li><li>lock语句要求锁对象必须是引用类型（如object、自定义类实例等）。尝试使用值类型（如int）会导致编译错误，因为值类型会被装箱（每次装箱会生成新对象实例），导致锁失效</li><li>锁定字符串的危险性：字符串被公共语言运行库（CLR）“暂留”，即程序中相同内容的字符串在内存中只有一个实例。因此，锁定字符串会导致锁定应用程序中所有相同内容的字符串实例，范围过广，容易引发问题。</li><li>避免锁定公共类型或不受控制的对象：锁定公共类型（如公共数据类型）或使用lock(this)锁定当前对象实例可能会导致问题。如果对象实例可以被公开访问，其他不受控制的代码也可能会锁定该对象，从而导致死锁。死锁是指两个或多个线程互相等待对方释放锁，导致程序无法继续运行。</li><li>锁定范围问题：lock(this)只对当前对象有效，无法实现多个对象之间的同步。lock(typeof(Class))类似于锁定字符串，锁定范围过宽，容易影响整个应用程序的性能和稳定性。</li></ul><h3 id="1-5-Monitor类"><a href="#1-5-Monitor类" class="headerlink" title="1.5 Monitor类"></a>1.5 Monitor类</h3><ol><li>与lock的区别：</li></ol><ul><li>lock是语法糖，编译后会被展开为Monitor.Enter和Monitor.Exit，用于互斥访问临界区</li><li>Monitor类提供了更底层的控制，包括Wait()、Pulse()和PulseAll()方法，用于线程间的协作</li><li>Monitor.Wait()和Monitor.Pulse()必须在已持有锁的情况下调用</li><li>lock自动生成try-finally块，确保锁的释放（即使发生异常）。若直接使用Monitor.Enter和Exit，需手动处理异常和锁释放，代码更冗长且易出错</li><li>使用Monitor可以避免忙等待：若仅用lock而不用Monitor.Wait()，线程会在条件不满足时持续循环检查浪费CPU资源。通过Wait()，线程主动释放锁并休眠，直到被唤醒但需要维护等待队列</li></ul><ol start="2"><li>相关函数</li></ol><ul><li>Wait()：释放当前锁，使线程进入等待队列，直到被其他线程唤醒</li><li>Pulse()：唤醒等待队列中的第一个线程，使其进入就绪队列，准备重新获取锁</li><li>PulseAll()：唤醒所有等待线程</li></ul><h3 id="1-6-Mutex类"><a href="#1-6-Mutex类" class="headerlink" title="1.6 Mutex类"></a>1.6 Mutex类</h3><ul><li>Mutex可以实现跨进程的线程同步</li></ul><h3 id="1-7-Semaphore类"><a href="#1-7-Semaphore类" class="headerlink" title="1.7 Semaphore类"></a>1.7 Semaphore类</h3><ul><li>信号量：信号量是一种计数器，用于限制同时访问某个资源的线程数量。信号量可以用于控制线程并发的程度，以及在资源有限的情况下防止资源过度占用。信号量可以用来实现生产者-消费者问题、连接池等场景。</li><li>可以限制同时有多少个线程一起运行</li><li>初始化Semaphore可当做开启了一个线程池</li><li>相关函数：<ul><li>WaitOne()：等待信号量，若信号量为0则阻塞线程</li><li>Release()：释放信号量，增加信号量的值</li></ul></li></ul><hr><h2 id="2-C-中各种锁"><a href="#2-C-中各种锁" class="headerlink" title="2. C#中各种锁"></a>2. C#中各种锁</h2><h3 id="一、自旋锁（SpinLock）"><a href="#一、自旋锁（SpinLock）" class="headerlink" title="一、自旋锁（SpinLock）"></a><strong>一、自旋锁（SpinLock）</strong></h3><h4 id="1-实现原理"><a href="#1-实现原理" class="headerlink" title="1. 实现原理"></a><strong>1. 实现原理</strong></h4><p>自旋锁通过<strong>循环检测锁状态</strong>实现同步。当线程尝试获取锁时，若锁已被占用，线程会持续自旋（循环等待）而非进入阻塞状态。其底层依赖原子操作（如CAS指令）确保锁状态修改的原子性。例如，C#中的<code>SpinLock</code>类通过<code>Enter</code>和<code>Exit</code>方法控制锁的获取与释放，内部使用标志位（如0表示空闲，1表示占用）管理状态。</p><h4 id="2-代码示例"><a href="#2-代码示例" class="headerlink" title="2. 代码示例"></a><strong>2. 代码示例</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line"><span class="built_in">bool</span> lockTaken = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    spinLock.Enter(<span class="keyword">ref</span> lockTaken);  <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="comment">// 临界区操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lockTaken) spinLock.Exit(); <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-适用场景与优缺点"><a href="#3-适用场景与优缺点" class="headerlink" title="3. 适用场景与优缺点"></a><strong>3. 适用场景与优缺点</strong></h4><ul><li><strong>适用场景</strong>：锁持有时间极短（如几微秒）、多核环境、实时系统或中断处理等无法容忍线程切换的场景。</li><li><strong>优点</strong>：无上下文切换开销，响应快。</li><li><strong>缺点</strong>：长时间自旋会浪费CPU资源，单核场景下可能导致死锁。</li></ul><hr><h3 id="二、互斥锁（Mutex）"><a href="#二、互斥锁（Mutex）" class="headerlink" title="二、互斥锁（Mutex）"></a><strong>二、互斥锁（Mutex）</strong></h3><h4 id="1-实现原理-1"><a href="#1-实现原理-1" class="headerlink" title="1. 实现原理"></a><strong>1. 实现原理</strong></h4><p>互斥锁通过<strong>操作系统内核调度</strong>实现阻塞。当锁被占用时，请求线程会被挂起并加入阻塞队列，等待锁释放后被唤醒。C#中常见的实现包括：</p><ul><li><strong><code>lock</code>关键字</strong>：语法糖，底层调用<code>Monitor.Enter</code>和<code>Monitor.Exit</code>。</li><li><strong><code>Monitor</code>类</strong>：支持混合锁（先自旋后阻塞），适用于大多数场景。</li><li><strong><code>Mutex</code>类</strong>：系统级互斥量，支持跨进程同步。</li></ul><h4 id="2-代码示例-1"><a href="#2-代码示例-1" class="headerlink" title="2. 代码示例"></a><strong>2. 代码示例</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用lock关键字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">object</span> _lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"><span class="keyword">lock</span> (_lockObj) &#123;</span><br><span class="line">    <span class="comment">// 临界区操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Mutex类</span></span><br><span class="line">Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line">mutex.WaitOne();   <span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    mutex.ReleaseMutex();  <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-适用场景与优缺点-1"><a href="#3-适用场景与优缺点-1" class="headerlink" title="3. 适用场景与优缺点"></a><strong>3. 适用场景与优缺点</strong></h4><ul><li><strong>适用场景</strong>：锁持有时间长、单核环境或需要跨进程同步的场景。</li><li><strong>优点</strong>：避免CPU空转，适用于高竞争环境。</li><li><strong>缺点</strong>：上下文切换开销大，频繁锁竞争可能导致性能下降。</li></ul><hr><h3 id="三、读写锁（ReaderWriterLockSlim）"><a href="#三、读写锁（ReaderWriterLockSlim）" class="headerlink" title="三、读写锁（ReaderWriterLockSlim）"></a><strong>三、读写锁（ReaderWriterLockSlim）</strong></h3><h4 id="1-实现原理-2"><a href="#1-实现原理-2" class="headerlink" title="1. 实现原理"></a><strong>1. 实现原理</strong></h4><p>读写锁通过<strong>区分读锁和写锁</strong>优化并发性：</p><ul><li><strong>读锁</strong>：允许多线程同时获取，共享资源。</li><li><strong>写锁</strong>：独占资源，禁止其他读写操作。<br>C#中<code>ReaderWriterLockSlim</code>类实现了这一机制，支持读锁升级为写锁（需先获取可升级读锁）。</li></ul><h4 id="2-代码示例-2"><a href="#2-代码示例-2" class="headerlink" title="2. 代码示例"></a><strong>2. 代码示例</strong></h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ReaderWriterLockSlim rwLock = <span class="keyword">new</span> ReaderWriterLockSlim();</span><br><span class="line"><span class="comment">// 读操作</span></span><br><span class="line">rwLock.EnterReadLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 读取共享资源</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwLock.ExitReadLock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写操作</span></span><br><span class="line">rwLock.EnterWriteLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 修改共享资源</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rwLock.ExitWriteLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-适用场景与优缺点-2"><a href="#3-适用场景与优缺点-2" class="headerlink" title="3. 适用场景与优缺点"></a><strong>3. 适用场景与优缺点</strong></h4><ul><li><strong>适用场景</strong>：读多写少（如配置缓存、日志系统）。</li><li><strong>优点</strong>：提升读操作的并发性，减少阻塞。</li><li><strong>缺点</strong>：写锁可能导致“写者饥饿”，需通过三重检查锁（Double-Checked Triple Lock）优化。</li></ul><hr><table><thead><tr><th><strong>维度</strong></th><th><strong>自旋锁</strong></th><th><strong>互斥锁</strong></th><th><strong>读写锁</strong></th></tr></thead><tbody><tr><td><strong>实现原理</strong></td><td>循环检测锁状态</td><td>内核调度阻塞线程</td><td>区分读&#x2F;写锁，允许多读或独占写</td></tr><tr><td><strong>开销</strong></td><td>无上下文切换，但占用CPU</td><td>上下文切换开销大</td><td>读锁低开销，写锁类似互斥锁</td></tr><tr><td><strong>适用场景</strong></td><td>短期临界区、多核环境</td><td>长期临界区、跨进程同步</td><td>读多写少的高并发场景</td></tr><tr><td><strong>C#类库</strong></td><td><code>SpinLock</code>、<code>Interlocked</code>原子操作</td><td><code>lock</code>、<code>Monitor</code>、<code>Mutex</code></td><td><code>ReaderWriterLockSlim</code></td></tr><tr><td><strong>性能（参考）</strong></td><td>高（短时间）</td><td>低（高竞争）</td><td>中高（读多写少）</td></tr></tbody></table><ul><li><strong>自旋锁</strong>：适用于锁持有时间极短且竞争不激烈的场景（如计数器递增）。</li><li><strong>互斥锁</strong>：默认选择，尤其当临界区操作涉及IO或复杂计算时。</li><li><strong>读写锁</strong>：优化读多写少场景（如缓存系统），需注意写锁的公平性问题。</li></ul><hr><h2 id="3-异步编程"><a href="#3-异步编程" class="headerlink" title="3. 异步编程"></a>3. 异步编程</h2><ul><li><p>参考文章：</p><ul><li><a href="https://www.cnblogs.com/Bob-luo/p/18518463">异步编程底层原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/677520958">C#异步编程详解</a></li></ul></li><li><p>异步编程与多线程：</p><ul><li>异步编程适用于需要处理I&#x2F;O密集型任务的场景，例如网络请求、文件操作等。它通过异步调用和回调机制，能够提高系统的并发能力和响应速度。</li><li>多线程编程适用于需要处理计算密集型任务的场景，例如图像处理、数据分析等。它通过创建多个线程，能够在多个处理器上同时执行任务，提高系统的计算能力。</li></ul></li></ul><hr><h2 id="4-Unity中的协程与异步"><a href="#4-Unity中的协程与异步" class="headerlink" title="4. Unity中的协程与异步"></a>4. Unity中的协程与异步</h2><ul><li>Unity中可以使用UniTask插件实现异步编程</li><li>异步编程优势：速度更快（可能使用线程池充分利用多核CPU，而协程只能单线程），有返回结果（协程也可通过回调或共享变量传递结果）</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协程返回结果示例</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">LoadDataCoroutine</span>(<span class="params">Action&lt;<span class="built_in">string</span>&gt; onComplete</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> data = File.ReadAllText(<span class="string">&quot;data.txt&quot;</span>); <span class="comment">// 同步阻塞！</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 无实际意义的分帧</span></span><br><span class="line">    onComplete?.Invoke(data); <span class="comment">// 通过回调返回</span></span><br><span class="line">&#125;</span><br><span class="line">StartCoroutine(LoadDataCoroutine(result =&gt; Debug.Log(result)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// UniTask返回结果示例</span></span><br><span class="line"><span class="function"><span class="keyword">async</span> UniTask&lt;<span class="built_in">string</span>&gt; <span class="title">LoadDataAsync</span>()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> File.ReadAllTextAsync(<span class="string">&quot;data.txt&quot;</span>); <span class="comment">// 异步读取</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> result = <span class="keyword">await</span> LoadDataAsync(); <span class="comment">// 直接获取结果</span></span><br></pre></td></tr></table></figure><ul><li>使用场景：<ul><li>协程：需要与Unity生命周期强关联的操作（<code>WaitForFixedUpdate</code>）；简单的延时或序列动画（<code>yield return new WaitForSeconds(2)</code>）</li><li>UniTask：文件I&#x2F;O、网络请求等耗时操作；复杂并行任务（如同时加载多个资源）</li></ul></li></ul><h2 id="5-关键字相关"><a href="#5-关键字相关" class="headerlink" title="5. 关键字相关"></a>5. 关键字相关</h2><ul><li>protected internal:<ul><li>假设有一个基类 BaseClass 和一个派生类 DerivedClass，它们可能在同一个程序集中，也可能在不同的程序集中。使用 protected internal 的成员在以下情况下可以被访问：</li><li>同一个程序集中的任何类：可以访问 protected internal 的成员，无论是否继承自基类。</li><li>不同程序集中的派生类：如果 DerivedClass 继承自 BaseClass，那么 DerivedClass 也可以访问 BaseClass 中的 protected internal 成员。</li></ul></li></ul><h2 id="6-Struct"><a href="#6-Struct" class="headerlink" title="6. Struct"></a>6. Struct</h2><ul><li>如果写构造函数时没有显式初始化所有字段，编译器会报错</li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10-数组</title>
      <link href="/posts/71242314.html"/>
      <url>/posts/71242314.html</url>
      
        <content type="html"><![CDATA[<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49-字母异位词分组"></a>49-字母异位词分组</h3><ul><li>哈希，键直接用排序后的字符串（不能用int累加和，因为a是0分辨不出），或者设置字母出现次数作为键</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str: strs) &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义哈希</span></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt;&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(string str:strs) &#123;</span><br><span class="line">            <span class="type">int</span> counts[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:str) &#123;</span><br><span class="line">                counts[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            string key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">26</span>;++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(counts[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                    key.<span class="built_in">push_back</span>(i+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                    key.<span class="built_in">push_back</span>(counts[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p:map) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(p.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128-最长连续序列"></a>128-最长连续序列</h3><ul><li>哈希，先把所有元素加入哈希表，然后遍历每个元素，看是否有比它小的元素，如果没有，就从它开始，不断+1，看是否有这个元素，直到没有为止，记录长度，最后返回最大长度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; nums_set;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            nums_set.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> max_len = <span class="number">0</span>, cur_num = <span class="number">0</span>, cur_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums_set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!nums_set.<span class="built_in">count</span>(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                cur_num = num + <span class="number">1</span>;                        <span class="comment">// 注意这里不能num++否则会改变集合元素值</span></span><br><span class="line">                cur_len = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (nums_set.<span class="built_in">count</span>(cur_num)) &#123;</span><br><span class="line">                    cur_num++;</span><br><span class="line">                    cur_len++;</span><br><span class="line">                &#125;</span><br><span class="line">                max_len = max_len &gt; cur_len ? max_len : cur_len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189-轮转数组"></a>189-轮转数组</h3><ul><li>数组，先把数组后面k个元素复制到一个新数组，然后把前面n-k个元素复制到后面，最后把新数组复制到前面</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[l], nums[r]);</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, n - k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, n - k, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238-除自身以外数组的乘积"></a>238-除自身以外数组的乘积</h3><ul><li>数组，先从左到右遍历，把每个元素左边的乘积记录到一个数组中，然后从右到左遍历，把每个元素右边的乘积记录到一个数组中，最后把两个数组相乘即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算下三角各部分乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 计算上三角各部分乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            temp *= nums[i + <span class="number">1</span>];</span><br><span class="line">            res[i] *= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41-缺失的第一个正数"></a>41-缺失的第一个正数</h3><ul><li>数组，先把所有正数放到一个哈希表中，然后从1开始，看是否在哈希表中，如果不在，就返回这个数，否则继续++，直到找到一个不在哈希表中的数，返回这个数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 小于零的数都改成n+1</span></span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp;num : nums) &#123;</span><br><span class="line">            num = num &lt;= <span class="number">0</span> ? n + <span class="number">1</span> : num; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对指定位置变为负数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> cur_num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (cur_num &lt;= n) nums[cur_num - <span class="number">1</span>] = -<span class="built_in">abs</span>(nums[cur_num - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-寻路系统</title>
      <link href="/posts/e2712377.html"/>
      <url>/posts/e2712377.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-寻路系统map"><a href="#1-寻路系统map" class="headerlink" title="1. 寻路系统map"></a>1. 寻路系统map</h3><ul><li>Waypoint<img src="/img/GAMES104/4-寻路系统/Waypoint.png" height=300 /></li><li>Grid<img src="/img/GAMES104/4-寻路系统/Grid.png" height=300 /></li><li>NavMesh<img src="/img/GAMES104/4-寻路系统/NavMesh.png" height=300 /></li><li>八叉树：可以3D空间</li></ul><h3 id="2-寻路算法"><a href="#2-寻路算法" class="headerlink" title="2. 寻路算法"></a>2. 寻路算法</h3><ul><li><p>深搜&#x2F;广搜</p></li><li><p>Dijstra算法</p></li><li><p>A*算法</p></li><li><p>体素化</p></li><li><p>off-mesh-link</p></li><li><p>RVO避障算法</p></li></ul><h3 id="3-高级应用"><a href="#3-高级应用" class="headerlink" title="3. 高级应用"></a>3. 高级应用</h3><ol><li>可以为不同polymesh添加flag，然后可以对不同区域进行一些自定义的行为，比如踩到雪地播放雪地音效</li></ol><img src="/img/GAMES104/4-寻路系统/PolygonFlag.png" height=400 /><ol start="2"><li>将场景分成多个Tile，然后在Tile里面生成导航网格，这样有动态物体只需更新其所在的Tile</li></ol><img src="/img/GAMES104/4-寻路系统/Tile.png" height=400 /><ol start="3"><li>Off-Mesh Link，可以让角色在两个polymesh之间跳跃，而不需要直接连接两个polymesh</li></ol><img src="/img/GAMES104/4-寻路系统/Off-Mesh Link.png" height=350 /><h3 id="4-A-算法"><a href="#4-A-算法" class="headerlink" title="4. A*算法"></a>4. A*算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义节点结构，包含位置、父节点及代价信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;          <span class="comment">// 节点坐标</span></span><br><span class="line">    Node* parent;       <span class="comment">// 路径中的父节点</span></span><br><span class="line">    <span class="type">float</span> g;            <span class="comment">// 从起点到本节点的实际代价</span></span><br><span class="line">    <span class="type">float</span> h;            <span class="comment">// 到终点的启发式估计代价</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> g + h; &#125; <span class="comment">// 总评估代价</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A*算法主函数</span></span><br><span class="line"><span class="function">function <span class="title">AStar</span><span class="params">(start, goal, grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化开放列表和关闭列表</span></span><br><span class="line">    PriorityQueue openList;  <span class="comment">// 按f值排序的最小堆</span></span><br><span class="line">    Set closedList;          <span class="comment">// 已处理节点集合</span></span><br><span class="line"></span><br><span class="line">    start.g = <span class="number">0</span></span><br><span class="line">    start.h = <span class="built_in">heuristic</span>(start, goal)</span><br><span class="line">    openList.<span class="built_in">add</span>(start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> openList.<span class="built_in">isEmpty</span>() &#123;</span><br><span class="line">        current = openList.<span class="built_in">pop</span>()  <span class="comment">// 取出f值最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> current == goal </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">reconstructPath</span>(current)  <span class="comment">// 找到路径</span></span><br><span class="line">        closedList.<span class="built_in">add</span>(current)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前节点的所有相邻节点（四方向或八方向）</span></span><br><span class="line">        foreach neighbor in <span class="built_in">getNeighbors</span>(current, grid) &#123;</span><br><span class="line">            <span class="comment">// 跳过不可通行或已处理的节点</span></span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> traversable || neighbor in closedList </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">// 计算从当前节点到邻居的临时g值</span></span><br><span class="line">            tentative_g = current.g + <span class="built_in">movementCost</span>(current, neighbor)</span><br><span class="line">            <span class="comment">// 判断是否需要更新路径</span></span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> in openList || tentative_g &lt; neighbor.g &#123;</span><br><span class="line">                neighbor.parent = current</span><br><span class="line">                neighbor.g = tentative_g</span><br><span class="line">                neighbor.h = <span class="built_in">heuristic</span>(neighbor, goal)</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> in openList </span><br><span class="line">                    openList.<span class="built_in">add</span>(neighbor)</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    openList.<span class="built_in">update</span>(neighbor)  <span class="comment">// 调整堆结构</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> null  <span class="comment">// 路径不存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启发式函数示例（曼哈顿距离）</span></span><br><span class="line">function <span class="built_in">heuristic</span>(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.x - b.x) + <span class="built_in">abs</span>(a.y - b.y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径重建函数</span></span><br><span class="line">function <span class="built_in">reconstructPath</span>(node) &#123;</span><br><span class="line">    path = []</span><br><span class="line">    <span class="keyword">while</span> node != null &#123;</span><br><span class="line">        path.<span class="built_in">add</span>(node)</span><br><span class="line">        node = node.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path.<span class="built_in">reverse</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-RecastNavigation"><a href="#5-RecastNavigation" class="headerlink" title="5. RecastNavigation"></a>5. RecastNavigation</h3><ul><li>参考资料：<ul><li><a href="https://zhuanlan.zhihu.com/p/35100455">NavMesh简要过程</a></li><li><a href="https://zhuanlan.zhihu.com/p/592339133">RecastNavigation源码分析</a></li><li>简要步骤：<ul><li>首先将场景中的静态几何体（如墙壁、障碍物等）转化为voxels（体素）网格，每个体素都有自己的坐标和状态（可通行、不可通行、障碍物等）</li><li>然后根据设定的爬坡角度限制生成可行走区域（walkable area），即将voxels网格中的不可通行区域标记为不可通行</li><li>接着生成尽可能大的，不重叠的，连通的regions（区域）-&gt; 洪水填充算法</li><li>对region进行边缘检测生成边缘contours（轮廓）</li><li>再根据轮廓的顶点生成凸多边形polymesh（多边形网格）</li><li>最后加上高度信息生成DetailedMesh（详细网格）</li><li>可以根据polymesh和DetailedMesh进行寻路</li></ul></li></ul></li><li>像素化是将平面上的2D图像转化为一个个小正方形，与此类似，RecastNavigation的体素化过程是把空间几何体转换为一个个小长方体的组合（与游戏：我的世界相似）。</li><li>体素化的过程是将三维几何体转化为一个三维的voxels（体素）网格，体素是一个三维的小方块，每个体素都有自己的坐标和状态，状态可以是可通行、不可通行、障碍物等。</li><li>为什么要凸多边形：<ul><li>路径寻找生成一系列需要穿过的多边形（多边形走廊）</li><li>因为凸多边形在几何上就限定了其形状的规范性，至少其能保证，其内部任意两点之间是直线联通的，这对于后续算法有很重要的意义</li><li>凸性保证了最终路径被限制在多边形内，并且两个相邻多边形只有一个公共边（门户）</li><li>后续漏斗算法光滑路径也用到了这个性质</li></ul></li><li>NavMesh存储点：使用每个多边形的中心点作为存储点，因为多边形的中心点在多边形内部，所以可以保证路径不会穿过多边形的边界</li></ul><img src="/img/GAMES104/4-寻路系统/NavMesh存储点.png" height=300 /><ul><li>A*的启发式函数直接用两点间的直线距离</li></ul><img src="/img/GAMES104/4-寻路系统/A-Star算法启发式函数.png" height=300 /><ul><li>漏斗算法光滑路径，原理参考：<a href="https://blog.csdn.net/fengkeyleaf/article/details/118832924">漏斗算法原理及实现</a><ul><li>遍历所有polymesh的公共边，将公共边的左右顶点和起始点形成的边作为漏斗</li><li>如果新公共边顶点形成的漏斗比当前漏斗更窄，更新当前漏斗（将对应左&#x2F;右顶点移动到该位置，反之不更新）</li><li>如果新的一次顶点和起始点形成的边界越过了另一侧原顶点和起始点形成的边界，则将起始点移动到原顶点位置（并加入最短路径中），重新开始计算漏斗</li><li>最后将起始点和终点加入最短路径中</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> GAMES104 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-物理系统</title>
      <link href="/posts/50dadbb8.html"/>
      <url>/posts/50dadbb8.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-碰撞检测"><a href="#1-碰撞检测" class="headerlink" title="1. 碰撞检测"></a>1. 碰撞检测</h3><ul><li><p>参考资料：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/696725602">八叉树实现</a></li><li><a href="https://zhuanlan.zhihu.com/p/697130257">BVH实现</a></li></ul></li><li><p>Broad Phase：快速检测（检测有没有发生碰撞）</p><ul><li>按物体划分：<ul><li>BVH  <img src="/img/GAMES104/3-物理系统/BVH.png" height=350 /></li><li>Sort and Sweep：更新时方便因为已经排好序了只需局部调整  <img src="/img/GAMES104/3-物理系统/SortandSweep.png" height=350 /></li></ul></li><li>按空间划分：<ul><li>KD树</li><li>八叉树</li></ul></li></ul></li><li><p>Narrow Phase：精确检测（判断具体碰撞点EPA算法）</p><ul><li>基本形状交集测试</li><li>Minkowski差值（凸包）<ul><li>Minkowski和：两个凸包的顶点坐标相加（如果其中一个是点则是位移，如果是线段或面则是形成一个凸包）  <img src="/img/GAMES104/3-物理系统/MinkowskiSum.png" height=350 /></li><li>Minkowski差  <img src="/img/GAMES104/3-物理系统/MinkowskiDifference.png" height=350 /></li><li>如果两个凸包有交集则其Minkowski差的凸包一定包含原点  <img src="/img/GAMES104/3-物理系统/MinkowskiDifference1.png" height=350 /></li><li>使用GJK算法求：<ul><li>核心思想：通过迭代计算Minkowski差集的最近点，判断是否包含原点</li><li>迭代过程：<ol><li>初始化搜索方向向量(通常取两几何中心连线方向)</li><li>计算支撑点(support point)：在Minkowski差集沿当前方向的最远点</li><li>将支撑点加入单纯形(simplex)</li><li>判断当前单纯形是否包含原点：<ul><li>三角形&#x2F;四面体：通过重心坐标判断</li><li>线段：投影检测</li></ul></li><li>更新搜索方向朝向原点，重复直到满足终止条件</li></ol></li><li>终止条件：<ul><li>找到包含原点的单纯形 → 发生碰撞</li><li>当前支撑点与前一方向点积≤0 → 无碰撞</li></ul></li></ul></li></ul></li><li>分离轴（SAT）定理（AABB，OBB）<ul><li>分离轴定理：两个凸多边形之间如果不相交，那么必定存在一条线可以将两者进行分割。这条线称之为分割线（Seperating Line）</li><li>分离轴定理推论：两个凸多边形之间如果不相交，那么必定存在一条轴，让两多边形落在上面的投影线段不相交。这条轴称之为分离轴（Seperating Axis）</li><li>重要推论：两个凸多边形之间如果不相交，那么必定存在一条平行于这两个多边形中的某一条边的分割线，同时有一条垂直于该分割线的分割轴，让两多边形落在上面的投影线段不相交。  <img src="/img/GAMES104/3-物理系统/SAT.png" height=400 /></li><li>3D情况下：除了各个面、还需要各边叉乘得到的面组合  <img src="/img/GAMES104/3-物理系统/SAT_3D.png" height=400 /></li></ul></li></ul></li><li><p>总结：</p><ul><li>Minkowski差方法优点：<ul><li>适合任意凸体形状检测（不限于特定几何类型）</li><li>计算复杂度与几何体顶点数无关（仅依赖迭代次数）</li><li>天然支持连续碰撞检测（CCD）</li><li>通过GJK+EPA组合可同时获得碰撞存在性、穿透深度和接触点</li></ul></li><li>SAT方法优点：<ul><li>对AABB&#x2F;OBB等规则几何体检测效率极高</li><li>能直接获得分离轴和最小平移向量（MTV）</li><li>适合需要快速排除不相交物体的场景</li><li>对刚体变换不敏感（轴对齐特性保持计算稳定）</li><li>实现简单，适合硬件并行优化</li></ul></li></ul></li></ul><h3 id="2-BVH与四-八叉树"><a href="#2-BVH与四-八叉树" class="headerlink" title="2. BVH与四&#x2F;八叉树"></a>2. BVH与四&#x2F;八叉树</h3><hr><h4 id="1-均匀分布场景：四叉树-八叉树更优"><a href="#1-均匀分布场景：四叉树-八叉树更优" class="headerlink" title="1. 均匀分布场景：四叉树&#x2F;八叉树更优"></a><strong>1. 均匀分布场景：四叉树&#x2F;八叉树更优</strong></h4><ul><li><strong>原因</strong>：四叉树&#x2F;八叉树通过<strong>固定空间划分</strong>管理物体。当物体分布均匀时，每个子区域内的物体数量相近，树的深度一致，<strong>查询效率稳定</strong>（复杂度O(logN)）。例如：  </li><li><strong>案例</strong>：在2D城市地图中，建筑物均匀分布在网格化的街道中，四叉树每次查询只需遍历固定层数的节点，避免冗余检测。  </li><li><strong>优势</strong>：规则划分简化碰撞检测逻辑，无需频繁调整树结构。</li></ul><h4 id="2-不均匀分布场景：BVH更优"><a href="#2-不均匀分布场景：BVH更优" class="headerlink" title="2. 不均匀分布场景：BVH更优"></a><strong>2. 不均匀分布场景：BVH更优</strong></h4><ul><li><strong>原因</strong>：BVH基于<strong>物体包围盒的层次划分</strong>，动态调整包围盒的覆盖范围。当物体集中时（如大量物体堆积在某个角落），BVH的包围盒会紧密包裹实际物体，<strong>减少空区域遍历</strong>。例如：  </li><li><strong>案例</strong>：在3D太空场景中，飞船残骸聚集在某一区域，BVH通过SAH（Surface Area Heuristic）优化分割轴，将密集区域的包围盒细化，稀疏区域合并，减少冗余检测。  </li><li><strong>优势</strong>：四叉树在物体集中区域可能产生过深的分层（如100个物体挤在一个小区域内），导致查询效率骤降。</li></ul><h4 id="3-动态物体频繁移动：四叉树："><a href="#3-动态物体频繁移动：四叉树：" class="headerlink" title="3. 动态物体频繁移动：四叉树："></a><strong>3. 动态物体频繁移动：四叉树</strong>：</h4><ul><li>适合<strong>动态物体频繁移动</strong>的场景（如开放世界游戏中的玩家角色）。通过<strong>松散四叉树</strong>（出口边界扩大为入口边界的2倍），减少物体跨节点切换的频率。  </li><li><strong>案例</strong>：在MMO游戏中，100个玩家动态移动，四叉树每帧更新只需调整物体所在节点，无需重构整棵树。</li></ul><h4 id="4-静态或低频动态场景：BVH："><a href="#4-静态或低频动态场景：BVH：" class="headerlink" title="4. 静态或低频动态场景：BVH："></a><strong>4. 静态或低频动态场景：BVH</strong>：</h4><ul><li>适合<strong>静态或低频动态场景</strong>（如离线渲染）。动态物体需<strong>自底向上更新包围盒</strong>，若物体移动范围大（如爆炸后碎片飞散），重构子树成本较高。  </li><li><strong>案例</strong>：电影渲染中，预先构建BVH树加速光线追踪，但若场景中有大量动态爆炸特效，需频繁局部重构，效率下降。</li></ul><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a><strong>5.总结</strong></h4><table><thead><tr><th><strong>场景特征</strong></th><th><strong>推荐算法</strong></th><th><strong>关键原因</strong></th></tr></thead><tbody><tr><td>均匀分布的动态场景</td><td>四叉树&#x2F;八叉树</td><td>规则划分简化更新逻辑，松散结构减少节点切换</td></tr><tr><td>非均匀分布的静态场景</td><td>BVH</td><td>SAH优化包围盒，减少空区域遍历</td></tr><tr><td>小范围动态更新</td><td>BVH</td><td>局部包围盒更新成本低（如少量物体移动）</td></tr><tr><td>大规模动态物体（如MMO）</td><td>松散四叉树</td><td>出口边界扩大避免频繁重构，内存占用可预测</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> GAMES104 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2-渲染</title>
      <link href="/posts/58290cca.html"/>
      <url>/posts/58290cca.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-顶点法线"><a href="#1-顶点法线" class="headerlink" title="1. 顶点法线"></a>1. 顶点法线</h3><ul><li>参考文章：<a href="https://blog.csdn.net/bb_sy_w/article/details/122826036">https://blog.csdn.net/bb_sy_w/article/details/122826036</a></li><li>为什么要顶点法线：因为光照计算是针对每个顶点进行的因此需要确定顶点法线来计算光照照射到表面的角度</li><li>软表面（平滑着色）：顶点法线是共用该顶点的所有三角面法线的平均值。光照在顶点间插值时，法线的平滑过渡会形成曲面假象，例如球体表面光滑的外观</li><li>硬表面（锐利边缘）：顶点法线保留各三角面的原始法线，不进行平均。这导致相邻面间的法线突变，光照插值产生清晰棱角，例如立方体的硬边效果。</li></ul><table><thead><tr><th align="center">特性</th><th align="center">软表面（平滑）</th><th align="center">硬表面（锐利）</th></tr></thead><tbody><tr><td align="center">顶点法线计算方式</td><td align="center">共用面法线的平均</td><td align="center">各面法线独立存储</td></tr><tr><td align="center">光照效果</td><td align="center">平滑渐变（如球体）</td><td align="center">突变分界（如立方体棱角）</td></tr><tr><td align="center">适用场景</td><td align="center">生物模型、布料等有机形态</td><td align="center">机械、建筑等工业模型</td></tr><tr><td align="center">建模操作</td><td align="center">使用“平滑组”或自动法线平均</td><td align="center">手动设置硬边或断开法线统一性</td></tr></tbody></table><h3 id="2-物理材质模型"><a href="#2-物理材质模型" class="headerlink" title="2. 物理材质模型"></a>2. 物理材质模型</h3><ul><li>Phong模型</li><li>PBR模型：Physically-Based Rendering</li><li>Subsurface材质：Burley Subsurface Profile（次表面散射，指的是一种用于模拟光在半透明材料内部散射效果的材质类型，这种材质通常用于渲染如皮肤、蜡、大理石、树叶等材料）</li></ul><h3 id="3-渲染对象"><a href="#3-渲染对象" class="headerlink" title="3. 渲染对象"></a>3. 渲染对象</h3><ul><li>Submesh：整个物体的顶点是存在一个buffer中的，但是针对不同部分会分成多个submesh，会存一个count和offset(count是指的是这个submesh的顶点数量，offset是指的是这个submesh的顶点在buffer中的起始位置)</li></ul><img src="/img/GAMES104/2-渲染/Submesh.png" height=400 /><ul><li>资源池：对共用的Mesh，shader，texture会存在一个池中，然后不同物体会记录其索引来节约资源</li></ul><img src="/img/GAMES104/2-渲染/ResourcePool.png" height=400 /><ul><li>GPU Batch Rendering：合批，GPU Instancing（可以让GPU直接绘制大量重复物体）</li></ul><h3 id="4-可见性裁剪"><a href="#4-可见性裁剪" class="headerlink" title="4. 可见性裁剪"></a>4. 可见性裁剪</h3><ul><li>各种包围盒（Sphere，AABB，OBB（Object Bounding Box），凸包）</li><li>空间划分（BVH（Bounding Volume Hierarchy）：四叉树）</li><li>PVS（Potential Visibility Set）</li><li>GPU Culling：运算很快不用设计数据结构</li><li>Early-Z：对于被挡住的物体直接不绘制了，在片元着色器前面判断</li></ul><h3 id="5-纹理压缩"><a href="#5-纹理压缩" class="headerlink" title="5. 纹理压缩"></a>5. 纹理压缩</h3><ul><li>传统图片压缩格式（JPG&#x2F;PNG）的局限性<ul><li>不支持随机访问：JPG&#x2F;PNG等格式采用全局压缩算法（如离散余弦变换、霍夫曼编码），需整图解码才能访问单个像素，无法满足GPU渲染时局部纹理随机访问需求</li><li>需CPU解压：GPU无法直接读取压缩后的JPG&#x2F;PNG数据，必须由CPU解压为RGB&#x2F;RGBA等非压缩格式后再传输至显存，增加了内存占用和带宽开销</li></ul></li><li>块压缩纹理格式的优势<ul><li>基于分块的编码设计：将纹理划分为固定或可变大小的像素块独立压缩，每个块可单独解码，支持GPU直接随机访问。<ul><li>固定分块格式（如BC&#x2F;DXT系列）：以4×4像素为最小压缩单元，固定压缩比（如DXT1为4bpp，压缩率6:1），适用于桌面端和硬表面模型</li><li>可变分块格式（如ASTC）：支持4×4至12×12的多种块尺寸（压缩比从8bpp到0.89bpp），通过动态分配块内编码资源提升压缩质量，尤其适合移动端和复杂材质（如法线贴图、HDR）（可以不同细节用不同分块大小）</li></ul></li><li>直接GPU支持：压缩后的纹理可直接存储于显存中，渲染时按需解码所需区块，显著降低带宽和内存占用</li></ul></li></ul><img src="/img/GAMES104/2-渲染/BlockCompression.png" height=400 />]]></content>
      
      
      <categories>
          
          <category> GAMES104 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.Transform</title>
      <link href="/posts/c0bd01f3.html"/>
      <url>/posts/c0bd01f3.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-旋转变换矩阵推导"><a href="#1-旋转变换矩阵推导" class="headerlink" title="1. 旋转变换矩阵推导"></a>1. 旋转变换矩阵推导</h3><ul><li>使用(1,0)和(0,1)作为特殊值求解得出</li></ul><img src="/img/GAMES101/1.旋转矩阵推导.png" height=350 /><h3 id="2-齐次坐标"><a href="#2-齐次坐标" class="headerlink" title="2. 齐次坐标"></a>2. 齐次坐标</h3><ul><li>将最后一个数设为1表示点，将最后一个数设为0表示向量（因为向量具有平移不变性所以最后数设置为0）</li><li>用齐次坐标统一仿射变换（坐标空间的线性变换）</li></ul><img src="/img/GAMES101/2.齐次坐标.png" height=350 /><h3 id="3-正交投影推导"><a href="#3-正交投影推导" class="headerlink" title="3. 正交投影推导"></a>3. 正交投影推导</h3><ul><li>模型定义（右手系，x叉乘y等于z）</li></ul><img src="/img/GAMES101/3.模型定义.png" height=350 /><ul><li>正交投影矩阵：</li></ul><img src="/img/GAMES101/4.正交投影矩阵.png" height=200 /><h3 id="4-透视投影推导"><a href="#4-透视投影推导" class="headerlink" title="4. 透视投影推导"></a>4. 透视投影推导</h3><ul><li>推导原理：首先对远平面挤压变成近平面大小求出透视变正交矩阵，再使用正交投影到近平面</li></ul><img src="/img/GAMES101/5.透视投影1.png" height=400 /><ol><li>利用三角形相似关系求出透视变正交矩阵三行值</li></ol><img src="/img/GAMES101/6.透视投影2.png" height=250 /><img src="/img/GAMES101/7.透视投影3.png" height=400 /><ol start="2"><li>利用两个特殊值联立方程求解：近平面的点(x, y, n)不会变，远平面的中点(0, 0, f)不会变</li></ol><img src="/img/GAMES101/8.透视投影4.png" height=400 /><ol start="3"><li>最后结合得到透视投影矩阵</li></ol><img src="/img/GAMES101/9.透视投影5.png" height=400 /><ul><li>中间平面挤压后z值会更靠近远平面 <a href="https://zhuanlan.zhihu.com/p/366606146">https://zhuanlan.zhihu.com/p/366606146</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> GAMES101 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HR面试</title>
      <link href="/posts/c340d75f.html"/>
      <url>/posts/c340d75f.html</url>
      
        <content type="html"><![CDATA[<h2 id="感謝と恩返し"><a href="#感謝と恩返し" class="headerlink" title="感謝と恩返し"></a>感謝と恩返し</h2><h3 id="1-做了这么多项目，你觉得最有成就感的是哪个？"><a href="#1-做了这么多项目，你觉得最有成就感的是哪个？" class="headerlink" title="1. 做了这么多项目，你觉得最有成就感的是哪个？"></a>1. 做了这么多项目，你觉得最有成就感的是哪个？</h3><p>Global Gamejam的2D消除类游戏。成就感体现需要在很短时间内即48小时完成一个完整游戏的开发，这锻炼了我的团队协作能力和快速开发游戏原型的能力。第一天晚上进行游戏方案策划，第二天进行逻辑编写，然后晚上进行试玩debug和提出修改意见，第三天早上进行修改</p><ul><li>技术上困难：<ol><li>场景中需要生成几百个大泡泡和小泡泡会造成画面卡顿，然后我通过使用对象池技术进行管理分别将预先生成一百个大泡泡和小泡泡数组，如果需要则取出，要是被消除或是出了视野外则回收，这样就有效缓解了帧率卡顿情况</li><li>不清楚如何实现在水中泡泡的随机运动，然后我想到使用柏林噪来添加随机的偏移，这样的好处是使得位置的变换更接近自然情况不会出现较大幅度的突变</li><li>大泡泡和小泡泡重叠时不能点击大泡泡来消除否则会出bug，增加一个bool值检测泡泡是否重叠如果重叠则设为false不能鼠标点击消除</li></ol></li><li>沟通时问题：<ol><li>在完成主题逻辑后策划提出了增加开始，倒计时和结束界面的需求并增加成就系统的UI，此时我评估了一下需要编写的时间优先对开始结束界面进行设计使用状态机来保游戏流程，最后时间还剩余了于是成就系统的UI设计</li></ol></li></ul><h3 id="2-为什么不选其他Offer？"><a href="#2-为什么不选其他Offer？" class="headerlink" title="2. 为什么不选其他Offer？"></a>2. 为什么不选其他Offer？</h3><ul><li>我非常喜欢战双和鸣潮，希望也能参与这样的项目做出好玩的游戏</li><li>我非常看好贵公司的项目，觉得非常有发展，对我个人技术而言也是挑战和提升，我更倾向于来贵公司工作</li></ul><h3 id="3-说一说自己的优缺点"><a href="#3-说一说自己的优缺点" class="headerlink" title="3. 说一说自己的优缺点"></a>3. 说一说自己的优缺点</h3><ul><li>性格：<ol><li>有好奇心</li><li>注重团队合作</li><li>会自我反思</li></ol></li><li>优点：<ol><li>喜欢主动学习：比如游戏开发和日语都是自己利用空余时间自学的，并且在工作中也会主动学习新的技术，比如在硕士期间也去学习了通信相关知识并进行硬件开发</li><li>责任心较强：比如在实验室中也担任了某方向的小组长，会在deadline前合理的安排各个组员的工作并且在平时也会每周进行小组会议进行讨论和解决问题来及时做出调制以确保在deadline前完成任务</li><li>做事时喜欢思考全再行动：比如在做一件事的时候我会尽量考虑周全这件事的所有可能情况并作出应对情况再行动，这样可以避免在做事情时出现错误（举例就说DVB）   </li><li>喜欢帮助别人，容易和他人相处，目前在实验室担任某方向小组长，经常帮助回答组员的问题，也和实验室其他人相处融洽</li></ol></li><li>缺点：<ol><li>面对很多人发言时会紧张：不擅长在很多人面前演讲，在很多人面前发表自己的意见时会很紧张，但是目前由于每周都需要开组会，我也会在大家面前汇报小组进展，现在已经能逐渐适应了</li><li>技术视野还不够广阔：比如在游戏开发时只是在参考了网上查找的一些资料并不清楚工业界的解决方案，我希望能够在今后的工作中不断学习新的技术来提高自己的技术水平</li></ol></li></ul><h3 id="4-为什么不去做硬件而是来做游戏？"><a href="#4-为什么不去做硬件而是来做游戏？" class="headerlink" title="4. 为什么不去做硬件而是来做游戏？"></a>4. 为什么不去做硬件而是来做游戏？</h3><ul><li>首先我本人从本科的时候就对游戏开发很感兴趣，并且在本科期间也加入了游戏编程社团也参与过社团活动制作了小游戏在迎新活动中展示，考研的时候也是想选择网络方向这样和游戏开发有关联并且也想学习一些新技术以便有更多的选择，但目前还是对游戏开发比较感兴趣，也希望在未来的工作中也能参与到游戏开发中</li></ul><h3 id="5-说说职业规划"><a href="#5-说说职业规划" class="headerlink" title="5. 说说职业规划"></a>5. 说说职业规划</h3><p>我个人喜欢钻研技术，并且希望一直在技术这条路上走下去，会主动发现项目里的设计或者性能问题，乐于给出经过验证的解决方案。有什么新技术也乐于和大家一起研究分享。能一直做游戏就挺知足了。</p><ol><li>所以前几年工作时我想侧重于进行GamePlay相关的开发来积累一些技术经验</li><li>后面的话我想在空余时间学习一些计算机图形学相关知识，希望能够多学习一些渲染相关知识今后可能会往TA方向发展</li></ol><h3 id="6-有什么问题想问"><a href="#6-有什么问题想问" class="headerlink" title="6. 有什么问题想问"></a>6. 有什么问题想问</h3><ol><li>想了解一些贵公司新人培训流程</li><li>想了解一下贵公司定期技术分享的情况</li><li>想了解一些贵公司目前项目组的人员配置</li><li>想了解贵公司的技术栈</li></ol><h3 id="7-如何看待加班"><a href="#7-如何看待加班" class="headerlink" title="7. 如何看待加班"></a>7. 如何看待加班</h3><ul><li>游戏行业快速迭代赶进度，加班在所难免。首先我会提高自己的效率，尽可能在短时间内高质量完成功能。项目忙的时候加班很正常，我会跟着团队一起克服困难，保证项目的排期，及时的迭代发布上去。然后针对项目里的一些低效问题制作一些通用工具，做一些自动化处理的东西，提高效率。</li></ul><h3 id="8-兴趣爱好"><a href="#8-兴趣爱好" class="headerlink" title="8. 兴趣爱好"></a>8. 兴趣爱好</h3><ul><li>打乒乓球，羽毛球，学习日语做直播切片翻译，游戏开发</li></ul><h3 id="9-如何和策划，测试，美术沟通的"><a href="#9-如何和策划，测试，美术沟通的" class="headerlink" title="9. 如何和策划，测试，美术沟通的"></a>9. 如何和策划，测试，美术沟通的</h3><ul><li>会遵守标准的流程，先看需求文档，再开需求评审会。在这之前我就会把需求可能遗漏的点，风险点，设计和现有逻辑冲突等问题整理总结好。在会议上耐心听策划讲解，然后自由讨论环节简明扼要提出问题。在会议上就解决需求不明的问题。如果实际开发中遇到新的问题，我会及时群里同步给大家，抛出风险点并给出解决方案，商量着如何高效解决，绝对不能影响线上迭代。</li></ul><h3 id="10-为什么本科不去实习"><a href="#10-为什么本科不去实习" class="headerlink" title="10. 为什么本科不去实习"></a>10. 为什么本科不去实习</h3><ul><li>那段时间是疫情期间不太好找实习，而且学校课程比较多不方便去实习，并且当时对未来规划也不是很明确，所以就没有去实习。</li></ul><h3 id="11-为什么选择考研"><a href="#11-为什么选择考研" class="headerlink" title="11. 为什么选择考研"></a>11. 为什么选择考研</h3><ul><li>我想去多深入学习一些知识对未来就业有更多选择，同时也希望能够在未来的工作中能够参与到游戏开发中，提高自己的技术水平。</li><li>提升学历</li></ul><h3 id="12-为什么选择做游戏开发"><a href="#12-为什么选择做游戏开发" class="headerlink" title="12. 为什么选择做游戏开发"></a>12. 为什么选择做游戏开发</h3><ul><li>首先自己本身小时候就喜欢玩游戏，比如游戏王卡牌，4399小游戏等，自己也尝试设计过一些卡牌游戏</li><li>然后在本科和硕士期间玩了FF14还有战双，原神等游戏，游戏的剧情，战斗和音乐融合在一起让我感到很震撼和感动，于是我也期望在未来的工作中也能参与到这样的游戏开发中来，从而做出能够触动人心的游戏产品</li></ul><h3 id="13-有没有遇到什么难题，又是怎么解决的（项目难点）"><a href="#13-有没有遇到什么难题，又是怎么解决的（项目难点）" class="headerlink" title="13. 有没有遇到什么难题，又是怎么解决的（项目难点）"></a>13. 有没有遇到什么难题，又是怎么解决的（项目难点）</h3><ul><li>比如实习时制作装备合成需求的功能时没考虑到大容量配方的情况编写的代码时间复杂度比较高导致了合成速度比较慢，然后我通过两个方法对代码进行优化从而解决了这个问题</li><li>多人在线项目的难点：（网络抖动现象）<ul><li>插值算法：我引入了插值算法来平滑玩家的移动和状态变化，减少抖动现象。</li><li>预测算法：我实现了客户端预测，提前处理玩家的动作，减少延迟对游戏体验的影响。</li><li>网络优化：我优化了网络包的大小和发送频率，减少了不必要的数据传输，提升了传输效率。</li></ul></li><li>平台移植，查找资料，学习不同平台IP核的使用差别</li><li>匹配滤波器实现，调制解调，编码解码实现，安排一部分人去学习通信知识，在小组会时一起分享所学成果</li><li>接收端方面难以实现，便去咨询了专业人士，后找到matlab的simulink进行HDL代码导出</li></ul><h3 id="14-薪资要求"><a href="#14-薪资要求" class="headerlink" title="14. 薪资要求"></a>14. 薪资要求</h3><ul><li>20k左右最好，但我也尊重贵公司的薪酬体系安排，我相信贵公司可以开出合理的薪资，我现在注重的是在游戏行业的工作机会，希望能通过实习了解商业游戏开发流程并积累游戏开发的经验，以便今后能为贵公司和国内游戏行业的发展做出自己的贡献</li></ul><h3 id="15-项目组倾向"><a href="#15-项目组倾向" class="headerlink" title="15. 项目组倾向"></a>15. 项目组倾向</h3><ul><li>更倾向与加入鸣潮项目组，因为鸣潮是我非常喜欢的游戏，我很希望能够参与到大世界动作游戏的开发，希望能够在今后的工作中也能参与到这样的项目中</li><li>但是我也尊重贵公司的安排，我也会考虑其他项目组的情况，希望能够在今后的工作中也能参与到这样的项目中</li><li>目前我也在学习UE引擎（各个大厂近年来UE项目也逐渐增多），考虑到未来可能会有不同的选择于是提前学习这方面的知识希望今后能胜任这方面的工作</li></ul><h3 id="16-游戏客户端方向"><a href="#16-游戏客户端方向" class="headerlink" title="16. 游戏客户端方向"></a>16. 游戏客户端方向</h3><ul><li>UI开发</li><li>gameplay</li><li>网络开发</li><li>渲染</li><li>游戏工具链</li></ul><h3 id="17-平时怎么学习"><a href="#17-平时怎么学习" class="headerlink" title="17. 平时怎么学习"></a>17. 平时怎么学习</h3><ul><li>跟着课程去学，同时加入自己的理解，去总结为啥这么写。多记录笔记和日常出的bug。同时注重自己的基础，毕竟是计算机专业，基础知识要扎实 </li><li>去github查看开源项目源码或是看引擎源码</li><li>去看官方文档</li><li>看论文</li></ul><h3 id="18-找工作比较看中公司哪些地方"><a href="#18-找工作比较看中公司哪些地方" class="headerlink" title="18. 找工作比较看中公司哪些地方"></a>18. 找工作比较看中公司哪些地方</h3><ul><li>技术实力和创新能力：希望能在技术实力强、创新氛围浓厚的团队中工作，不断学习和提升自己的技术能力</li><li>团队氛围和协作文化：希望加入一个开放、包容且注重团队合作的团队。良好的团队氛围不仅能提高工作效率，还能促进个人成长</li><li>职业发展机会：我愿意在公司长期发展，同时也希望公司能为我提供实现个人目标的平台</li><li>项目类型和挑战性：我对项目类型和挑战性非常感兴趣，希望参与具有创新性和挑战性的项目，能够在工作中不断学习和成长</li><li>公司文化和价值观：我希望能在一家有社会责任感和积极价值观的公司工作（比如喜欢二次元会更优先去制作二次元游戏的公司）</li></ul><h3 id="19-工作地点考虑"><a href="#19-工作地点考虑" class="headerlink" title="19. 工作地点考虑"></a>19. 工作地点考虑</h3><ul><li>在大城市就有发展，提高自己的视野，加入大平台机会多</li><li>亲戚朋友在某地较多</li></ul><h3 id="20-做的比较好的项目"><a href="#20-做的比较好的项目" class="headerlink" title="20. 做的比较好的项目"></a>20. 做的比较好的项目</h3><ul><li>3DARPG项目，用了多种技术</li><li>服务端数据库的设计</li><li>使用NavMesh和行为树实现怪物AI</li><li>使用了多种数据存储方式</li><li>使用MVC框架实现了UI和逻辑的分离制作了多个UI系统，并进行了优化</li></ul><h3 id="21-压力相关问题"><a href="#21-压力相关问题" class="headerlink" title="21. 压力相关问题"></a>21. 压力相关问题</h3><ul><li>主要回答自己有抗压能力</li><li>可以回答实习期间需要兼顾实验室任务</li></ul><h3 id="22-实习收获"><a href="#22-实习收获" class="headerlink" title="22. 实习收获"></a>22. 实习收获</h3><ul><li>技术层面：学习了贴图格式和lua语言的使用</li><li>团队协作层面：学习了如何和策划对接需求进行沟通，开组会</li><li>代码层面提升：写代码时会考虑到性能和效率，避免出现性能问题</li></ul><h3 id="23-为什么要学习日语"><a href="#23-为什么要学习日语" class="headerlink" title="23. 为什么要学习日语"></a>23. 为什么要学习日语</h3><ul><li>首先本身对动漫很感兴趣看的也多，平常的一些句子也能听得懂所以想着不如系统性的学习一下也是多门技术</li><li>其次是想要延续汉化组这种为爱发电的精神吧</li></ul><h3 id="24-最有成就感的事情"><a href="#24-最有成就感的事情" class="headerlink" title="24. 最有成就感的事情"></a>24. 最有成就感的事情</h3><ul><li>一是学习了日语，坚持时间久，并且也成功加入了字幕组参与了汉化工作</li><li>其次就是参加了GGJ和团队完整做出了一款游戏</li><li>本科社团活动</li></ul><h3 id="25-公司经历"><a href="#25-公司经历" class="headerlink" title="25. 公司经历"></a>25. 公司经历</h3><ul><li>松伦哥：2013年乐之游戏（休闲卡牌《极品神仙》担任主UI） -&gt;  2014年和刘胜成立库洛（布卡漫画第一笔投资）</li><li>2014年珠海库洛 -&gt; 2017年广州库洛（15年就迁过去了）</li><li>2016年战场双马尾（2D弹道射击游戏，cocos），（晨之科代为发行）运营不行，发行权不在自身手中，2018年关服</li><li>2017年尼尔 -&gt; 2017年战双开始立项（用unity）-&gt; 英雄互娱投资 -&gt; 2019年12月5日公测 -&gt; 开服黑卡事件发错黑卡数量 -&gt; 把玩家当人看，认真听取玩家意见，游戏皮肤一直在上线前都在修改</li><li>2020年鸣潮立项，动作游戏+开放世界+UE -&gt; 2023年腾讯投资+技术支持 -&gt; 2024年公测 -&gt; 1.1版本逆转（听取玩家意见进行迭代优化） -&gt; 全局光追</li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9-回溯</title>
      <link href="/posts/1926919d.html"/>
      <url>/posts/1926919d.html</url>
      
        <content type="html"><![CDATA[<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46-全排列"></a>46-全排列</h3><ul><li>全排列II需要不能重复的元素用set.insert()去重，unordered_set不能对vector去重</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78-子集"></a>78-子集</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39-组合总和"></a>39-组合总和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> idx, <span class="type">int</span> sum, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = idx; i &lt; candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="comment">// 组合问题直接传i</span></span><br><span class="line">            <span class="built_in">dfs</span>(candidates, i, sum, target);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, <span class="number">0</span>, <span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>总结</title>
      <link href="/posts/c8d0539d.html"/>
      <url>/posts/c8d0539d.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-UGUI相关"><a href="#1-UGUI相关" class="headerlink" title="1. UGUI相关"></a>1. UGUI相关</h3><ol><li>Canvas三种渲染模式：<ul><li>Screen Space - Overlay：屏幕空间，覆盖整个屏幕，忽略相机</li><li>Screen Space - Camera：屏幕空间，根据相机进行渲染，忽略相机的深度</li><li>World Space：UI作为3D对象存在于场景中，适合游戏内可交互的3D UI（如角色头顶名字、场景中的告示牌）</li></ul></li><li>性能瓶颈：提到 Draw Call 过多（Batch 不合理）[是指一次渲染调用的次数]、Canvas 重建（Dynamic 元素频繁更新）、Overdraw 过多（重叠透明元素）[是指同一个像素被多次渲染，导致颜色叠加，从而产生的像素点。]<br>排查方法：用 Profiler 分析 Draw Call 和 CPU 使用，检查 Canvas 的 Rebuild 次数<br>优化方案：<ul><li>减少 Draw Call：合并材质，使用 Sprite Atlas合并图集，合理分 Canvas</li><li>减少 Canvas 重建：将动态更新的 Text 或 Image 单独放一个 Canvas，静态元素保持不变（Tips弹窗优化）</li><li>减少 Overdraw：调整 UI 层级，减少透明重叠，使用遮罩优化</li></ul></li><li>UGUI 点击检测的工作原理:<ul><li>EventSystem：场景中必须有一个 EventSystem 组件，它负责管理和分发输入事件。</li><li>InputModule：如 Standalone Input Module 或 Touch Input Module，负责接收鼠标、触摸等输入，并将其转化为事件。</li><li>GraphicRaycaster：挂在 Canvas 上，用于检测 UI 元素是否被点击。它会根据输入位置发射一条虚拟射线（Ray），判断哪些 UI 对象被命中。</li><li>Raycast Target：UI 元素（如 Image、Text）上有一个“Raycast Target”选项，勾选后该元素才会参与射线检测<br>(1) UGUI 的点击检测是通过 EventSystem 和 GraphicRaycaster 实现的。当用户点击屏幕时，InputModule 捕获输入位置，GraphicRaycaster 基于这个位置发射虚拟射线，检测 Canvas 下的 UI 元素。只有启用了 Raycast Target 的元素会被检测到。命中后，系统会根据层级顺序触发事件，比如 OnPointerDown。我在项目中用它实现过按钮点击和拖拽功能<br>(2) UGUI 的点击检测是基于网格的。每个 UI 元素在渲染时会生成一个 Mesh，比如 Image 是矩形网格，Text 是字符拼接的网格。GraphicRaycaster 会用射线检测这些网格，只有命中网格内的三角形才算点击有效。比如我用带透明的 Sprite 时，只有非透明区域能点到，这就依赖网格的精确碰撞检测</li></ul></li><li>图集举例：对游戏主界面多个UI元素打包成图集，减少Draw Call，减少内存占用，或者尽量使用同一个材质（DrawCall从原本的20+降低至3~5）；</li><li>对象池举例：战斗场景中频繁弹出伤害飘字（每秒生成数百个Text组件），频繁的创建销毁导致GC卡顿（用对象池预生成10个，GC频率从每秒20次降至接近0）</li><li>组合优化：无限滚动列表（使用对象池+图集）（滚动帧率从30 FPS提升至稳定60 FPS）</li></ol><h3 id="2-动画系统相关"><a href="#2-动画系统相关" class="headerlink" title="2. 动画系统相关"></a>2. 动画系统相关</h3><ol><li>Animation 动画系统：<ul><li>关键帧插值实现</li></ul></li><li>Animator 动画系统：<ul><li>需要Controller，状态机，参数，动画片段，过渡条件，动画事件（运行时无法动态增删动画）</li><li>Blend Tree 混合树：根据参数值混合多个动画片段<ul><li>1D：根据参数值线性混合</li><li>2D：根据参数值的二维空间混合</li></ul></li><li>Layer 层：控制动画的播放顺序，同一时间只能播放一个动画，使用Avatar Mask控制动画的可见性实现上半身和下半身动作融合</li><li>Blend Mode 混合模式：<ul><li>Additive：叠加混合，适用于叠加效果的动画</li><li>Override：覆盖混合，适用于覆盖效果的动画</li></ul></li></ul></li><li>Playable 动画系统：<ul><li>先PlayableGraph，再PlayableOutput绑定Graph到Animator</li><li>接着创建Playable设定Clip，然后PlayableOutput连接Playable，最后PlayableGraph播放</li></ul></li><li>Timeline 动画系统：<ul><li>通过可视化时间轴控制动画、音频、剧情等资源的时序逻辑</li><li>适用于过场动画、剧情编排</li></ul></li><li>2D动画技术：序列帧，Live2D，Spine</li><li>3D动画技术：刚性层次动画，逐顶点动画，变形目标动画，蒙皮动画，物理动画（Ragdoll，FK，IK）</li><li>蒙皮动画：<ul><li>mesh绑定骨骼有权重</li><li>四元数方便旋转</li><li>Local&#x2F;Model&#x2F;World（local空间插值，同一父节点不会乱）</li><li>蒙皮调色板：一组用于蒙皮动画的矩阵集合，顶点变换，权重混合（一个顶点受多个骨骼影响）</li><li>LERP插值，NLERP（归一化）插值[四元数，角速度不定]，SLERP（球面）插值[四元数，角速度恒定，计算量较大]：θ大时用SLERP，θ接近零时用NLERP</li></ul></li><li>动画管线：在CPU端，首先进行的是动画数据的提取（Extract），将包含时间信息的动画剪辑（Clip + time）作为输入。这些剪辑在局部空间（Local Space）中被处理成局部姿势（Local Pose），随后通过混合（Blend）过程，根据权重等因素将多个局部姿势混合成一个混合姿势（Blend Pose）。混合后的姿势被转换到模型空间（Model Space），形成模型姿势（Model Pose）。接下来是后处理（Post-processing）阶段，模型姿势被进一步处理成世界姿势（World Pose），以适应场景的世界坐标系。在此过程中，逆运动学（IK）计算会对世界姿势进行调整，以确保角色动作符合物理规律和交互需求。最后，经过IK调整的世界姿势在世界空间（World Space）中进行蒙皮（Skinning）处理，通过蒙皮矩阵调色板（Skinning Matrix Palette）将姿势应用到网格顶点，得到最终的网格顶点位置（Mesh Vertex Position），并通过GPU进行渲染。整个管线高效地整合了动画提取、混合、空间转换、物理调整和蒙皮等多个步骤，确保了动画的流畅性和真实性。</li></ol><img src="/img/总结/动画管线.png" height=400 /><ol start="9"><li>动画数据压缩：通过减少自由度、关键帧提取（删除可通过插值还原的冗余帧，Catmull-Rom样条曲线：通过控制点拟合平滑动画路径，减少数据量）、浮点量化、四元数量化等方法减少动画数据大小，需考虑误差传播和补偿</li><li>IK：limb, CCD(可优化不断缩小), FABRIK<table><thead><tr><th>算法</th><th>适用于</th><th>效果</th><th>性能消耗</th><th>什么时候用?</th></tr></thead><tbody><tr><td>Limb</td><td>2个骨骼</td><td>自然</td><td>低</td><td>处理2个骨骼的IK时</td></tr><tr><td>CCD</td><td>多个骨骼</td><td>不一定自然</td><td>较高</td><td>IK系统不是很复杂，且对于自然度要求不是很高时</td></tr><tr><td>FABRIK</td><td>多个骨骼</td><td>自然</td><td>较高</td><td>IK系统较复杂，或对效果要求较高时</td></tr></tbody></table></li></ol><h3 id="3-寻路系统相关"><a href="#3-寻路系统相关" class="headerlink" title="3. 寻路系统相关"></a>3. 寻路系统相关</h3><ol><li>静态物体标记，体素化，生成多边形网格，NavMesh Agent&#x2F;Obstacle，offmesh link</li><li>A*算法全局路径搜索，漏斗算法局部路径优化，动态避障算法</li></ol><h3 id="4-网络相关"><a href="#4-网络相关" class="headerlink" title="4. 网络相关"></a>4. 网络相关</h3><ol><li><p>优化网络延迟导致的位置抖动：</p><ul><li>NetworkTransform配置：调整同步频率（syncInterval），降低冗余数据；启用插值（interpolate）平滑移动。</li><li>预测算法：客户端预判移动轨迹（如速度方向），服务器权威位置修正后补偿误差。</li><li>RPC优化：对高频操作（如切菜动作）采用缓冲队列，合并短时间内的多次调用。</li></ul></li><li><p>帧同步一个客户端延迟怎么办：</p><ul><li>bucket：将延迟分为若干个桶，每个桶内的延迟都可以接受。</li><li>指令缓存与追帧：延迟窗口，追帧插入（场景：玩家A在第10帧点击“切菜”按钮，但指令因网络延迟在第10帧结束后50ms才到达服务器。处理流程：服务器行为：第10帧处理时，检测到指令未到达，但仍在100ms延迟窗口内。将指令存入第10帧的缓冲区，而非视为第11帧的指令。广播执行：服务器在第10帧的延迟窗口结束后，将缓冲区内的所有指令（含玩家A的切菜指令）广播给所有客户端。所有客户端在第10帧统一执行该指令，播放切菜动画）</li><li>客户端预测，插值：根据服务器提供的历史数据，预测客户端未来的位置和状态。</li><li>服务器回滚：服务器根据客户端提供的历史数据，回滚到客户端的历史状态。</li></ul></li><li><p>buffer平滑网络抖动，逻辑帧插入渲染帧平滑</p></li><li><p>帧同步checksum判断是否作弊</p></li><li><p>状态同步要客户端预测（半个RTT）来平滑输入，最后还需和客户端（buffer）和解</p></li><li><p>内插平滑，外插预测，航位预测法（PVB算法平滑位移做速度和位置插值）</p></li><li><p>命中判定：(服务器会buffer对面之前位置来延迟补偿然后检测是否击中)</p><ul><li>碰撞检测：使用物理引擎或自定义碰撞检测算法。</li><li>射线检测：从相机位置发射射线，检测是否与场景中的物体碰撞。</li><li>网格检测：将场景划分为网格，检测射线是否与网格相交。</li></ul></li><li><p>时间同步</p><img src="/img/总结/NTP时间同步.png" height=400 /></li></ol><h3 id="5-碰撞检测相关"><a href="#5-碰撞检测相关" class="headerlink" title="5. 碰撞检测相关"></a>5. 碰撞检测相关</h3><ol><li>BVH，OBB，AABB，KD树，四叉树，八叉树<ul><li>BVH（BFS）：将场景中的物体划分为若干个包围盒（AABB），每个包围盒内的物体都可以进行快速碰撞检测</li><li>OBB：将物体的旋转也考虑在内，用于精确碰撞检测</li><li>AABB：用于快速碰撞检测，用于计算物体的碰撞体积</li><li>KD树：用于快速碰撞检测，将场景中的物体基于坐标点划分为若干个包围盒，每个包围盒内的物体都可以进行快速碰撞检测</li></ul></li><li>分离轴定理（SAT），GJK算法，Minkowski差值</li><li>AOI算法：（或者十字链表）<ul><li>网格划分：将场景划分为若干个网格，每个网格内的角色都可以感知到其他网格内的角色</li><li>视野计算：根据角色的视野范围，计算出角色可以感知到的网格</li><li>角色移动：当角色移动到新的网格时，需要重新计算视野</li></ul></li><li>碰撞检测：<ul><li>离散碰撞检测 DCD</li><li>CCD算法：<ul><li>Sweep-based CCD（形成扫射区域，不能处理角速度（旋转）较大时物体的碰撞）</li><li>Speculative CCD（扩大AABB，提前检测碰撞）</li></ul></li></ul></li></ol><h3 id="6-AB打包相关"><a href="#6-AB打包相关" class="headerlink" title="6. AB打包相关"></a>6. AB打包相关</h3><h3 id="7-渲染相关"><a href="#7-渲染相关" class="headerlink" title="7. 渲染相关"></a>7. 渲染相关</h3><img src="/img/总结/渲染管线.png" height=400 /><img src="/img/总结/图元装配及光栅化.png" height=400 /><ul><li>数组算法题刷，排序</li><li>C++几个点</li><li>面经看</li><li>网络同步</li></ul><h3 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h3><ol><li><p>实习收获<br>在网易游戏实习期间，我主要参与了 Y3编辑器Lua开发框架 的开发，具体收获包括：</p><ul><li>技术实践：通过编写装备合成、刷怪等Demo，深入理解了Lua脚本在游戏开发中的应用，掌握了触发器、定时器的使用，以及如何在Moba游戏中设计交互逻辑（如装备购买界面）。</li><li>工具开发经验：参与贴图精度提升工具的开发，学习了贴图压缩格式（如ASTC、ETC2）的处理，并通过Python的PIL库实现了图片通道分离与格式转换，提升了自动化工具开发能力。</li><li>协作与规范：优化了Lua框架的API文档规范，使用Python脚本解析Excel和Markdown文件，建立了函数与注释的自动映射流程，强化了代码可维护性和团队协作效率。</li></ul></li><li><p>自己优缺点</p><ul><li>优点：<ul><li>我学习能力强，能快速掌握新知识和技能，适应工作变化。</li><li>我责任心强，对工作认真负责，能按时高质量完成任务。</li><li>我沟通能力好，善于与人交流，能有效表达和理解意图。</li><li>我有团队协作精神，能与不同背景的人合作，共同达成目标。</li></ul></li><li>缺点：<ul><li>我有时过于追求完美，可能会在细节上花费过多时间，影响效率。</li><li>面对批评时，我可能会比较敏感，但我会努力调整心态，积极改进。</li><li>在决策时，我可能会犹豫不决，不过我正在努力提升决策能力。</li></ul></li></ul></li><li><p>未来发展方向（规划）</p></li><li><p>现有游戏技术拆解</p><ul><li>《燕云十六声》 的NPC系统基于 自然语言处理（NLP） 动态生成对话</li><li>守望先锋使用状态同步</li><li>语音驱动嘴型动画技术</li><li>贴图变换：可以根据真实服饰的图片生成纹理，然后放入3D模型</li></ul></li></ol><p>单例模式确保一个类只有一个实例，并提供全局访问点。懒汉式通过延迟加载节省资源，但需额外处理线程安全（如双重检查锁），适合实例化成本高的场景；饿汉式在类加载时立即实例化，实现简单且线程安全，适合实例化成本低、使用频率高的场景。在实际开发中，需根据具体需求选择合适的方式</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-一维动态规划</title>
      <link href="/posts/465725e1.html"/>
      <url>/posts/465725e1.html</url>
      
        <content type="html"><![CDATA[<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70-爬楼梯"></a>70-爬楼梯</h3><ul><li>方法一：动态规划</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：递归（要想着把问题分解成子问题）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法三：优化递归</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo.<span class="built_in">count</span>(n) == <span class="number">0</span>) memo[n] = <span class="built_in">climbStairs</span>(n - <span class="number">1</span>) + <span class="built_in">climbStairs</span>(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198-打家劫舍"></a>198-打家劫舍</h3><ul><li>方法一：动态规划：dp[n-1]表示有n个房间的最大收益</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：优化动态规划</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> a = nums[<span class="number">0</span>], b = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]), c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            c = <span class="built_in">max</span>(b, a + nums[i]);</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139-单词拆分"></a>139-单词拆分</h3><ul><li>dp[i]表示字符串s前i个字符组成的字符串s[0..i−1] 是否能被空格拆分成若干个字典中出现的单词</li><li>状态转移方程：dp[i] &#x3D; dp[j] &amp;&amp; check(s[j..i−1])，所以遍历顺序这样写</li><li>注意vector没有find函数，需要用algorithm库中的find函数，可以考虑用unordered_set这样就能用find函数了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &amp;&amp; <span class="built_in">find</span>(wordDict.<span class="built_in">begin</span>(), wordDict.<span class="built_in">end</span>(), s.<span class="built_in">substr</span>(j, i - j)) != wordDict.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322-零钱兑换"></a>322-零钱兑换</h3><ul><li>背包问题：dp[i]表示凑成总金额为i所需的最少的硬币个数，注意循环写法</li><li>注意此处直接取MAX &#x3D; amount + 1因为最多只会有amount个硬币，所以amount + 1肯定是不会出现的</li><li>如果用INT_MAX会溢出要判断很麻烦</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> MAX = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; coins.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt;= MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300-最长递增子序列"></a>300-最长递增子序列</h3><ul><li>方法一：动态规划</li><li>dp[i]表示以nums[i]结尾的最长递增子序列的长度（递增序列包含了nums[i]）</li><li>状态转移方程：dp[i] &#x3D; max(dp[i], dp[j] + 1);，其中0 &lt;&#x3D; j &lt; i且num[j] &lt; num[i]</li><li>时间复杂度：O(n^2)，空间复杂度：O(n)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;           <span class="comment">// 注意需要双重循环遍历前面所有元素</span></span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：贪心+二分查找</li><li>时间复杂度：O(nlogn)，空间复杂度：O(n)</li><li>贪心：如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小</li><li>这里其实是维护了一个最小末尾数组d，d[i]表示长度为i+1的所有上升子序列的最小末尾值，并不是真实子序列，只需看其长度</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; d;  <span class="comment">// 维护的最小末尾数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 当前元素比所有末尾都大，直接扩展</span></span><br><span class="line">            <span class="keyword">if</span> (d.<span class="built_in">empty</span>() || num &gt; d.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                d.<span class="built_in">push_back</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则找到合适的位置替换</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 二分查找第一个 &gt;= num 的位置</span></span><br><span class="line">                <span class="type">int</span> left = <span class="number">0</span>, right = d.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="type">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (d[mid] &lt; num) &#123;</span><br><span class="line">                        left = mid + <span class="number">1</span>;  <span class="comment">// 排除较小值</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        right = mid;     <span class="comment">// 保留可能的位置</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                d[left] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53-最大子数组和"></a>53-最大子数组和</h3><ul><li>动态规划&#x2F;贪心，dp[i]表示以i结尾的最大子数组和，dp[i] &#x3D; max(dp[i-1]+nums[i], nums[i])</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简化动归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>, res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            cur = <span class="built_in">max</span>(cur + num, num);</span><br><span class="line">            res = <span class="built_in">max</span>(res, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 贪心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MIN, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            res = <span class="built_in">max</span>(res, sum);</span><br><span class="line">            <span class="comment">// 小于0就重置</span></span><br><span class="line">            <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><blockquote><ol><li>需要二维dp，表示物品背包重量</li><li>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</li><li>状态变化即物品i放或不放: dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维写法注意：</span></span><br><span class="line"><span class="comment">// 1. 先遍历物品再遍历背包，因为反过来的话dp[j]不会连续更新</span></span><br><span class="line"><span class="comment">// 2. 遍历背包需要倒序遍历，因为确保每次物品只放入一次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = N; j &gt;= cost[i]; --j) &#123;</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - costs[i]] + values[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长连续递增子串长度"><a href="#最长连续递增子串长度" class="headerlink" title="最长连续递增子串长度"></a>最长连续递增子串长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下标i为结尾的连续递增的子序列长度为dp[i]</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长递增子序列长度"><a href="#最长递增子序列长度" class="headerlink" title="最长递增子序列长度"></a>最长递增子序列长度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 对于每个 nums[i]，遍历从 0 到 i-1 的所有 nums[j]，检查是否满足 nums[i] &gt; nums[j]。</span></span><br><span class="line"><span class="comment">//2. 如果满足，则更新 dp[i] 为 dp[j] + 1，即以 nums[j] 结尾的子序列加上当前元素 nums[i] 形成的递增子序列。</span></span><br><span class="line"><span class="comment">//3. dp[i] 的值始终表示以 nums[i] 为结尾的最长递增子序列长度。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. dp[i][j] 表示 nums1 在索引 i-1 处和 nums2 在索引 j-1 处结尾的最长公共子数组的长度。</span></span><br><span class="line"><span class="comment">// 2. 如果 nums1[i-1] == nums2[j-1]，则 dp[i][j] = dp[i-1][j-1] + 1。否则，dp[i][j] = 0，因为此处没有公共子数组。</span></span><br><span class="line"><span class="comment">// 3. 当 i == 0 或 j == 0 时，无法使用 dp[i-1][j-1]，因此直接将 dp[i][j] 初始化为 1（如果 nums1[i] == nums2[j]）。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">1.</span><span class="built_in">size</span>(), m = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化第一行和第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    res = <span class="built_in">max</span>(res, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. dp[i][j]: 长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]</span></span><br><span class="line"><span class="comment">// 2. 可以声明dp数组时大一点来简化第一行和第一列的初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = text<span class="number">1.</span><span class="built_in">size</span>(), m = text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (text1[i] == text2[j]) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                        <span class="keyword">if</span> (j &gt; <span class="number">0</span>) dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (text1[i] == text2[j]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 记住遍历顺序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        string res_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j-i&lt;=<span class="number">1</span> || dp[i<span class="number">+1</span>][j<span class="number">-1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j-i<span class="number">+1</span> &gt; res) &#123;</span><br><span class="line">                        res_str = s.<span class="built_in">substr</span>(i, j-i<span class="number">+1</span>);</span><br><span class="line">                        res = j-i<span class="number">+1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 注意遍历顺序</span></span><br><span class="line"><span class="comment">// 2. 记得dp[i][i] = 1;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>, n = s.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) dp[i][j] = dp[i<span class="number">+1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">+1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                res = <span class="built_in">max</span>(res, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最大子串和"><a href="#最大子串和" class="headerlink" title="最大子串和"></a>最大子串和</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>], n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(nums[i], dp[i<span class="number">-1</span>] + nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="交错字符串-给定三个字符串-s1、s2、s3，请你帮忙验证-s3-是否是由-s1-和-s2-交错-组成的"><a href="#交错字符串-给定三个字符串-s1、s2、s3，请你帮忙验证-s3-是否是由-s1-和-s2-交错-组成的" class="headerlink" title="交错字符串 (给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的)"></a>交错字符串 (给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i][j] 表示s的前i+j个字符是否可以由part1的前i个和part2的前j个字符交错组成</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s<span class="number">1.</span><span class="built_in">size</span>(), m = s<span class="number">2.</span><span class="built_in">size</span>(), len = s<span class="number">3.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len != n + m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m<span class="number">+1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s3[i<span class="number">-1</span>] == s1[i<span class="number">-1</span>]) dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s3[j<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">                <span class="comment">// 是为了确保 dp[i][j] 可能来自任意一个方向的匹配</span></span><br><span class="line">                <span class="keyword">if</span> (s3[j+i<span class="number">-1</span>] == s1[i<span class="number">-1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (s3[j+i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) dp[i][j] = dp[i][j] || dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.图</title>
      <link href="/posts/848b9497.html"/>
      <url>/posts/848b9497.html</url>
      
        <content type="html"><![CDATA[<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200-岛屿数量"></a>200-岛屿数量</h3><ul><li>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</li><li>方法一：深度优先搜索</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] == <span class="string">&#x27;0&#x27;</span> || visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> newx = x + dir[i][<span class="number">0</span>], newy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newx &lt; <span class="number">0</span> || newx &gt;= grid.<span class="built_in">size</span>() || newy &lt; <span class="number">0</span> || newy &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(grid, visited, newx, newy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, visited, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：广度优先搜索</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curx = q.<span class="built_in">front</span>().first, cury = q.<span class="built_in">front</span>().second;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> newx = curx + dir[i][<span class="number">0</span>], newy = cury + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (newx &lt; <span class="number">0</span> || newx &gt;= grid.<span class="built_in">size</span>() || newy &lt; <span class="number">0</span> || newy &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (grid[newx][newy] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; !visited[newx][newy]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;newx, newy&#125;);</span><br><span class="line">                    visited[newx][newy] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    <span class="built_in">bfs</span>(grid, visited, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130-被围绕的区域"></a>130-被围绕的区域</h3><ul><li>(孤岛问题)给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</li><li>方法一：深度优先搜索</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board[x][y] == <span class="string">&#x27;X&#x27;</span> || visited[x][y]) <span class="keyword">return</span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> newx = x + dir[i][<span class="number">0</span>], newy = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (newx &lt; <span class="number">0</span> || newx &gt;= board.<span class="built_in">size</span>() || newy &lt; <span class="number">0</span> || newy &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(board, visited, newx, newy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 遍历从四周扩散进去的&#x27;O&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, visited, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, visited, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, visited, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">dfs</span>(board, visited, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：广度优先搜索</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt;&amp; visited, <span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;x, y&#125;);</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> curx = q.<span class="built_in">front</span>().first, cury = q.<span class="built_in">front</span>().second;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> newx = curx + dir[i][<span class="number">0</span>], newy = cury + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (newx &lt; <span class="number">0</span> || newx &gt;= board.<span class="built_in">size</span>() || newy &lt; <span class="number">0</span> || newy &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (board[newx][newy] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; !visited[newx][newy]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;newx, newy&#125;);</span><br><span class="line">                    visited[newx][newy] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 遍历从四周扩散进去的&#x27;O&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">bfs</span>(board, visited, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (board[i][n - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">bfs</span>(board, visited, i, n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">bfs</span>(board, visited, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (board[m - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>) <span class="built_in">bfs</span>(board, visited, m - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span> &amp;&amp; !visited[i][j]) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133-克隆图"></a>133-克隆图</h3><ul><li>给无向连通图中一个节点的引用，请返回该图的深拷贝（克隆）</li><li>方法一：深度优先搜索</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">    <span class="function">Node* <span class="title">dfs</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited.<span class="built_in">find</span>(node) != visited.<span class="built_in">end</span>()) </span><br><span class="line">            <span class="keyword">return</span> visited[node];</span><br><span class="line">        </span><br><span class="line">        Node* cloneNode = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Node* neighbor : node-&gt;neighbors) &#123;</span><br><span class="line">            cloneNode-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">dfs</span>(neighbor));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/img/7-图/7-133.png" height=800 /><p>方法二：广度优先搜索</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">    <span class="function">Node* <span class="title">bfs</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        unordered_map&lt;Node*, Node*&gt; visited;</span><br><span class="line">        queue&lt;Node*&gt; q;</span><br><span class="line">        </span><br><span class="line">        Node* cloneNode = <span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        visited[node] = cloneNode;</span><br><span class="line">        q.<span class="built_in">push</span>(node);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (Node* neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(neighbor) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    visited[neighbor] = <span class="keyword">new</span> <span class="built_in">Node</span>(neighbor-&gt;val);</span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">                visited[cur]-&gt;neighbors.<span class="built_in">push_back</span>(visited[neighbor]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneNode;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399-除法求值"></a>399-除法求值</h3><ul><li>条件：a &#x2F; b &#x3D; 2.0, b &#x2F; c &#x3D; 3.0，问题：a &#x2F; c &#x3D; ?, b &#x2F; a &#x3D; ?, a &#x2F; e &#x3D; ?, a &#x2F; a &#x3D; ?, x &#x2F; x &#x3D; ?，结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]，注意：x 是未定义的 &#x3D;&gt; -1.0</li><li>深度优先搜索，注意回溯</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, unordered_map&lt;string, <span class="type">double</span>&gt;&gt; graph;</span><br><span class="line">    unordered_set&lt;string&gt; visited;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(string start, string end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.<span class="built_in">find</span>(start) == graph.<span class="built_in">end</span>() || graph.<span class="built_in">find</span>(end) == graph.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (graph[start].<span class="built_in">find</span>(end) != graph[start].<span class="built_in">end</span>()) <span class="keyword">return</span> graph[start][end];</span><br><span class="line">        </span><br><span class="line">        visited.<span class="built_in">insert</span>(start);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; neighbor : graph[start]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">find</span>(neighbor.first) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">double</span> res = <span class="built_in">dfs</span>(neighbor.first, end);</span><br><span class="line">                <span class="keyword">if</span> (res != <span class="number">-1.0</span>) &#123;</span><br><span class="line">                    visited.<span class="built_in">erase</span>(start); <span class="comment">// 回溯</span></span><br><span class="line">                    <span class="keyword">return</span> neighbor.second * res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.<span class="built_in">erase</span>(start); <span class="comment">// 回溯</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; equations.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string a = equations[i][<span class="number">0</span>], b = equations[i][<span class="number">1</span>];</span><br><span class="line">            graph[a][b] = values[i];</span><br><span class="line">            graph[b][a] = <span class="number">1.0</span> / values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; q : queries) &#123;</span><br><span class="line">            visited.<span class="built_in">clear</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">dfs</span>(q[<span class="number">0</span>], q[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：广度优先搜索，注意写法：auto [curr, value] &#x3D; q.front();</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, unordered_map&lt;string, <span class="type">double</span>&gt;&gt; graph; <span class="comment">// 图：起点 -&gt; &#123;终点: 权重&#125;</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">bfs</span><span class="params">(string start, string end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.<span class="built_in">find</span>(start) == graph.<span class="built_in">end</span>() || graph.<span class="built_in">find</span>(end) == graph.<span class="built_in">end</span>()) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (start == end) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        queue&lt;pair&lt;string, <span class="type">double</span>&gt;&gt; q;</span><br><span class="line">        unordered_set&lt;string&gt; visited;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;start, <span class="number">1.0</span>&#125;);</span><br><span class="line">        visited.<span class="built_in">insert</span>(start);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [curr, value] = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; neighbor : graph[curr]) &#123;</span><br><span class="line">                string next = neighbor.first;</span><br><span class="line">                <span class="type">double</span> weight = neighbor.second;</span><br><span class="line">                <span class="keyword">if</span> (visited.<span class="built_in">find</span>(next) == visited.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    <span class="type">double</span> newValue = value * weight;</span><br><span class="line">                    <span class="keyword">if</span> (next == end) </span><br><span class="line">                        <span class="keyword">return</span> newValue;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;next, newValue&#125;);</span><br><span class="line">                    visited.<span class="built_in">insert</span>(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; equations.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string a = equations[i][<span class="number">0</span>], b = equations[i][<span class="number">1</span>];</span><br><span class="line">            graph[a][b] = values[i];</span><br><span class="line">            graph[b][a] = <span class="number">1.0</span> / values[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; q : queries) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">bfs</span>(q[<span class="number">0</span>], q[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207-课程表"></a>207-课程表</h3><ul><li>拓扑排序</li><li>方法一：深度优先搜索</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges; <span class="comment">// 邻接表表示图</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;       <span class="comment">// 状态：0=未访问，1=访问中，2=已完成</span></span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;         <span class="comment">// 是否无环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>; <span class="comment">// 标记为访问中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123; <span class="comment">// 未访问的邻居</span></span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) <span class="keyword">return</span>; <span class="comment">// 如果发现环，提前退出</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123; <span class="comment">// 访问中的邻居，说明有环</span></span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// visited[v] == 2 时无需处理，已确认无环</span></span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>; <span class="comment">// 当前节点及其子树处理完毕，标记为已完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info : prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]); <span class="comment">// info[1] 是先修课，info[0] 是后续课</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从每个未访问的节点开始 DFS</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123; <span class="comment">// 只对未访问的节点进行 DFS</span></span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：广度优先搜索(重点)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indegree;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; indegree)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="comment">// 初始化：入度为 0 的节点入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS 处理</span></span><br><span class="line">        <span class="type">int</span> visitedCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            visitedCount++;</span><br><span class="line">            <span class="comment">// 遍历邻居，减少入度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v : edges[u]) &#123;</span><br><span class="line">                indegree[v]--;</span><br><span class="line">                <span class="keyword">if</span> (indegree[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否所有节点都被处理</span></span><br><span class="line">        <span class="keyword">return</span> visitedCount == numCourses;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建图和入度数组</span></span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indegree.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info : prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]); <span class="comment">// info[1] -&gt; info[0]</span></span><br><span class="line">            indegree[info[<span class="number">0</span>]]++;               <span class="comment">// 记录入度</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 BFS</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bfs</span>(numCourses, edges, indegree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210-课程表 II"></a>210-课程表 II</h3><ul><li>拓扑排序，输出序列</li><li>注意最后需要判断是否输出{}，edges别初始化成邻接矩阵</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numCourses == <span class="number">1</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edges</span>(numCourses);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">indegrees</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; info : prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">            indegrees[info[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> course : edges[cur]) &#123;</span><br><span class="line">                indegrees[course]--;</span><br><span class="line">                <span class="keyword">if</span> (indegrees[course] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(course);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res.<span class="built_in">size</span>() != numCourses) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Dijstra"><a href="#Dijstra" class="headerlink" title="Dijstra"></a>Dijstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Dijstra</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; graph, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isVisited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        dis[i] = graph[idx][i];</span><br><span class="line">    &#125;</span><br><span class="line">    isVisited[idx] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k) &#123;</span><br><span class="line">        <span class="type">int</span> cur_idx = <span class="number">0</span>, min_dis = INT_MAX;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i] &lt; min_dis &amp;&amp; !isVisited[i]) &#123;</span><br><span class="line">                min_dis = dis[i];</span><br><span class="line">                cur_idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[j] &gt; dis[cur_idx] + graph[cur_idx][j] &amp;&amp; !isVisited[j]) &#123;</span><br><span class="line">                dis[j] = dis[cur_idx] + graph[cur_idx][j]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isVisited[cur_idx] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.栈</title>
      <link href="/posts/48a579df.html"/>
      <url>/posts/48a579df.html</url>
      
        <content type="html"><![CDATA[<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20-有效的括号"></a>20-有效的括号</h3><ul><li>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</li><li>用栈模拟，注意字典设置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; pairs = &#123;</span><br><span class="line">            &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pairs.<span class="built_in">count</span>(ch)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pairs[ch]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="71-简化路径"><a href="#71-简化路径" class="headerlink" title="71-简化路径"></a>71-简化路径</h3><ul><li>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘&#x2F;‘ 开头），请你将其转化为更加简洁的规范路径。</li><li>用栈模拟，先按’&#x2F;‘分割字符串，再考虑三种情况即”..”，”.”，””，注意最后要倒序输出</li><li>注意<font color='red'><b>stringstream用法</b></font>，getline(ss, tmp, ‘&#x2F;‘)，以’&#x2F;‘分割字符串，tmp为分割后的字符串，ss为输入流，”&#x2F;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">simplifyPath</span><span class="params">(string path)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; stk;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(path)</span></span>;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;/&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!tmp.<span class="built_in">empty</span>() &amp;&amp; tmp != <span class="string">&quot;.&quot;</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res = <span class="string">&quot;/&quot;</span> + stk.<span class="built_in">top</span>() + res;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;/&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155-最小栈"></a>155-最小栈</h3><ul><li>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</li><li>方法一：用两个栈模拟，一个正常栈，一个最小栈 O(1)&#x2F;O(n)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; min_stk;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">        min_stk.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(val);</span><br><span class="line">        min_stk.<span class="built_in">push</span>(<span class="built_in">min</span>(min_stk.<span class="built_in">top</span>(), val));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        min_stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：差值存储法 O(1)&#x2F;O(1)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">long</span>&gt; stk;  <span class="comment">// 存储与当前最小值的差值</span></span><br><span class="line">    <span class="type">long</span> min_val;     <span class="comment">// 当前最小值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(<span class="number">0L</span>);</span><br><span class="line">            min_val = val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> diff = val - min_val;</span><br><span class="line">            stk.<span class="built_in">push</span>(diff);</span><br><span class="line">            <span class="comment">// 更新最小值 (当新值更小时)</span></span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) min_val = val; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> diff = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 如果弹出的是最小值，需要还原前一个最小值</span></span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) min_val = min_val - diff; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> diff = stk.<span class="built_in">top</span>();</span><br><span class="line">        <span class="comment">// 根据差值类型返回实际值</span></span><br><span class="line">        <span class="keyword">return</span> diff &lt; <span class="number">0</span> ? min_val : min_val + diff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150-逆波兰表达式求值"></a>150-逆波兰表达式求值</h3><ul><li>给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。</li><li>注意isdigit()函数判断是否为数字，stoi()函数将string转int</li><li>注意token.size() &gt; 1的情况因为可能是两位数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; token : tokens) &#123;</span><br><span class="line">            <span class="comment">// 如果是数字，直接入栈</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(token[<span class="number">0</span>]) || token.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(<span class="built_in">stoi</span>(token));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">int</span> num2 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> num1 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">switch</span> (token[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">push</span>(num1 + num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">push</span>(num1 - num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">push</span>(num1 * num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                        stk.<span class="built_in">push</span>(num1 / num2);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224-基本计算器"></a>224-基本计算器</h3><ul><li>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</li><li>去括号法，用栈模拟，<font color='red'><b>注意符号栈的初始值为1，遇到’(‘时入栈保存符号状态，遇到’)’时出栈</b></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; ops;</span><br><span class="line">        ops.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                sign = ops.<span class="built_in">top</span>();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                sign = -ops.<span class="built_in">top</span>();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.<span class="built_in">push</span>(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                ops.<span class="built_in">pop</span>();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; <span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.区间</title>
      <link href="/posts/23e2398a.html"/>
      <url>/posts/23e2398a.html</url>
      
        <content type="html"><![CDATA[<h3 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228-汇总区间"></a>228-汇总区间</h3><ul><li>给定一个无重复元素的有序整数数组nums返回恰好覆盖数组中所有数字的最小有序区间范围列表</li><li>双指针：注意边界条件，<font color=red><b>to_string()函数转int成string</b></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">summaryRanges</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (right + <span class="number">1</span> &lt; n &amp;&amp; nums[right] + <span class="number">1</span> == nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                string s = <span class="built_in">to_string</span>(nums[left]);</span><br><span class="line">                <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                    s += <span class="string">&quot;-&gt;&quot;</span> + <span class="built_in">to_string</span>(nums[right]);</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(s);</span><br><span class="line">                right++;</span><br><span class="line">                left = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56-合并区间"></a>56-合并区间</h3><ul><li>给定一个区间的集合，合并所有重叠的区间</li><li>先排序，再遍历</li><li>注意可以直接排序二维数组（优先按第一个元素排序，若相同则比较第二个元素，以此类推），同时注意使用<font color=red><b>res.back()</b></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> left = intervals[i][<span class="number">0</span>], right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!res.<span class="built_in">size</span>() || res.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(res.<span class="built_in">back</span>()[<span class="number">1</span>], right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57-插入区间"></a>57-插入区间</h3><ul><li><p>给定一个无重叠的区间数组，插入一个新的区间，合并所有重叠的区间</p></li><li><p>方法一：先将新区间插入到数组中，再合并区间解法同上</p></li><li><p>方法二：模拟 O(n)&#x2F;O(1)</p></li><li><p>注意分三种情况考虑：</p><ul><li>新区间在当前区间的左侧且无交集，直接将当前区间加入结果集，再处理后续区间</li><li>新区间在当前区间的右侧且无交集，直接将当前区间加入结果集</li><li>新区间与当前区间有交集，需进行合并</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">insert</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals, vector&lt;<span class="type">int</span>&gt;&amp; newInterval) &#123;</span><br><span class="line">        <span class="type">int</span> left = newInterval[<span class="number">0</span>], right = newInterval[<span class="number">1</span>];</span><br><span class="line">        <span class="type">bool</span> placed = <span class="literal">false</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">                    placed = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt; left) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(intervals[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = <span class="built_in">min</span>(left, intervals[i][<span class="number">0</span>]);</span><br><span class="line">                right = <span class="built_in">max</span>(right, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!placed) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;left, right&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452-用最少数量的箭引爆气球"></a>452-用最少数量的箭引爆气球</h3><ul><li>给一组区间代表气球直径，找到需要最少的箭数，使这些区间都被引爆</li><li>排序 + 贪心</li><li>先按区间右端点排序，然后遍历区间，若当前区间的左端点大于上一个区间的右端点，则需要增加箭数，同时更新右端点（如果按左端点排序后续还需更新最小右端点值）</li><li>注意sort写法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (points.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), [](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; u, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; v)&#123;</span><br><span class="line">            <span class="keyword">return</span> u[<span class="number">1</span>] &lt; v[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, r = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; r) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                r = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.滑动窗口</title>
      <link href="/posts/54809807.html"/>
      <url>/posts/54809807.html</url>
      
        <content type="html"><![CDATA[<hr><ul><li>滑动窗口是一种双指针的方法，一般用于解决数组&#x2F;字符串的子元素问题，它可以将嵌套的循环问题，转换为单循环问题，降低时间复杂度</li><li>一般求某个数组内连续的子串是否等于某个值（如果是数组要注意是正数才行）&#x2F;由什么组成等问题都可以用滑动窗口</li></ul><hr><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209-长度最小的子数组"></a>209-长度最小的子数组</h3><ul><li>给定一个含有n个正整数的数组和一个正整数target，找出该数组中满足其和大于等于target的长度最小的连续子数组，并返回其长度</li><li>滑动窗口</li><li>注意此题中数组都是正整数所以可以滑动窗口，可以满足右边加左边减的条件，如果是560题中的数组是负数则不能用滑动窗口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="560-和为k的子数组"><a href="#560-和为k的子数组" class="headerlink" title="560-和为k的子数组"></a>560-和为k的子数组</h3><ul><li>给你一个整数数组nums和一个整数k，请你统计并返回该数组中和为k的连续子数组的个数</li><li>前缀和+哈希表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nums_map;</span><br><span class="line">        nums_map[<span class="number">0</span>] = <span class="number">1</span>;                        <span class="comment">// 注意这里要先加入0，否则会漏掉以0开头的子数组</span></span><br><span class="line">        <span class="type">int</span> pre_sum = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            pre_sum += num;</span><br><span class="line">            <span class="keyword">if</span> (nums_map.<span class="built_in">find</span>(pre_sum - k) != nums_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                cnt += nums_map[pre_sum - k];</span><br><span class="line">            &#125;</span><br><span class="line">            nums_map[pre_sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-最长无重复子串"><a href="#3-最长无重复子串" class="headerlink" title="3-最长无重复子串"></a>3-最长无重复子串</h3><ul><li>给定一个字符串s，请你找出其中不含有重复字符的最长子串的长度</li><li>方法一：滑动窗口（用unordered_set）注意里面一层也需要while保证和右边字符不重复</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; set;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 注意此处要用while保证和右边字符不重复</span></span><br><span class="line">            <span class="keyword">while</span> (set.<span class="built_in">count</span>(s[right])) &#123;</span><br><span class="line">                set.<span class="built_in">erase</span>(s[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">            set.<span class="built_in">insert</span>(s[right]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：滑动窗口（不用额外空间）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; s.<span class="built_in">size</span>(); ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] != s[r]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, r - l + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30-串联所有单词的子串"></a>30-串联所有单词的子串</h3><ul><li>给定一个字符串s和一个字符串数组words（其中字符串长度相同），找出s中所有是由words中每个单词串联形成的子串的起始位置</li><li>滑动窗口：注意先判断target.count(cur)再判断窗口</li><li>注意最外层的循环for (int offset &#x3D; 0; offset &lt; len; offset++)考虑所有可能情况的滑动窗口</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建目标单词频率字典，统计words中所有单词出现次数</span></span><br><span class="line"><span class="comment">// 2. 遍历所有可能的窗口起始偏移（0到单词长度-1），处理不同起始位置的滑动窗口</span></span><br><span class="line"><span class="comment">// 3. 扩展右边界：每次截取固定长度单词，若匹配目标则更新窗口计数，当计数匹配目标值时增加有效计数</span></span><br><span class="line"><span class="comment">// 4. 收缩左边界：当窗口包含的单词总数超过要求时，移除最左侧单词并调整计数</span></span><br><span class="line"><span class="comment">// 5. 当有效计数等于目标单词种类数时，记录当前窗口左边界位置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findSubstring</span><span class="params">(string s, vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = words.<span class="built_in">size</span>(), len = words[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; target;</span><br><span class="line">        <span class="comment">// 创建目标单词频率表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; w : words) target[w]++;</span><br><span class="line">        <span class="comment">// 遍历所有可能的起始偏移（0到len-1）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> offset = <span class="number">0</span>; offset &lt; len; offset++) &#123;</span><br><span class="line">            unordered_map&lt;string, <span class="type">int</span>&gt; window;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 有效单词计数</span></span><br><span class="line">            <span class="comment">// 滑动窗口 [left, right)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> left = offset, right = offset; right &lt;= n - len; right += len) &#123;</span><br><span class="line">                string cur = s.<span class="built_in">substr</span>(right, len);</span><br><span class="line">                <span class="keyword">if</span> (target.<span class="built_in">count</span>(cur)) &#123;</span><br><span class="line">                    <span class="comment">// 此处先加再判断</span></span><br><span class="line">                    window[cur]++;</span><br><span class="line">                    <span class="keyword">if</span> (window[cur] == target[cur]) count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (right - left + len &gt; m * len) &#123;</span><br><span class="line">                    string del = s.<span class="built_in">substr</span>(left, len);</span><br><span class="line">                    <span class="keyword">if</span> (target.<span class="built_in">count</span>(del)) &#123;</span><br><span class="line">                        <span class="comment">// 此处先判断再减</span></span><br><span class="line">                        <span class="keyword">if</span> (window[del] == target[del]) count--;</span><br><span class="line">                        window[del]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left += len;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count == target.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76-最小覆盖子串"></a>76-最小覆盖子串</h3><ul><li>给你一个字符串s，一个字符串t，返回s中涵盖t所有字符的最小子串</li><li>滑动窗口，注意target[cur]没有值的话会创建一个新的键值对所以需要用target.count(cur)来判断</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 首先对t中字符串用字典统计字符个数</span></span><br><span class="line"><span class="comment">// 2. 然后用滑动窗口对s进行遍历，用字典统计窗口内字符个数</span></span><br><span class="line"><span class="comment">// 3. 当窗口内字符个数等于t中字符个数时，说明此时子串包含了t所有字符</span></span><br><span class="line"><span class="comment">// 4. 然后移动左指针，缩小窗口，计算最小子串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min_len = INT_MAX, start = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window, target;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : t) target[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> cur = s[r];</span><br><span class="line">            <span class="keyword">if</span> (target.<span class="built_in">count</span>(cur)) &#123;</span><br><span class="line">                window[cur]++;</span><br><span class="line">                <span class="keyword">if</span> (window[cur] == target[cur]) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (cnt == target.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (len &lt; min_len) &#123;</span><br><span class="line">                    min_len = len;</span><br><span class="line">                    start = l;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">char</span> del = s[l];</span><br><span class="line">                <span class="keyword">if</span> (target.<span class="built_in">count</span>(del)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window[del] == target[del]) cnt--;</span><br><span class="line">                    window[del]--;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min_len == INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, min_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239-滑动窗口最大值"></a>239-滑动窗口最大值</h3><ul><li>给你一个整数数组nums，有一个大小为k的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的k个数字。滑动窗口每次只向右移动一位，求滑动窗口中的最大值</li><li>双端队列中存储的是窗口中的元素，且窗口中的元素从大到小排列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 未初始化窗口时逐渐扩展右边界，加入的元素要保证队列中没有比其小的元素，队尾始终是最大元素</span></span><br><span class="line"><span class="comment">// 2，初始化窗口后需要收缩左边界，首先判断左边界移除的元素是否是队尾元素，如果是则需要移除队尾元素</span></span><br><span class="line"><span class="comment">// 3. 然后扩展右边界，同样加入的元素要保证队列中没有比其小的元素，队尾始终是最大元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n - k + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; deque_nums;</span><br><span class="line">        <span class="comment">// 初始化窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque_nums.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; deque_nums.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                deque_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            deque_nums.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[<span class="number">0</span>] = deque_nums.<span class="built_in">front</span>();</span><br><span class="line">        <span class="comment">// 已初始化窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = k; r &lt; n; ++l, ++r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l - <span class="number">1</span>] == deque_nums.<span class="built_in">front</span>()) deque_nums.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">if</span> (nums[r] &gt; deque_nums.<span class="built_in">front</span>()) deque_nums.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">while</span> (!deque_nums.<span class="built_in">empty</span>() &amp;&amp; nums[r] &gt; deque_nums.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                deque_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            deque_nums.<span class="built_in">push_back</span>(nums[r]);</span><br><span class="line">            res[l] = deque_nums.<span class="built_in">front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438-找到字符串中所有字母异位词"></a>438-找到字符串中所有字母异位词</h3><ul><li>给定两个字符串s和p，找到s中所有是p的字母异位词的子串，返回这些子串的起始索引</li><li>优化版滑动窗口（时间复杂度O(n)最优实现），统计diff（太妙了）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; p.<span class="built_in">size</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> diff = <span class="number">0</span>; <span class="comment">// 差异计数器</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化目标频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : p) count[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="comment">// 初始化滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i++) count[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="comment">// 计算初始差异</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v : count) <span class="keyword">if</span> (v != <span class="number">0</span>) diff++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 滑动固定长度窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>, r = p.<span class="built_in">size</span>(); r &lt;= s.<span class="built_in">size</span>(); l++, r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (diff == <span class="number">0</span>) res.<span class="built_in">push_back</span>(l);</span><br><span class="line">            <span class="keyword">if</span> (r == s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 移除左边界字符</span></span><br><span class="line">            <span class="type">int</span> left = s[l] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (count[left] == <span class="number">1</span>) diff--;    <span class="comment">// 从差异变为0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count[left] == <span class="number">0</span>) diff++;<span class="comment">// 从0变为差异</span></span><br><span class="line">            count[left]--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 添加右边界字符</span></span><br><span class="line">            <span class="type">int</span> right = s[r] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (count[right] == <span class="number">-1</span>) diff--;  <span class="comment">// 从差异变为0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count[right] == <span class="number">0</span>) diff++;<span class="comment">// 从0变为差异</span></span><br><span class="line">            count[right]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.双指针</title>
      <link href="/posts/fc355fed.html"/>
      <url>/posts/fc355fed.html</url>
      
        <content type="html"><![CDATA[<h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125-验证回文串"></a>125-验证回文串</h3><ul><li>将字符串符号数字全去掉然后变为小写判断是否是回文串</li><li>注意<font color=red><b>isalnum()判断字符是否是字母或数字</b></font></li><li>方法一：双指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[left])) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !<span class="built_in">isalnum</span>(s[right])) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[left]) != <span class="built_in">tolower</span>(s[right])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：反转字符串</li><li>注意<font color=red><b>string.rbegin()和string.rend()</b></font>函数进行字符串反转</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string sgood;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch: s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isalnum</span>(ch)) &#123;</span><br><span class="line">                sgood += <span class="built_in">tolower</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">string <span class="title">sgood_rev</span><span class="params">(sgood.rbegin(), sgood.rend())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> sgood == sgood_rev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392-判断子序列"></a>392-判断子序列</h3><ul><li>给定字符串s和t，判断s是否为t的子序列</li><li>双指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>(), m = t.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167-两数之和 II - 输入有序数组"></a>167-两数之和 II - 输入有序数组</h3><ul><li>给定一个已按照升序排列的整数数组numbers，找到两个数使得它们相加之和等于目标数target返回下标（从1开始）</li><li>方法一：双指针（注意已经升序）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> sum = numbers[left] + numbers[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：二分查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> low = i + <span class="number">1</span>, high = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">                <span class="keyword">if</span> (numbers[mid] == target - numbers[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i + <span class="number">1</span>, mid + <span class="number">1</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; target - numbers[i]) &#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11-盛最多水的容器"></a>11-盛最多水的容器</h3><ul><li>给定一个长度为n的整数数组height，有n条垂线，第i条线的两个端点是(i,0)和(i,height[i])，找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水，返回最大水量</li><li>双指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> area = <span class="built_in">min</span>(height[left], height[right]) * (right - left);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, area);</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15-三数之和"></a>15-三数之和</h3><ul><li>给定一个包含n个整数的数组nums，判断nums中是否存在三个元素a,b,c，使得a+b+c&#x3D;0，找出所有满足条件且不重复的三元组</li><li>排序+双指针：注意判断和上一次枚举不同的写法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 先排序</span></span><br><span class="line"><span class="comment">// 2. 最左边定住a，最右边定住c，然后在中间不断找c满足和为0的b（需要去重），找的时候如果大了c就--</span></span><br><span class="line"><span class="comment">// 3. 然后a++，重复2（c需要重新到最右边）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="comment">// 枚举a</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> first = <span class="number">0</span>; first &lt; n; ++first) &#123;</span><br><span class="line">            <span class="comment">// 注意此处判断和上一次枚举的数不相同</span></span><br><span class="line">            <span class="keyword">if</span> (first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> target = -nums[first];</span><br><span class="line">            <span class="comment">// 枚举b</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> second = first + <span class="number">1</span>; second &lt; n; ++second) &#123;</span><br><span class="line">                <span class="keyword">if</span> (second &gt; first + <span class="number">1</span> &amp;&amp; nums[second] == nums[second - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (second &lt; third &amp;&amp; nums[second] + nums[third] &gt; target) &#123;</span><br><span class="line">                    --third;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 注意此处重合判断</span></span><br><span class="line">                <span class="keyword">if</span> (second == third) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[second] + nums[third] == target) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试总结</title>
      <link href="/posts/27a6e4df.html"/>
      <url>/posts/27a6e4df.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Lua相关"><a href="#1-Lua相关" class="headerlink" title="1. Lua相关"></a>1. Lua相关</h3><h4 id="在-Lua-中优化-table-存储大规模数据的方法有："><a href="#在-Lua-中优化-table-存储大规模数据的方法有：" class="headerlink" title="在 Lua 中优化 table 存储大规模数据的方法有："></a>在 Lua 中优化 table 存储大规模数据的方法有：</h4><ol><li><strong>使用数组</strong>：Lua 的 table 在作为数组（顺序索引）时性能更高，尽量使用数字索引来存储数据，而不是字符串键。</li><li><strong>预分配大小</strong>：在 LuaJIT 中，通过预先分配 table 大小，减少动态扩展的开销，比如在创建 table 时就指定足够的初始容量。</li><li><strong>利用轻量化的数据结构</strong>：将大数据分块存储在多个小 table 中，可以有效减少单个 table 的压力。</li></ol><h4 id="G表概念："><a href="#G表概念：" class="headerlink" title="_G表概念："></a>_G表概念：</h4><ol><li><strong>全局变量</strong>：在 Lua 中直接赋值的变量默认都是全局的。例如 <code>a = 10</code> 就会创建一个全局变量 <code>a</code>，并可以在整个程序中访问。</li><li><strong>_G 表</strong>：Lua 将所有全局变量存储在一个特殊的全局表 <code>_G</code> 中。可以通过 <code>_G</code> 表来访问、遍历所有全局变量。例如 <code>_G[&quot;a&quot;]</code> 就是变量 <code>a</code> 的值。</li><li><strong>注意事项</strong>：<ul><li>全局变量过多会影响性能，特别是在需要频繁访问的场景下。</li><li>未定义的全局变量默认为 <code>nil</code>，容易引发意外错误。因此，通常用 <code>local</code> 来声明局部变量以减少全局污染。</li></ul></li><li><strong>优化</strong>：可以通过设置元表来控制 <code>_G</code>，避免错误的全局变量访问，或限制不必要的全局变量创建。</li></ol><h4 id="如果-Lua-中的全局变量过多，可以通过以下方法优化："><a href="#如果-Lua-中的全局变量过多，可以通过以下方法优化：" class="headerlink" title="如果 Lua 中的全局变量过多，可以通过以下方法优化："></a>如果 Lua 中的全局变量过多，可以通过以下方法优化：</h4><ol><li><strong>使用局部变量</strong>：局部变量的访问速度比全局变量快很多，尽量将函数内部的变量定义为 <code>local</code>，减少对全局表 <code>_G</code> 的依赖。</li><li><strong>模块化</strong>：将功能相关的全局变量封装进模块，减少直接在 <code>_G</code> 表中的变量数量。可以通过 <code>require</code> 加载模块，将全局变量转化为模块变量。</li><li><strong>避免动态创建全局变量</strong>：防止在运行时动态生成全局变量，尤其是在循环或递归中，防止内存占用增加。</li><li><strong>元表限制</strong>：可以为 <code>_G</code> 表设置元表来捕获不正确的全局变量访问。例如，通过元表设置可以禁止未定义的全局变量创建或访问。</li></ol><h4 id="G表的优势"><a href="#G表的优势" class="headerlink" title="_G表的优势"></a>_G表的优势</h4><ol><li><strong>灵活性</strong>：Lua 的 <code>_G</code> 表允许动态访问和操作全局变量，开发者可以通过 <code>_G[&quot;变量名&quot;]</code> 动态获取或设置变量值。这在很多动态脚本中提供了灵活性，允许通过字符串等动态方式访问变量。</li><li><strong>内存控制</strong>：与 C++ 或 C# 的全局变量相比，Lua 中的 <code>_G</code> 表相当于一个管理所有全局变量的容器，可以通过元表对其进行控制。这样，开发者可以使用元表来限制不必要的全局变量访问。</li><li><strong>轻量级和性能优化</strong>：Lua 本身设计简洁，没有复杂的全局变量管理机制，减少了全局变量的内存消耗。同时，通过模块化和局部变量的使用，可以有效减少对 <code>_G</code> 表的访问需求。</li></ol><h4 id="脚本语言实现原理"><a href="#脚本语言实现原理" class="headerlink" title="脚本语言实现原理"></a>脚本语言实现原理</h4><p>脚本语言通过解释器将源代码逐行解析并执行，无需编译即可运行。解释器负责将脚本代码转换为机器指令，逐步执行，使脚本语言具有动态和跨平台特性，适合快速开发和嵌入应用程序中。</p><h4 id="Lua-实现类和对象"><a href="#Lua-实现类和对象" class="headerlink" title="Lua 实现类和对象"></a>Lua 实现类和对象</h4><p>Lua 中可以用表（table）和元表（metatable）来模拟类和对象，通过设置元表的 <code>__index</code> 方法来实现继承和方法查找。这样可以将类的方法和属性组织在表中，并动态创建对象。</p><h4 id="Lua-和-C-交互"><a href="#Lua-和-C-交互" class="headerlink" title="Lua 和 C++ 交互"></a>Lua 和 C++ 交互</h4><ol><li><p>Lua 调用 C++ 的过程</p><ul><li><strong>流程</strong>：<code>Lua -&gt; Wrapper -&gt; C++</code></li><li><strong>实现</strong>：C++ 编写一个 <strong>Wrapper</strong> 文件，将 C++ 函数、类和对象包装并注册到 Lua 虚拟机中（通常通过 <code>luaL_register</code> 函数注册）。注册完成后，Lua 可以通过该 Wrapper 文件调用 C++ 函数。</li></ul></li><li><p>C++ 调用 Lua 的过程</p><ul><li><strong>流程</strong>：<code>C++ -&gt; Lua C API -&gt; Lua</code></li><li><strong>实现</strong>：C++ 通过 Lua C API 调用 Lua 脚本中的函数和变量。常见操作包括加载 Lua 脚本、设置全局变量、获取返回值等。</li></ul></li><li><p>内存和数据管理</p><ul><li><strong>栈结构交互</strong>：C++ 和 Lua 通过一个<strong>共享栈</strong>交换数据。C++ 调用 Lua 函数时，将参数和结果都放在栈中。比如，C++ 将参数压栈，然后调用 Lua 函数，Lua 处理并将结果压入栈顶，C++ 最后从栈顶取回结果。</li></ul></li></ol><h4 id="C-实现热更新"><a href="#C-实现热更新" class="headerlink" title="C++ 实现热更新"></a>C++ 实现热更新</h4><p>C++ 中可以通过将代码模块化为动态链接库（DLL）实现热更新。当需要更新时，重新编译 DLL 并在运行时加载新版本，避免重启应用程序，从而实现代码的无缝更新。</p><h4 id="C-指针在-Lua-中的数据结构"><a href="#C-指针在-Lua-中的数据结构" class="headerlink" title="C++ 指针在 Lua 中的数据结构"></a>C++ 指针在 Lua 中的数据结构</h4><p>C++ 指针在 Lua 中通常作为<strong>轻用户数据（light userdata）</strong>，它只占用一个内存地址，适合存储简单指针，并可用于 Lua 与 C++ 间的数据交互，不带有元表等额外信息。</p><h4 id="Lua-与-C-交互"><a href="#Lua-与-C-交互" class="headerlink" title="Lua 与 C# 交互"></a>Lua 与 C# 交互</h4><ol><li>Lua 调用 C# 的过程<ul><li><strong>流程</strong>：<code>Lua -&gt; Wrap -&gt; C#</code></li><li><strong>实现</strong>：xLua 生成 Wrap 文件（中间&#x2F;适配文件），将 C# 类、字段和方法注册到 Lua 虚拟机（如 LuaJIT）。Lua 脚本可以通过 Wrap 文件访问 C# 功能；另外，还可以在 config 文件中添加相关类型，使其自动生成 Wrap 文件。</li></ul></li><li>C# 调用 Lua 的过程<ul><li><strong>流程</strong>：<code>C# -&gt; Bridge -&gt; dll -&gt; Lua</code> 或 <code>C# -&gt; dll -&gt; Lua</code></li><li><strong>实现</strong>：C# 通过生成的 Bridge 文件调用 Lua 的 dll 文件（该 dll 文件是由 C 语言编写的库）。C# 代码可以直接或通过 Bridge 间接调用 Lua 虚拟机，执行 Lua 脚本。</li></ul></li><li>内存交互<ul><li><strong>C# Call Lua</strong>：C# 将请求或数据压入栈顶，Lua 从栈顶读取数据进行处理，处理完后将结果放回栈顶，C# 再从栈顶获取数据完成交互。这种基于栈的数据交换机制实现了 Lua 和 C# 的双向数据传递。</li></ul></li><li>Wrap 文件是 C# 类型的包装文件，用于将 C# 类、方法和字段暴露给 Lua 使用。Wrap 文件通过 xLua 的自动生成机制，将 C# 类的方法和属性封装并注册到 Lua 虚拟机中，使得 Lua 脚本能够直接调用 C# 方法或访问 C# 属性。Wrap 文件的主要功能是为 Lua 提供一个接口，让 Lua 可以调用特定的 C# 类或方法。</li><li>Bridge 文件是 桥接文件，用于 C# 调用 Lua。它通过与 xLua 提供的底层 C&#x2F;C++ 库（dll 文件）交互，将 C# 请求传递给 Lua 虚拟机。Bridge 文件可以将 C# 中的操作转化为 Lua 的 API 调用，从而在 C# 中实现 Lua 脚本的执行。</li></ol><h3 id="2-网络相关"><a href="#2-网络相关" class="headerlink" title="2. 网络相关"></a>2. 网络相关</h3><h4 id="TCP-和-UDP-原理"><a href="#TCP-和-UDP-原理" class="headerlink" title="TCP 和 UDP 原理"></a>TCP 和 UDP 原理</h4><ul><li>TCP 是一种可靠的、面向连接的协议，而 UDP 是不可靠的、无连接的协议。TCP 的首部长度最小为 20 字节，而 UDP 的首部只有 8 字节。TCP 只支持一对一的通信，而 UDP 支持一对一、一对多、多对一和多对多的通信模式。TCP 提供确认、重传、流量控制和拥塞控制等功能，而 UDP 则不具备这些功能。</li></ul><ol><li><strong>TCP（Transmission Control Protocol，传输控制协议）</strong>：<ul><li>是面向连接的协议，提供可靠的、顺序的数据传输。</li><li>建立连接时通过三次握手保证连接的可靠性，传输过程中对数据包进行校验、排序、重传，确保数据完整。</li><li>适合需要高可靠性的场景，但由于建立连接和确认机制，速度比 UDP 慢。</li></ul></li><li><strong>UDP（User Datagram Protocol，用户数据报协议）</strong>：<ul><li>是无连接的协议，发送数据包时不需要建立连接。</li><li>速度快，但不保证数据的可靠传输，数据可能丢失或顺序混乱。</li><li>适合对速度要求高且可以容忍一定数据丢失的场景。</li></ul></li></ol><h4 id="游戏中-TCP-和-UDP-的应用"><a href="#游戏中-TCP-和-UDP-的应用" class="headerlink" title="游戏中 TCP 和 UDP 的应用"></a>游戏中 TCP 和 UDP 的应用</h4><ol><li><strong>TCP 应用</strong>：<ul><li><strong>登录认证</strong>：玩家登录游戏时的账号验证、安全信息传输需要使用 TCP 确保数据完整和安全。</li><li><strong>聊天系统</strong>：游戏中的聊天信息对可靠性要求高，使用 TCP 能确保消息完整送达。</li></ul></li><li><strong>UDP 应用</strong>：<ul><li><strong>实时游戏状态更新</strong>：玩家位置、动作等数据更新速度要求高，适合使用 UDP，少量数据丢失不会对游戏体验有太大影响。</li><li><strong>音视频传输</strong>：在实时语音或视频的情况下使用 UDP，可以减少延迟，提高实时性。</li></ul></li></ol><h4 id="如何用UDP来实现TCP"><a href="#如何用UDP来实现TCP" class="headerlink" title="如何用UDP来实现TCP"></a>如何用UDP来实现TCP</h4><ol><li><strong>建立连接（模拟三次握手）</strong><ul><li>虽然 UDP 没有连接，但可以通过在客户端发送连接请求，并等待服务端回应的方式模拟连接建立。</li><li>服务端在接收到请求后，返回确认信息，客户端收到确认后正式开始传输数据，模拟了三次握手的过程。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 客户端 <span class="comment">--&gt; 服务器：SYN（seq=x）</span></span><br><span class="line"><span class="number">2.</span> 客户端 &lt;<span class="comment">-- 服务器：SYN + ACK（seq=y, ack=x+1）</span></span><br><span class="line"><span class="number">3.</span> 客户端 <span class="comment">--&gt; 服务器：ACK（ack=y+1）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>数据包编号</strong><ul><li>为每个数据包分配一个唯一的序号（Sequence Number），使接收端能够识别数据包的顺序。</li><li>通过包编号，接收端可以重排数据包，确保数据按顺序处理。</li></ul></li><li><strong>确认应答（ACK）</strong><ul><li>在发送数据包后，接收端需要向发送端发送一个确认包（ACK），确认接收到的数据包。</li><li>如果发送端在一定时间内没有收到 ACK，重新发送该数据包，确保数据可靠传输。</li></ul></li><li><strong>超时重传</strong><ul><li>发送端在发送数据包后设置超时时间，等待 ACK。如果超时未收到 ACK，则重传数据包，直到确认收到为止。</li><li>通过超时和重传机制，可以弥补 UDP 本身的丢包问题，提升可靠性。</li></ul></li><li><strong>滑动窗口</strong><ul><li>为了提高传输效率，可以在发送端实现滑动窗口机制，即在等待 ACK 期间继续发送多个数据包。</li><li>接收端也根据窗口大小进行处理，按序接收数据包，未按序的包则缓存，等待前面的数据到达后再处理。</li></ul></li><li><strong>断开连接（模拟四次挥手）</strong><ul><li>模拟 TCP 的断开过程，客户端向服务端发送断开请求，服务端确认后，释放资源，结束会话。</li><li>确保双方都能确认断开连接，防止数据未完全接收时断开连接。<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 客户端 <span class="comment">--&gt; 服务器：FIN（seq=u）</span></span><br><span class="line"><span class="number">2.</span> 客户端 &lt;<span class="comment">-- 服务器：ACK（ack=u+1）</span></span><br><span class="line"><span class="number">3.</span> 客户端 &lt;<span class="comment">-- 服务器：FIN（seq=v）</span></span><br><span class="line"><span class="number">4.</span> 客户端 <span class="comment">--&gt; 服务器：ACK（ack=v+1）</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>为什么三次握手需要三次，而挥手需要四次？<ul><li>三次握手：建立连接时，客户端和服务器都需要确认自己和对方的发送和接收能力。因此，三次握手可以确保双方都已经准备好通信。三次握手通过同步的序列号来完成双向的确认。</li><li>四次挥手：关闭连接时，TCP 是全双工通信，因此两端的关闭是独立进行的。客户端发送 FIN 仅表示它不再发送数据了，而服务器可能还有数据要发送。因此，双方的关闭需要分别确认，形成四次挥手。</li></ul></li></ul><h4 id="简述状态同步"><a href="#简述状态同步" class="headerlink" title="简述状态同步"></a>简述状态同步</h4><p>状态同步是一种将游戏对象的完整状态同步给所有玩家的同步方式：</p><ol><li><strong>原理</strong>：服务端负责计算游戏中每个对象的状态（位置、速度、方向等），并将这些状态广播给所有客户端。客户端直接更新到接收到的最新状态。</li><li><strong>优点</strong>：<ul><li><strong>实现简单</strong>：客户端只需接收和应用最新的状态，不需要复杂的逻辑。</li><li><strong>抗干扰强</strong>：即使丢包或延迟，客户端会收到后续的状态更新，迅速恢复。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>带宽需求高</strong>：需要频繁传输对象的完整状态，尤其在游戏对象较多时对带宽要求较高。</li><li><strong>体验延迟</strong>：每次接收到服务器的更新时才进行状态刷新，容易造成延迟感。</li></ul></li><li><strong>应用场景</strong>：多用于射击类、角色扮演等对精确性要求高的游戏。</li></ol><h4 id="简述帧同步"><a href="#简述帧同步" class="headerlink" title="简述帧同步"></a>简述帧同步</h4><p>帧同步是一种将玩家的输入操作同步给所有客户端的同步方式：</p><ol><li><strong>原理</strong>：客户端仅上传玩家的输入（按键、操作指令等），服务端接收后同步这些输入给所有客户端。客户端在接收到输入后独立计算并更新游戏状态，确保帧步相同。</li><li><strong>优点</strong>：<ul><li><strong>带宽低</strong>：只需传输输入数据，比状态同步的带宽占用小。</li><li><strong>一致性好</strong>：所有客户端同时运行相同逻辑，状态高度一致，适合竞技游戏。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>抗干扰差</strong>：若丢包或延迟导致输入不同步，客户端之间的状态会发生分歧。</li><li><strong>实现复杂</strong>：客户端需要确保每一帧的逻辑完全一致，否则会导致不同步问题。</li></ul></li><li><strong>应用场景</strong>：常用于格斗、RTS 等要求高度同步和公平性的竞技类游戏。</li></ol><h4 id="优化帧同步延迟策略"><a href="#优化帧同步延迟策略" class="headerlink" title="优化帧同步延迟策略"></a>优化帧同步延迟策略</h4><ol><li><strong>预测与回滚</strong><ul><li><strong>输入预测</strong>：客户端在等待服务端同步的输入时，先假设其他玩家保持当前状态，提前进行操作预测。例如，在延迟较低的情况下预测玩家移动方向不变，减少视觉延迟。</li><li><strong>状态回滚</strong>：如果服务端输入到达后发现预测错误，回滚到之前的状态，重新应用正确的输入。这样保证了同步的一致性。</li></ul></li><li><strong>帧补偿</strong><ul><li><strong>快进帧数</strong>：在高延迟情况下，客户端可以增加执行帧速（例如，每帧处理多个输入），逐渐追赶上服务端的同步帧，避免同步滞后。</li><li><strong>动态帧率调整</strong>：根据当前延迟动态调整帧率，降低高延迟时的数据更新频率，以平滑游戏体验。</li></ul></li><li><strong>压缩输入数据</strong><ul><li><strong>数据精简</strong>：优化输入包的内容，尽量精简每次传输的数据（例如只传输按键变化），减小传输的数据量，降低延迟。</li><li><strong>封包合并</strong>：合并连续的输入数据，一起发送到服务端或客户端，减少单独包传输的频率。</li></ul></li></ol><h4 id="帧同步如何保证数据传输正确"><a href="#帧同步如何保证数据传输正确" class="headerlink" title="帧同步如何保证数据传输正确"></a>帧同步如何保证数据传输正确</h4><ol><li><strong>帧编号</strong><ul><li><strong>唯一标识帧</strong>：给每一帧分配唯一的帧编号，确保所有客户端和服务端的帧都能按顺序对齐。</li><li><strong>丢包重传</strong>：如果某一帧的输入数据丢失，客户端或服务端可以请求重传对应帧的数据，以确保没有帧缺失。</li></ul></li><li><strong>校验和</strong><ul><li><strong>数据校验</strong>：通过计算每帧的校验和（如 CRC32、MD5 等），确保传输数据完整性。每次接收数据时，对比校验值可以快速检测数据是否损坏或丢失。</li><li><strong>状态一致性检查</strong>：客户端可以定期发送关键帧的状态校验和到服务端，对比后检查是否存在不同步问题。若不同步，可以请求同步最新状态。</li></ul></li><li><strong>确认应答机制</strong><ul><li><strong>ACK 确认</strong>：每次发送输入后，接收方需要返回 ACK 确认包，告知已收到该帧的数据。</li><li><strong>重传机制</strong>：如果在设定的超时时间内未收到 ACK，则重新发送该帧数据。可以通过递增的超时时间来控制重传频率，避免过多带宽消耗。</li></ul></li><li><strong>滞后检测与回滚机制</strong><ul><li><strong>输入回滚</strong>：一旦检测到错误的输入或顺序不一致，客户端可以回滚到上一正确帧，重新执行未完成的输入，确保帧逻辑的一致性。</li><li><strong>滞后检测</strong>：若客户端检测到帧滞后（如帧编号不连续），可以暂停当前操作，等待服务端或其他客户端的正确输入。</li></ul></li></ol><h4 id="帧同步客户端数据不一致怎么办"><a href="#帧同步客户端数据不一致怎么办" class="headerlink" title="帧同步客户端数据不一致怎么办"></a>帧同步客户端数据不一致怎么办</h4><p>在帧同步中，若客户端出现不一致，可能导致不同步的问题，这通常由于网络延迟、数据包丢失或浮点数精度差异引起。为解决此问题，可以使用固定帧步长、状态校验、断线重连及服务器回滚等机制，确保各客户端能同步恢复一致状态，并尽量减少误差的累积。</p><h4 id="客户端帧率不同导致的不一致怎么办"><a href="#客户端帧率不同导致的不一致怎么办" class="headerlink" title="客户端帧率不同导致的不一致怎么办"></a>客户端帧率不同导致的不一致怎么办</h4><p>为避免客户端帧率不同导致的不一致问题，可以采用<strong>逻辑帧和渲染帧分离</strong>的方式，强制所有客户端在相同的固定逻辑帧率下运行游戏逻辑，将渲染帧率独立出来。这样，即便不同设备的渲染帧率不同，游戏逻辑依然在相同的逻辑帧率下同步执行，从而保证一致性。</p><h4 id="简述RPC调用原理"><a href="#简述RPC调用原理" class="headerlink" title="简述RPC调用原理"></a>简述RPC调用原理</h4><ul><li>RPC 概念<br>RPC（Remote Procedure Call，远程过程调用）是一种通信协议，允许程序在不同的计算机或进程之间调用方法，就像在本地调用方法一样。通过 RPC，开发者可以跨越网络边界，在分布式系统中简化通信和数据传输。</li><li>RPC 的调用主要分为以下几个步骤：<ol><li><strong>客户端调用本地代理（Stub）</strong>：<ul><li>客户端通过一个本地代理（Stub）发起调用请求，这个代理与远程服务的接口一致，看起来像是本地方法调用。</li></ul></li><li><strong>序列化请求数据</strong>：<ul><li>客户端代理将方法名称、参数等请求数据打包，并进行序列化（例如 JSON、XML 或 Protocol Buffers），使数据可以通过网络传输。</li></ul></li><li><strong>请求发送到服务端</strong>：<ul><li>序列化后的数据通过网络发送到服务端的代理（通常是远程的另一台机器）。</li></ul></li><li><strong>服务端解包与调用方法</strong>：<ul><li>服务端代理接收到数据后，进行反序列化，解析出方法名和参数，然后调用服务端的实际方法。</li></ul></li><li><strong>返回结果</strong>：<ul><li>服务端执行方法后，将结果打包并序列化为响应数据，传回客户端。</li></ul></li><li><strong>客户端处理返回数据</strong>：<ul><li>客户端代理接收到响应数据后，进行反序列化，并将结果返回给调用方，完成远程调用。</li></ul></li></ol></li><li>RPC 优势与应用<ul><li><strong>简化通信</strong>：通过隐藏底层网络通信细节，使得远程调用如同本地调用，提升开发效率。</li><li><strong>应用场景</strong>：多用于微服务架构、分布式系统中模块间的通信，例如服务注册、数据传输和分布式计算等。</li></ul></li></ul><h4 id="粘包与拆包"><a href="#粘包与拆包" class="headerlink" title="粘包与拆包"></a>粘包与拆包</h4><ul><li>粘包和拆包是网络通信中TCP协议常见的问题。</li><li>粘包是指多个数据包被合并传输，通常因为发送方发送数据过快，接收方缓冲区一次接收到多个包，或操作系统合并小包以提高传输效率。</li><li>拆包多由于数据包过大，超出传输协议规定的最大传输单元（MTU）或接收缓冲区的限制。</li><li>为解决这些问题，可以在每个数据包前添加包长度字段，使用分隔符协议，或在应用层协议中定义数据包边界，从而确保接收方能正确识别数据包的起始和结束位置。</li></ul><h3 id="3-Unity相关"><a href="#3-Unity相关" class="headerlink" title="3. Unity相关"></a>3. Unity相关</h3><h4 id="简述一下Unity中的ECS架构"><a href="#简述一下Unity中的ECS架构" class="headerlink" title="简述一下Unity中的ECS架构"></a>简述一下Unity中的ECS架构</h4><ul><li>Unity 的 ECS（Entity Component System）架构是一种高效的架构模式，专注于数据驱动和性能优化，特别适合需要高并发和大量数据处理的场景，如大型游戏或模拟系统。ECS 架构的核心概念：<ol><li><strong>Entity（实体）</strong>：<ul><li>Entity 是游戏对象的标识符，可以理解为“空容器”或“ID”，不包含具体数据。每个实体可以附加多个组件来描述其属性和行为。</li></ul></li><li><strong>Component（组件）</strong>：<ul><li>组件是数据的载体，不包含逻辑代码。它仅存储描述实体的属性，如位置、速度、颜色等。通过附加不同的组件，可以灵活定义实体的属性。</li><li>每种组件只存储一个方面的数据，遵循数据分离的思想。比如 <code>Position</code> 组件只存储位置数据，<code>Health</code> 组件只存储生命值。</li></ul></li><li><strong>System（系统）</strong>：<ul><li>系统包含逻辑代码，负责处理特定类型的组件数据。系统根据特定条件或组件集合进行更新，如移动系统处理所有具有 <code>Position</code> 和 <code>Velocity</code> 组件的实体，渲染系统负责所有有 <code>Mesh</code> 和 <code>Material</code> 组件的实体。</li><li>系统不直接访问实体，只处理其关联的组件数据，从而实现并行化和高效的缓存利用。</li></ul></li></ol></li><li>ECS 的优势<ol><li><strong>性能优化</strong>：ECS 的数据存储是基于内存局部性的。通过将相似的组件数据存储在连续的内存中，可以提高 CPU 缓存命中率，提升处理速度。</li><li><strong>可并行化</strong>：ECS 将逻辑和数据分离，多个系统可以并行操作，不同系统独立处理不同的组件组合，适合多线程优化。</li><li><strong>灵活扩展</strong>：组件和系统解耦，实体可以动态添加或移除组件，便于灵活定义实体行为和属性。</li></ol></li><li>Unity 的 ECS 应用场景<br>Unity 的 ECS 在需要高并发处理和优化 CPU 性能的场景下非常有效，比如粒子系统、大量 NPC、复杂的物理模拟等。</li></ul><h4 id="Unity不同动画之间怎么做平滑"><a href="#Unity不同动画之间怎么做平滑" class="headerlink" title="Unity不同动画之间怎么做平滑"></a>Unity不同动画之间怎么做平滑</h4><ol><li><strong>Animator Controller 的混合树（Blend Tree）</strong><ul><li><strong>混合树</strong>：Unity 的 Animator Controller 支持 Blend Tree，可以根据参数动态控制多个动画之间的平滑过渡。例如，移动和跑步动画可以放在同一个 Blend Tree 中，根据速度参数自动在两者之间平滑过渡。</li><li><strong>参数控制</strong>：通过设置控制参数（如速度、方向等）来控制动画权重，从而实现不同状态间的无缝过渡。</li></ul></li><li><strong>过渡（Transitions）</strong><ul><li>在 Animator Controller 中，两个动画之间可以设置 Transition，定义过渡的条件和过渡时间。</li><li><strong>过渡时间</strong>：通过调整过渡时间（Transition Duration）可以控制从一个动画状态切换到另一个动画状态的平滑程度。过渡时间越长，切换越平滑。</li><li><strong>淡入淡出</strong>：Transition 支持设置淡入淡出曲线，允许不同动画的权重逐渐变化，实现平滑的视觉效果。</li></ul></li><li><strong>层级权重控制（Layer Weight）</strong><ul><li>Unity 的 Animator 支持多层级动画，可以在不同的 Layer 上放置不同的动画，比如一个基础的行走动画和一个上半身的攻击动画。</li><li>通过调整 Layer 的权重（Layer Weight），可以实现动画的混合。例如，在跑步时也可以让上半身执行挥剑动作，使两种动画能够自然地融合。</li></ul></li><li><strong>Avatar Mask（骨骼蒙版）</strong><ul><li>使用 Avatar Mask 可以指定某些动画只影响部分骨骼（如只控制上半身或下半身），其他部分则保持原状态。</li><li>通过 Avatar Mask，Unity 可以让不同动画的骨骼系统只影响特定的骨骼区域，从而实现平滑的动画混合，不会相互干扰。</li></ul></li><li><strong>Animation Rigging 和 Constraints</strong><ul><li>Animation Rigging 包含了多种约束（Constraint）系统，可以在特定的骨骼上添加约束（如 IK 约束、Look At 约束等），用于平滑调整骨骼动画之间的过渡。</li><li>例如，角色的手可以通过 IK 保持在指定位置，无论下半身是跑步还是站立都不会影响手的位置，从而实现更自然的动画混合。</li></ul></li><li><strong>通过代码控制混合（Animator.CrossFade）</strong><ul><li>Unity 提供了 <code>Animator.CrossFade</code> 函数，通过代码指定从当前动画过渡到目标动画的时间，实现平滑过渡。</li><li>可以在特定条件触发时，动态控制不同动画间的过渡，比如攻击与跳跃的切换。设置过渡时间，确保在切换动作时不过于突兀。</li></ul></li></ol><h4 id="简述目前手机和PC端流行的贴图压缩格式，并说说有哪些优化点"><a href="#简述目前手机和PC端流行的贴图压缩格式，并说说有哪些优化点" class="headerlink" title="简述目前手机和PC端流行的贴图压缩格式，并说说有哪些优化点"></a>简述目前手机和PC端流行的贴图压缩格式，并说说有哪些优化点</h4><ol><li><strong>ETC（Ericsson Texture Compression）</strong><ul><li><strong>平台</strong>：广泛用于移动端，特别是 Android 设备。</li><li><strong>特点</strong>：ETC1 不支持透明通道（Alpha），ETC2 支持透明通道，但兼容性较低。</li><li><strong>优化点</strong>：对于不需要透明通道的贴图，可以选择 ETC1，以获得更广泛的兼容性；对于需要透明通道的情况，在新设备上使用 ETC2。</li></ul></li><li><strong>ASTC（Adaptive Scalable Texture Compression）</strong><ul><li><strong>平台</strong>：支持 iOS、Android 以及一些高端 PC 平台。</li><li><strong>特点</strong>：支持透明通道，压缩质量灵活，压缩率范围广（如 4x4、8x8 等块大小）。</li><li><strong>优化点</strong>：选择合适的块大小，块越大压缩率越高、质量越低。可根据贴图用途（如背景或 UI）选择不同的块大小，提高内存和性能效率。</li></ul></li><li><strong>PVRTC（PowerVR Texture Compression）</strong><ul><li><strong>平台</strong>：主要用于 iOS 设备，特别是老款设备。</li><li><strong>特点</strong>：支持透明通道，适合对内存占用敏感的场景。</li><li><strong>优化点</strong>：PVRTC 仅支持 2x2、4x4 的块大小，4x4 压缩比更高，但质量可能不佳。可以考虑将次要贴图或低分辨率贴图设置为 4x4，而关键贴图则使用 2x2。</li></ul></li><li><strong>DXT &#x2F; BC（Block Compression）</strong><ul><li><strong>平台</strong>：PC 端，特别是 Windows 平台的 DirectX 渲染。</li><li><strong>特点</strong>：DXT1 支持不带透明通道的压缩，DXT5 支持带透明通道的压缩；压缩效果优秀但只适合高性能设备。</li><li><strong>优化点</strong>：针对不透明的贴图优先使用 DXT1，减少内存占用。对于透明贴图，可以考虑使用 DXT5，同时尽量降低透明区域的复杂性。</li></ul></li><li><strong>Basis Universal（.basis 格式）</strong><ul><li><strong>平台</strong>：跨平台支持（通过 Vulkan、OpenGL、DirectX 进行二次解码）。</li><li><strong>特点</strong>：支持各种压缩格式，通过一次压缩生成多个平台兼容的压缩文件，减少开发工作量。</li><li><strong>优化点</strong>：优化点在于其二次解码策略，可以根据设备情况解码为合适的格式（如 ETC、BC、ASTC 等），减小内存负担，同时实现跨平台兼容性。</li></ul></li></ol><ul><li>优化要点<ol><li><strong>选择合适的压缩格式</strong>：不同平台和贴图用途选择对应的压缩格式（如 iOS 选择 PVRTC，PC 端选择 DXT 系列）。</li><li><strong>调整压缩块大小</strong>：如 ASTC 提供的不同块大小可以调整画质与压缩比之间的平衡，根据贴图的视觉重要性灵活选择。</li><li><strong>减少高分辨率贴图使用</strong>：在小物体或远景的贴图上使用较低分辨率和高压缩比的格式，以节省内存。</li><li><strong>预处理贴图</strong>：对贴图进行 mipmap 和降噪处理，减少贴图压缩时的质量损失，提高视觉效果。</li><li><strong>多通道合并</strong>：将多个低彩度通道合并到一张贴图上（如使用 RGBA 通道分配不同的内容），减少单独贴图的占用。</li></ol></li></ul><h4 id="LZ4和LZMA"><a href="#LZ4和LZMA" class="headerlink" title="LZ4和LZMA"></a>LZ4和LZMA</h4><ul><li>LZ4：适合 运行时按需加载的资源（如贴图、模型、场景内容等），比如游戏运行中动态加载的 AssetBundle。因为 LZ4 的分块特性，解压时间大幅减少，并且对内存和 CPU 的消耗较低。</li><li>LZMA：适合 静态内容或大容量初次加载的场景，如游戏的启动加载、初次资源解压等。在 Unity 中，LZMA 更适合一次性解压的资源包，如启动加载时解压的场景或静态内容。</li></ul><h4 id="怎么使用Protobuf通信"><a href="#怎么使用Protobuf通信" class="headerlink" title="怎么使用Protobuf通信"></a>怎么使用Protobuf通信</h4><ul><li>在 Unity 中使用 Protobuf 进行通讯时，首先定义 .proto 文件以确定消息结构（如 PlayerAction），然后用 protoc 工具生成对应的 C# 文件。在 Unity 中，创建 PlayerAction 对象并调用 ToByteArray() 将其序列化为字节数组，通过 TcpClient 发送到服务器。服务器接收后，通过 PlayerAction.Parser.ParseFrom() 方法将字节数组反序列化为 PlayerAction 对象，便于读取消息内容。这种方法使游戏实现高效、跨平台的数据通讯。</li></ul><h4 id="meta文件"><a href="#meta文件" class="headerlink" title="meta文件"></a>meta文件</h4><ul><li>Unity 导入文件时生成的 .meta 文件用于存储该文件的唯一 ID（UUID）、导入设置和资源依赖信息，确保项目中资源在版本控制或移动时的引用关系一致性。</li></ul><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li>在单例模式中，<strong>饿汉式</strong>是在类加载时就创建实例，实例的生命周期从程序启动到结束，线程安全，但即使不使用实例也会占用资源；<strong>懒汉式</strong>则在首次访问时才创建实例，节省了资源，但需要额外的线程同步机制来确保线程安全。</li><li>unity中推荐后者，可以加上DontDestroyOnLoad确保跨场景的持续存在</li></ul><h4 id="高速碰撞检测"><a href="#高速碰撞检测" class="headerlink" title="高速碰撞检测"></a>高速碰撞检测</h4><ul><li>使用连续碰撞检测：Unity的碰撞检测模式（刚体组件）提供了“Discrete”（离散）、“Continuous”（连续）和“Continuous Dynamic”等选项。这会在每帧之间检查是否发生碰撞，而不是仅在每帧末尾的位置检测碰撞</li><li>射线检测：使用Physics.Raycast从子弹的当前位置沿其移动方向发射一条射线，射线长度设置为本帧预期的移动距离。如果射线检测到碰撞体，则可以触发相应的碰撞逻辑，同时将子弹移动到碰撞点</li><li>子弹可以是实体，在子弹头前加一小段射线也可以检测碰撞</li></ul><h4 id="Blend-Tree相关"><a href="#Blend-Tree相关" class="headerlink" title="Blend Tree相关"></a>Blend Tree相关</h4><ul><li>设置一个参数来控制动画平滑过渡，用animator.SetFloat来设置参数值</li><li>1D Blend Tree：用于单一方向上的动画混合，它基于一个参数。会在不同动画片段之间进行平滑插值，使动画过渡自然；例如，角色的走、跑和冲刺动画可以使用一个速度参数，在不同速度下切换动画</li><li>2D Simple Directional：基于两个参数（水平速度和垂直速度），在二维平面中定义动画切换方向；例如走路或奔跑时根据实际移动方向平滑切换动画</li><li>2D Freeform Directional：动画片段的权重不仅基于两个参数（通常是水平和垂直速度），还考虑到动画的插值角度，这使得不同方向上的动画过渡更加流畅；例如角色在进行大范围转弯或复杂的四向、八向运动时的平滑切换</li><li>2D Freeform Cartesian：在动画插值时并不考虑角度，只基于二维空间中的位置。通过在二维空间中定义多个动画点，系统会根据当前位置在这些动画之间进行平滑过渡</li></ul><h4 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h4><ul><li>A*算法可以找到全局最短路径，只要启发式函数是可行的和一致的</li><li>启发式函数h(n)必须是可行的，即对于任何结点n，估算的成本不能超过实际成本</li><li>启发式函数h(n)若是一致的，即对于每个结点n到其相邻结点m，h(n) &lt;&#x3D; c(n, m) + h(m)（其中c(n, m)是从n到m的实际成本），则A*算法不仅能找到全局最优路径，而且无需回溯</li><li>相比Dijstra算法：<ul><li>速度更快，因为后者需要遍历所有节点</li><li>更适合路径规划和实时计算，理由同上</li><li>灵活的适应性，因为有启发式函数</li></ul></li><li>A* 算法使用的主要数据结构：<ul><li>开放列表：优先队列（存储待探索的节点）。</li><li>闭合列表：集合（存储已探索的节点）。</li><li>父节点映射：哈希表（记录节点的父节点）。</li><li>路径代价表：哈希表（存储从起点到每个节点的最短代价）。</li><li>最终结果（最优路径）：通常存储在一个列表中，包含从起点到目标的节点顺序。</li></ul></li></ul><h4 id="NavMesh相关"><a href="#NavMesh相关" class="headerlink" title="NavMesh相关"></a>NavMesh相关</h4><ul><li>在运行时添加障碍物后，AI角色默认不会避开新增障碍物。为解决此问题，可以对障碍物添加NavMesh Obstacle并启用雕刻功能；如果场景变化较大，可以使用NavMeshSurface在运行时重新生成或部分更新导航网格，以确保AI路径规划的准确性。</li></ul><h4 id="刚体相关"><a href="#刚体相关" class="headerlink" title="刚体相关"></a>刚体相关</h4><ul><li>可以通过设置 Rigidbody 的 Interpolation 属性为 Interpolate 来平滑物体在 FixedUpdate 和渲染之间的运动</li><li>逻辑和渲染分开：确保物理更新在 FixedUpdate 中进行，而渲染更新在 Update 中进行。确保在 Update 方法中读取 Rigidbody 的位置和旋转，以便在每帧中进行平滑渲染。</li><li>使用平滑方法：在更新物体位置时，可以使用插值（如线性插值或球形插值）来平滑物体的移动。</li></ul><h4 id="粒子系统相关"><a href="#粒子系统相关" class="headerlink" title="粒子系统相关"></a>粒子系统相关</h4><ul><li>粒子发射器（定义粒子的发射位置、速率、方向等）</li><li>粒子属性（定义大小，颜色等）</li><li>运动（定义运动轨迹，重力，风力影响等）</li><li>渲染（设置纹理和材质）</li><li>生命周期（管理粒子的生命周期，包括生成、变化和销毁）</li><li>碰撞，事件</li><li>粒子系统通过优化数据结构、利用批处理和 GPU 加速等技术，避免了将每个粒子作为单独的 GameObject 实现，从而有效减少性能消耗。</li></ul><h4 id="动画系统相关"><a href="#动画系统相关" class="headerlink" title="动画系统相关"></a>动画系统相关</h4><ul><li>动力学动画指使用物理引擎或物理计算来模拟角色或物体的自然运动行为。通常考虑重力、碰撞、摩擦、速度等因素，使得动画更符合物理规律<ul><li>通过物理引擎来计算运动，比如Unity中的Rigidbody组件、重力设置、物理材料等</li><li>用于角色行走、跑步、跳跃的物理反应、布料和头发的动态运动等</li><li>计算量较大，性能要求高，不适合实时性要求极高的简单动画</li></ul></li><li>非动力学动画指不使用物理引擎，而是直接使用关键帧、骨骼动画、插值等方法预设的动画。不受物理环境因素影响，运动轨迹是固定的<ul><li>常用方法包括关键帧动画、曲线插值、骨骼绑定等</li><li>适合角色的基本动作（如行走、攻击）、用户界面动画、简单物体移动等</li><li>缺少真实的物理反应，动画相对死板，无法根据环境动态调整</li></ul></li></ul><h4 id="AABB-Axis-Aligned-Bounding-Box-盒碰撞检测"><a href="#AABB-Axis-Aligned-Bounding-Box-盒碰撞检测" class="headerlink" title="AABB(Axis-Aligned Bounding Box)盒碰撞检测"></a>AABB(Axis-Aligned Bounding Box)盒碰撞检测</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">bool</span> <span class="title">CheckAABBCollision</span><span class="params">(AABB a, AABB b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.max.x &gt;= b.min.x &amp;&amp; a.min.x &lt;= b.max.x) &amp;&amp;</span><br><span class="line">           (a.max.y &gt;= b.min.y &amp;&amp; a.min.y &lt;= b.max.y) &amp;&amp;</span><br><span class="line">           (a.max.z &gt;= b.min.z &amp;&amp; a.min.z &lt;= b.max.z); <span class="comment">// 若为二维则省略z轴</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>四叉树（QuadTree）&#x2F; 八叉树（Octree）：通过递归划分空间，将物体分配到对应的节点中，缩小潜在的碰撞检测范围。四叉树用于二维空间，八叉树用于三维空间。划分后仅检测同一区域内的AABB盒，减少不必要的碰撞检测。</li><li>网格划分（Grid-Based Partitioning）：将空间划分为网格，每个网格存储当前AABB的对象，只检测同一网格中的AABB。此方法在对象分布较均匀时效率较高</li><li>排序轴检测：将所有AABB在x轴（或其他任意轴）上排序，将重叠的AABB放入候选列表，再对候选列表中进行精确的AABB碰撞检测</li></ul><h4 id="Animator相关"><a href="#Animator相关" class="headerlink" title="Animator相关"></a>Animator相关</h4><ul><li>Animator：适合简单到中等复杂度的动画需求，提供图形化的状态机和自动化过渡，易于使用但灵活性有限。</li><li>Playable API：适合复杂且动态的动画控制场景，提供更强的灵活性和性能控制，但需要更多的编程工作。</li></ul><h4 id="RenderTexture相关"><a href="#RenderTexture相关" class="headerlink" title="RenderTexture相关"></a>RenderTexture相关</h4><ul><li>RenderTexture 是 Unity 中用于将渲染结果输出到纹理的强大工具，适用于实现离屏渲染、后期处理、实时反射和折射等效果。</li><li>它的优点在于灵活性，能够创建复杂的视觉效果，如小地图、动态内容显示等。</li><li>高性能和内存开销，尤其在高分辨率和动态更新场景中需要特别注意。它适合用于需要自定义渲染和图像处理的复杂项目，但需要平衡性能与质量。</li></ul><h4 id="地形贴图出现缝隙"><a href="#地形贴图出现缝隙" class="headerlink" title="地形贴图出现缝隙"></a>地形贴图出现缝隙</h4><ul><li>地形贴图出现缝隙通常由纹理采样、UV 精度、LOD 切换或多个地形块拼接问题引起。为解决这些问题，可以通过设置纹理过滤模式为 Clamp、禁用或优化 MipMap、提高网格分辨率、使用无缝纹理以及同步地形和纹理的 LOD 切换。还可以通过扩展纹理边缘和边缘融合技术，确保地形块拼接时不会产生缝隙，从而提高渲染效果的连续性与美观性。</li></ul><h4 id="Playable相关"><a href="#Playable相关" class="headerlink" title="Playable相关"></a>Playable相关</h4><p><strong>三者之间的区别</strong></p><table><thead><tr><th>特性</th><th>Animation</th><th>Animator</th><th>Playable</th></tr></thead><tbody><tr><td><strong>用途</strong></td><td>播放简单动画</td><td>管理复杂动画状态机</td><td>灵活的动态动画控制</td></tr><tr><td><strong>复杂度</strong></td><td>低</td><td>中高</td><td>高</td></tr><tr><td><strong>适用场景</strong></td><td>简单动画，线性动画</td><td>复杂动画状态，角色控制</td><td>动态动画组合、混合，编程化控制</td></tr><tr><td><strong>状态机支持</strong></td><td>不支持</td><td>支持</td><td>通过代码控制可以实现类似状态机的功能</td></tr><tr><td><strong>动画混合</strong></td><td>不支持</td><td>支持</td><td>支持自定义动画混合</td></tr><tr><td><strong>参数驱动</strong></td><td>不支持</td><td>支持</td><td>支持动态控制和组合</td></tr><tr><td><strong>与 Timeline 结合</strong></td><td>不适用</td><td>可以结合 Timeline 管理动画</td><td>与 Timeline 紧密结合，可控制时间轴</td></tr><tr><td><strong>动态性</strong></td><td>通过设置 <code>AnimationClip</code> 播放</td><td>依赖状态机切换</td><td>通过编程动态组合和控制动画</td></tr></tbody></table><ul><li><strong>Animation</strong>：适用于简单的动画播放，不需要复杂的状态过渡。</li><li><strong>Animator</strong>：适合复杂的动画系统，支持状态机、动画混合等功能，适用于角色动画、骨骼动画等场景。</li><li><strong>Playable API</strong>：适合动态控制和组合动画，提供极高的灵活性，适用于复杂的动画控制和 Timeline 整合的场景。</li></ul><h3 id="4-项目相关"><a href="#4-项目相关" class="headerlink" title="4. 项目相关"></a>4. 项目相关</h3><h4 id="柏林噪声为什么可以平滑模拟地形"><a href="#柏林噪声为什么可以平滑模拟地形" class="headerlink" title="柏林噪声为什么可以平滑模拟地形"></a>柏林噪声为什么可以平滑模拟地形</h4><ul><li>柏林噪声生成的值是连续的，即相邻点的值变化较小</li><li>柏林噪声的参数（如频率、振幅、偏移等）可以根据需求进行调整。这使得开发者可以控制地形的特征</li><li>柏林噪声在局部区域内表现出一致性，意味着在小范围内，生成的值不会出现剧烈的变化</li></ul><h4 id="简述单状态机和多状态机，以及如何实现混合动画"><a href="#简述单状态机和多状态机，以及如何实现混合动画" class="headerlink" title="简述单状态机和多状态机，以及如何实现混合动画"></a>简述单状态机和多状态机，以及如何实现混合动画</h4><ul><li>需要绘制FSM图来判断转移条件是否设计的合理</li><li>单状态机<br>单状态机是指在一个状态机中管理角色的所有状态，每次只能处于一个状态。例如，角色可以是“站立”、“跑步”或“攻击”中的一种状态。<ul><li><strong>优点</strong>：简单易于实现，状态管理清晰。</li><li><strong>缺点</strong>：难以处理同时存在的多个状态，比如“跑步+攻击”的组合状态，通常需要为每种组合创建新的状态，导致状态爆炸。</li></ul></li><li>多状态机<br>多状态机是将状态拆分为多个子状态机，分别管理不同的状态。例如，一个状态机负责处理移动（如“站立”、“跑步”），另一个状态机负责攻击（如“普通攻击”、“技能攻击”）。<ul><li><strong>优点</strong>：更灵活，允许多个状态机独立运行，轻松处理不同的状态组合。</li><li><strong>缺点</strong>：实现复杂度稍高，需要管理多个状态机之间的协调。</li></ul></li><li>同时实现多个状态（如跑步时攻击）<br><a href="https://blog.csdn.net/weixin_34004750/article/details/85757204">AvatarMask</a><br>要在“跑步”状态下实现“攻击”，可以结合多状态机和分层状态的方式：<ol><li><strong>多状态机</strong>：将“移动”和“攻击”状态分别放在两个独立的状态机中。这样可以同时触发“跑步”状态和“攻击”状态，实现两者的组合。</li><li><strong>分层状态管理（Layered States）</strong>：<ul><li>在 Unity 中可以通过 Animator Controller 的分层（Layers）机制来实现。设置一个“移动”层管理跑步等状态，另一个“攻击”层管理攻击状态，并在两个层上分别定义跑步和攻击的动画。</li><li><strong>层级权重</strong>：通过调整各层的权重，实现上半身攻击和下半身跑步的同时播放。</li><li><strong>Avatar Mask</strong>：使用 Avatar Mask 将攻击动画只作用于上半身，跑步动画则作用于下半身，这样就能自然地实现“跑步+攻击”的组合。</li></ul></li><li><strong>触发优先级</strong>：在逻辑上优先处理攻击等高优先级动作，例如在跑步时按下攻击键触发攻击的上半身动画，同时保持下半身的跑步动作。</li></ol></li></ul><h4 id="定时器项目"><a href="#定时器项目" class="headerlink" title="定时器项目"></a>定时器项目</h4><ul><li>项目技术点可以说这个</li><li>提供了高灵活性和优化的任务管理，支持自定义时间、帧数、回调函数和执行次数等条件，且通过小顶堆提高了大量任务处理的性能。适用于需要精确控制执行条件和高频率调度的场景</li><li>Unity协程更适合逐帧执行和延时处理的场景，可以在一段时间内分步完成任务，如资源加载、异步请求等。协程依靠yield return提供非阻塞的等待和延时，便于编写流畅、自然的异步代码，适合有中断需求的任务和易读性的异步逻辑</li><li>大规模定时任务优化：<ul><li>数据结构优化：分层队列，将任务按不同的触发时间层级存储（例如1秒内、10秒内、1分钟内等），每个层级独立排序并单独处理</li><li>分布式：区域化处理，在游戏服务器上，可以将任务按玩家区域划分，分配给不同的服务器进程或线程管理。</li><li>对象池和延迟分配：在Unity中，大规模定时任务频繁创建和销毁会带来GC开销，可以使用对象池管理定时任务对象</li></ul></li></ul><h4 id="AB项目"><a href="#AB项目" class="headerlink" title="AB项目"></a>AB项目</h4><ul><li>主要实现了什么<br>三个部分。一个部分就是根据一个xml文件，然后进行一个打包的处理。然后第二个部分就是进行一个加载AB包以及现在的一个逻辑的管理。然后第三部分就是热更新的一个管理，就是进行MD5值对比，然后再进行下载，热更新。</li><li>AB包在运行时是怎么管理它的加载和卸载?<br>使用字典数据结构存储每个AB包，key值是AB包，value是引用计数，加载AB包时会递归查询它的依赖，并将该AB包和依赖包的引用计数都加1。卸载时就调用卸载方法对该AB包和其依赖的引用计数都减1.然后当它的引用计数为零的时候，管理器就会把它移到一个卸载队列。然后在卸载队列里等到下一帧的更新的时候然后它会把它卸出来。</li><li>打包策略考虑<br>逻辑紧密的资源尽量打包成一个包</li><li>怎么知道哪些资源共用了资源并需要把共用的资源单独打包<ul><li>显式打包公共资源：<br>开发者可以手动设置公共资源单独打包，例如将材质、纹理、音频等共用资源放入专门的 AB 包中，并设置其他 AB 包依赖该公共包。这样，多个资源包可以引用同一 AB，进一步减少重复打包的可能性。</li><li>配置文件策略：<br>使用配置文件（如图集或依赖清单）将资源分组，指定共用资源的打包方式。通过在配置文件中预设依赖结构，明确资源打包的优先级和独立性，确保资源共用关系明确化，进一步优化依赖结构。</li><li>使用代码：<ul><li>使用 AssetDatabase.GetDependencies 获取资源依赖关系：该方法可以帮助我们获取指定资源的所有依赖项。</li><li>建立引用计数表：遍历项目中的所有资源，记录每个资源的依赖项，并建立一个字典来统计每个资源的被依赖次数。</li><li>输出共用资源：筛选出引用计数大于 1 的资源，这些资源就是在多个资源中被共用的资源。</li></ul></li></ul><ul><li>使用Unity中的AssetBundle标签，将共用资源手动或自动设置为特定标签（如“Shared”）。</li><li>将可能被多个AB包引用的资源放入一个专用的文件夹中，如Textures&#x2F;Shared、Models&#x2F;Shared等。</li></ul></li><li>分组策略：将同类共用资源按用途或类型分组（如“UI资源”、“特效资源”、“音效资源”等），并将每个组打包成一个独立的AB包。这样可以减少AB包的数量，方便加载和管理。</li><li>依赖合并：对于不同资源中引用到的小型资源（如小图片、模型材质等），可以进行依赖合并。将引用量较小的资源按照组来合并打包，比如将所有UI用到的小图标统一打包。</li><li>定义“高频引用”：设置一个引用次数的阈值，只有被超过某个频次引用的资源才会视为共用资源。例如，只有被5个或以上资源引用的才会单独打包，低于这个次数的资源则跟随引用较多的AB包一起打包。</li><li>模块化资源打包：将资源按功能模块进行划分，例如将所有关卡资源、UI资源、角色资源分别打包。这些模块中的共用资源放入模块级别的AB包中，从而避免按单个资源拆分带来的碎包问题。</li><li>Android<ul><li>StreamingAssets: Application.streamingAssetsPath (需要使用 UnityWebRequest)</li><li>PersistentDataPath: Application.persistentDataPath (可直接读取)</li><li>TemporaryCachePath: Application.temporaryCachePath</li></ul></li><li>iOS<ul><li>StreamingAssets: Application.streamingAssetsPath (可直接读取)</li><li>PersistentDataPath: Application.persistentDataPath (可直接读取)</li><li>TemporaryCachePath: Application.temporaryCachePath</li></ul></li><li>选择合适的路径取决于资源的存储需求：StreamingAssets 适合存放不会改变的资源，而 PersistentDataPath 适合热更新和用户下载的内容。</li></ul><h4 id="热更新相关"><a href="#热更新相关" class="headerlink" title="热更新相关"></a>热更新相关</h4><ul><li>HybridCLR热更新原理是什么<ul><li>HybridCLR 热更新通过在 AOT（Ahead-Of-Time）编译的基础上引入解释执行模式，使部分 IL 代码在运行时解释执行，从而支持代码的动态更新和热修复，兼容 iOS 的 JIT 限制。</li></ul></li><li>AOT：AOT（提前编译）是在程序运行前将代码编译为机器码，提高启动速度和安全性，但限制了运行时动态代码执行的灵活性。</li><li>新项目用xlua还是HybirdCLR好<ul><li>新项目如果追求更好的性能和 iOS 热更新兼容性，推荐使用 HybridCLR；而若需求简单且已有 Lua 生态基础，可以选择 xLua。</li><li>HybridCLR 的性能更好是因为它直接在虚拟机上运行预编译的 C# IL 代码，不像 xLua 需要通过解释器将 Lua 脚本转换为可执行代码，减少了额外的解释开销和跨语言调用的性能损耗，因而更高效。</li></ul></li></ul><h4 id="UnityWebRequest相关"><a href="#UnityWebRequest相关" class="headerlink" title="UnityWebRequest相关"></a>UnityWebRequest相关</h4><ul><li>UnityWebRequest 类使用的是HTTP&#x2F;HTTPS 协议，而 HTTP 协议本质上是基于 TCP 连接 的</li><li>HTTP 使用端口 80，HTTPS 使用端口 443</li><li>流程：<ul><li>发送请求：客户端通过 UnityWebRequest 构造并发送一个 HTTP 请求（如 GET 或 POST）到服务器，目标资源由 URL 指定。</li><li>TCP 连接：HTTP&#x2F;HTTPS 基于 TCP 协议，客户端与服务器通过 TCP&#x2F;IP 建立连接。对于 HTTPS，还会进行加密握手（TLS&#x2F;SSL）。</li><li>请求发送：在建立连接后，客户端发送 HTTP 请求到服务器，可能包含请求头和数据。</li><li>服务器响应：服务器处理请求，并返回 HTTP 响应，包含状态码、内容类型和资源（如 JSON、文件等）。</li><li>处理响应：客户端接收到响应后，解析数据。如果状态码是成功（如 200 OK），则处理获取的资源（如文件、JSON 数据等）；否则处理错误。</li></ul></li><li>请求类别<ul><li>GET 请求：用于从服务器获取数据或文件，通过 UnityWebRequest.Get() 发送请求。</li><li>POST 请求：用于向服务器提交数据（如表单、文件），通过 UnityWebRequest.Post() 发送请求。</li><li>下载文件：可以使用 UnityWebRequestAssetBundle 下载 AB 包，或 UnityWebRequestTexture 下载图像文件</li></ul></li></ul><h4 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h4><ul><li>文件检查与断点续传：<ul><li>在下载前，检查本地是否存在部分下载的文件，并记录已经下载的字节数（通过 FileInfo.Length 获取）。</li><li>如果有部分文件已下载，则在 HTTP 请求头中加入 Range: bytes&#x3D;已下载字节数-，告诉服务器从该位置继续传输。</li></ul></li><li>文件保存：<ul><li>下载的文件数据写入到一个临时文件中（以防下载失败导致文件损坏），完成下载后再将临时文件重命名为最终文件。</li></ul></li><li>HTTP Range 请求：<ul><li>UnityWebRequest 支持设置自定义请求头，在这里通过 SetRequestHeader(“Range”, “bytes&#x3D;已下载字节数-“) 来告诉服务器从文件的某个位置开始传输。</li></ul></li><li>文件合并：<ul><li>如果是断点续传，打开文件流并以 Append 模式写入新下载的数据。下载完成后，将临时文件重命名为最终文件。</li></ul></li><li>下载进度更新：<ul><li>下载过程中，可以通过 <a href="http://www.downloadhandler.data/">www.downloadHandler.data</a> 获取当前下载的数据，并写入文件流。你可以在此基础上扩展，比如定期保存下载进度、更新 UI 等。</li></ul></li><li>服务器端的要求：<ul><li>支持 HTTP Range 请求：服务器需要实现 Range 头，并能够处理部分内容请求。如果服务器不支持 Range 请求，则无法实现断点续传。</li><li>返回状态码 206（Partial Content）：当服务器处理了部分请求时，应该返回 HTTP 状态码 206 Partial Content，表示文件的一部分成功传输。</li></ul></li></ul><h4 id="对象池相关"><a href="#对象池相关" class="headerlink" title="对象池相关"></a>对象池相关</h4><ul><li>可以将obj的scale设成0，同时自己实现一个Init函数，在get的时候调用改函数来初始化</li></ul><h4 id="实习相关"><a href="#实习相关" class="headerlink" title="实习相关"></a>实习相关</h4><ul><li>DXT&#x2F;ETC 这种压缩格式和 jpg&#x2F;png 之间有什么区别<br>DXT 和 ETC 是专为 GPU 优化的纹理压缩格式，可以直接加载到显存中使用，避免 CPU 解压，显存占用小、渲染性能高，非常适合游戏和实时渲染。相比之下，JPG 和 PNG 在加载到显卡前需要 CPU 解压，解压后显存占用较大，对 GPU 内存带宽要求高，适合图像存储和传输，但不适合实时渲染。</li></ul><h4 id="如何设计一个系统（如背包系统）"><a href="#如何设计一个系统（如背包系统）" class="headerlink" title="如何设计一个系统（如背包系统）"></a>如何设计一个系统（如背包系统）</h4><ol><li>系统架构设计（如用MVC框架）</li><li>静态数据配置，数据结构设置</li><li>用户进度存档</li><li>UI与用户交互</li><li>核心功能设计</li></ol><h3 id="5-数据结构和算法相关"><a href="#5-数据结构和算法相关" class="headerlink" title="5. 数据结构和算法相关"></a>5. 数据结构和算法相关</h3><h4 id="完全二叉树在堆中的应用"><a href="#完全二叉树在堆中的应用" class="headerlink" title="完全二叉树在堆中的应用"></a>完全二叉树在堆中的应用</h4><ul><li><strong>二叉堆（Binary Heap）</strong>：是一种基于完全二叉树的数据结构，分为<strong>最大堆</strong>和<strong>最小堆</strong>。在最大堆中，父节点的值始终大于或等于其子节点；在最小堆中，父节点的值始终小于或等于其子节点。</li><li><strong>完全二叉树的特性</strong>：二叉堆采用完全二叉树的结构，因此可以用数组高效存储，从根节点到叶子节点依次存放。这样可以利用索引来轻松计算节点的父节点和子节点位置，例如：<ul><li>给定节点的索引 ( i ) ，其父节点的索引为 ( (i - 1) &#x2F; 2 )。</li><li>左子节点的索引为 ( 2i + 1 )，右子节点的索引为 ( 2i + 2 )。</li></ul></li><li><strong>堆操作</strong>：二叉堆的插入和删除操作（堆化操作）基于完全二叉树的结构，通过数组实现自动调整位置，保证了操作的对数复杂度 ( O(\log n) )。查找得(O(n))</li></ul><h4 id="哪种数据管理使用双向链表进行管理的"><a href="#哪种数据管理使用双向链表进行管理的" class="headerlink" title="哪种数据管理使用双向链表进行管理的"></a>哪种数据管理使用双向链表进行管理的</h4><ul><li>双向链表常用于 <strong>LRU（Least Recently Used）缓存</strong>的数据管理中。LRU 缓存通过双向链表和哈希表的组合来管理数据。双向链表用于维护数据的访问顺序，最新访问的节点放在链表头部，最久未使用的节点在尾部，当缓存超出容量时，可以快速移除尾部节点。同时，双向链表的双向性使得节点可以在 O(1) 时间内进行插入、删除和移动，非常适合这种数据管理方式。</li></ul><h4 id="红黑树，B树，B-树"><a href="#红黑树，B树，B-树" class="headerlink" title="红黑树，B树，B+树"></a>红黑树，B树，B+树</h4><ol><li>红黑树（Red-Black Tree）<br> 红黑树是一种<strong>自平衡的二叉搜索树</strong>，通过对节点颜色的约束实现平衡，使得树的高度始终保持在较低水平，从而提高查找效率。<ul><li><strong>结构特性</strong>：<ol><li>每个节点要么是红色，要么是黑色。</li><li>根节点是黑色。</li><li>叶节点（即空节点）都是黑色。</li><li>红色节点不能有红色子节点（红节点的子节点必须为黑色）。</li><li>从任一节点到其叶子节点的所有路径上，黑色节点数量相同。</li></ol></li><li><strong>应用场景</strong>：适合内存中进行快速查找的场景，广泛用于平衡二叉查找树中，如 Java 中的 TreeMap 和 TreeSet。</li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：由于树的高度平衡，查找、插入和删除操作复杂度为 O(log n)，性能稳定。</li><li><strong>缺点</strong>：树结构较为复杂，平衡维护的成本较高，通常不适合存储大量数据的外存结构。</li></ul></li></ul></li><li>B树（B-Tree）<br> B树是一种<strong>多叉平衡树</strong>，用于磁盘或其他存储设备的数据管理。B树的每个节点可以有多个子节点，从而有效降低了树的高度，特别适合大数据量的查找操作。<ul><li><strong>结构特性</strong>：<ol><li>树的阶数（<code>m</code> 阶）定义了每个节点最多有 m 个子节点。</li><li>每个节点包含多个键值，并保持键值排序。</li><li>每个非叶节点的子节点数量等于关键字数量+1。</li><li>所有叶子节点都在同一层，确保树的平衡。</li></ol></li><li><strong>应用场景</strong>：适用于数据库和文件系统中需要多层次索引的数据存储结构，例如文件系统和数据库的索引实现。</li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：减少树的高度，降低磁盘 I&#x2F;O 次数，查找性能优于二叉树。</li><li><strong>缺点</strong>：节点结构较复杂，插入和删除需要频繁分裂和合并节点，维护成本较高。</li></ul></li></ul></li><li>B+树（B+ Tree）<br> B+树是 B 树的变种，具有类似的多叉平衡结构，但在结构上进行了优化，使得叶子节点形成链表，便于范围查询和顺序遍历。<ul><li><strong>结构特性</strong>：</li></ul><ol><li>非叶节点只存储键值，不直接存储数据，数据全部存储在叶子节点中。</li><li>所有叶子节点形成一个有序链表，用于高效的区间查找。</li><li>B+ 树的阶数（m 阶）定义每个节点可以拥有的子节点数量，非叶节点包含 m-1 个键值。</li></ol><ul><li><strong>应用场景</strong>：广泛应用于数据库索引系统和文件系统中，用于处理大规模数据的范围查询和顺序遍历。</li><li><strong>优缺点</strong>：<ul><li><strong>优点</strong>：数据都集中在叶子节点，并且叶子节点形成链表，便于顺序和范围查询，树高较低，磁盘 I&#x2F;O 性能更好。</li><li><strong>缺点</strong>：相比 B 树存储的数据更多，增加了空间开销。</li></ul></li></ul></li><li>总结<ul><li><strong>红黑树</strong>：平衡二叉搜索树，用于内存中快速查找操作，查找、插入和删除复杂度为 O(log n)。</li><li><strong>B树</strong>：多叉平衡树，适用于数据库和文件系统的多层次索引，减少磁盘 I&#x2F;O。</li><li><strong>B+树</strong>：B 树的优化版本，叶子节点通过链表连接，支持顺序遍历和范围查找，广泛用于数据库系统的索引。</li></ul></li></ol><h4 id="洗牌算法"><a href="#洗牌算法" class="headerlink" title="洗牌算法"></a>洗牌算法</h4><ol><li><strong>算法原理</strong>：Fisher-Yates洗牌算法通过随机交换数组中的元素来打乱顺序。</li><li><strong>步骤</strong>：从数组末尾向前遍历，每次随机选取一个位置，与当前位置的元素交换。</li><li><strong>等概率性</strong>：算法确保每个元素在每个位置上出现的概率相等，实现完全随机的洗牌效果。</li><li><strong>时间复杂度</strong>：算法的时间复杂度为<code>O(n)</code>，适合大规模数据的洗牌。</li><li><strong>空间复杂度</strong>：在原数组上操作，无需额外空间，空间复杂度为<code>O(1)</code>。</li><li><strong>应用场景</strong>：广泛用于随机抽样、卡牌洗牌、数组打乱等需要随机排序的场合。</li></ol><h4 id="如何设计排行榜"><a href="#如何设计排行榜" class="headerlink" title="如何设计排行榜"></a>如何设计排行榜</h4><ul><li>数据结构设计：需要ID，分数，排名，同时需要索引来查找</li><li>排序逻辑：<ul><li>实时排序：可以使用排序算法（如快速排序或堆排序）在插入新分数时实时更新排行榜，适合用户数量较少的情况</li><li>延迟排序：对于大规模用户，实时排序可能带来性能瓶颈，可以采用批量更新或延迟排序的方式，定期更新一次排行榜</li><li>附近排名查询：为了显示用户周围的排名，可以根据用户分数所在的范围查询上下几名玩家的数据</li><li>Top N查询：排行榜通常需要展示Top N数据，可以直接获取前N名的记录</li></ul></li></ul><h3 id="6-图形学相关"><a href="#6-图形学相关" class="headerlink" title="6. 图形学相关"></a>6. 图形学相关</h3><h4 id="什么是渲染管线？Unity-的-SRP（Scriptable-Render-Pipeline）有什么作用"><a href="#什么是渲染管线？Unity-的-SRP（Scriptable-Render-Pipeline）有什么作用" class="headerlink" title="什么是渲染管线？Unity 的 SRP（Scriptable Render Pipeline）有什么作用"></a>什么是渲染管线？Unity 的 SRP（Scriptable Render Pipeline）有什么作用</h4><ul><li>渲染管线是将 3D 场景转换为 2D 图像的一系列步骤，包括顶点处理、光栅化、着色和后处理等。</li><li>Unity 提供三种主要渲染管线：<strong>内置渲染管线</strong>、<strong>通用渲染管线（URP）</strong> 和 <strong>高清渲染管线（HDRP）</strong>。内置渲染管线是 Unity 的默认选择，适合一般项目；URP 优化性能，适合移动和跨平台项目；HDRP 提供高级光照和视觉效果，适用于高端平台或视觉质量要求较高的项目。</li><li><strong>通用渲染管线（URP）</strong> 和 <strong>高清渲染管线（HDRP）</strong> 是 Unity 的可编程渲染管线（Scriptable Render Pipeline, SRP）。它们允许开发者自定义渲染流程，以满足不同平台的性能和视觉效果需求。通过 SRP，开发者可以在 Unity 中精细控制渲染顺序、光照、后处理等，适用于对渲染有特殊要求的项目。</li></ul><h4 id="如何优化-Unity-中的渲染性能"><a href="#如何优化-Unity-中的渲染性能" class="headerlink" title="如何优化 Unity 中的渲染性能"></a>如何优化 Unity 中的渲染性能</h4><ul><li><strong>减少 Draw Calls</strong>：通过合并 Mesh、使用静态批处理或动态批处理、使用图集来减少 Draw Calls。</li><li><strong>LOD（Level of Detail）</strong>：为远处物体降低模型复杂度，减少多边形数。</li><li><strong>光照优化</strong>：优先使用烘焙光照、减少实时光源数量。</li><li><strong>纹理压缩</strong>：使用合适的贴图压缩格式（如 ASTC、ETC 等）来降低内存占用。</li></ul><h4 id="MVP矩阵的概念"><a href="#MVP矩阵的概念" class="headerlink" title="MVP矩阵的概念"></a>MVP矩阵的概念</h4><ul><li>MVP 矩阵（Model-View-Projection Matrix）是 3D 渲染中的一个矩阵，包含模型矩阵、视图矩阵和投影矩阵，用于将物体的局部坐标转化为屏幕坐标。MVP 矩阵先将模型放入世界空间，再通过视图矩阵转换到摄像机空间，最后通过投影矩阵映射到二维屏幕，实现从 3D 到 2D 的转换。(正交投影和透视投影区别：P矩阵不同)</li></ul><h4 id="Shader-中避免分支的原因"><a href="#Shader-中避免分支的原因" class="headerlink" title="Shader 中避免分支的原因"></a>Shader 中避免分支的原因</h4><ul><li>在 Shader 中尽量避免分支（如 if-else），因为分支会导致显卡执行多个分支路径，增加性能开销，尤其是在并行计算中。Shader 的每个线程需要执行相同路径，因此无条件运算和线性插值往往比条件判断更高效，有利于提升渲染性能。</li></ul><h4 id="Phong-模型的组成"><a href="#Phong-模型的组成" class="headerlink" title="Phong 模型的组成"></a>Phong 模型的组成</h4><ul><li>Phong 模型是一种经典的光照模型，包含三个主要成分：环境光、漫反射光和镜面反射光。环境光提供基本亮度，漫反射光根据光源角度模拟物体的基础光照效果，而镜面反射光则提供高光效果，增加物体的真实感。</li></ul><h4 id="Draw-Call-的定义和优化"><a href="#Draw-Call-的定义和优化" class="headerlink" title="Draw Call 的定义和优化"></a>Draw Call 的定义和优化</h4><ul><li>Draw Call 是指 GPU 渲染一个对象所需的一次 CPU 调用，每次调用都有较大开销。<ul><li>UI：图集，动静分离</li><li>场景：动静批处理，GPU Instancing，视锥体剔除，背面剔除，限制粒子数量，光照贴图</li></ul></li></ul><h4 id="批处理的作用"><a href="#批处理的作用" class="headerlink" title="批处理的作用"></a>批处理的作用</h4><ul><li>批处理是将多个渲染对象合并成一个，减少 Draw Call 次数，降低 CPU 与 GPU 之间的数据交换量。批处理可以合并材质、模型等，减少渲染开销，是提高性能的常见手段。</li></ul><h4 id="平行光阴影的实现"><a href="#平行光阴影的实现" class="headerlink" title="平行光阴影的实现"></a>平行光阴影的实现</h4><ul><li>平行光阴影通常通过深度贴图实现，首先在光源视角渲染场景的深度信息，生成阴影贴图，然后在物体渲染时比较物体深度与阴影贴图深度，确定是否处于阴影中。</li></ul><h4 id="透明物体的渲染方法"><a href="#透明物体的渲染方法" class="headerlink" title="透明物体的渲染方法"></a>透明物体的渲染方法</h4><ul><li>透明物体在渲染时，通常需关闭深度写入并排序后绘制，从远到近逐层渲染，避免混色错误。常使用 Alpha 混合来控制透明度，以实现正确的视觉效果。</li></ul><h4 id="模板测试的作用"><a href="#模板测试的作用" class="headerlink" title="模板测试的作用"></a>模板测试的作用</h4><ul><li>模板测试用于控制像素是否渲染，可以通过设置模板缓冲区值进行条件测试，实现复杂效果，如剪裁、蒙版或指定区域渲染，有效提升场景渲染的灵活性。</li></ul><h4 id="场景中有很多物体，大部分不透明，部分半透明，应该如何做渲染"><a href="#场景中有很多物体，大部分不透明，部分半透明，应该如何做渲染" class="headerlink" title="场景中有很多物体，大部分不透明，部分半透明，应该如何做渲染"></a>场景中有很多物体，大部分不透明，部分半透明，应该如何做渲染</h4><ul><li>在渲染场景中，首先渲染不透明物体并启用深度写入，以建立深度缓冲，从而确保不透明物体遮挡关系正确；接着，渲染半透明物体，关闭深度写入但保持深度测试，并按从远到近的顺序排序，以避免半透明物体的混色问题。通过这种顺序渲染，可以实现正确的遮挡效果和透明度混合。</li></ul><h4 id="GPU-Instancing-概念"><a href="#GPU-Instancing-概念" class="headerlink" title="GPU Instancing 概念"></a>GPU Instancing 概念</h4><ul><li>GPU Instancing 是一种图形渲染技术，用于在 GPU 上高效渲染大量相同或相似的对象。通过 GPU Instancing，开发者可以一次性将多个实例的属性（如位置、颜色、大小等）传递给 GPU，减少 CPU 与 GPU 间的 Draw Call 数量。GPU Instancing 在场景中渲染大量重复物体（如树木、草地、敌人）时非常高效，因为所有实例共享同一个网格和材质，只有少量变动的属性会在 GPU 上单独处理，从而显著提升渲染性能。</li><li>区别<ul><li>GPU Instancing 更适合几何形状相同但可能位置或其他属性不同的对象，并且这些对象的数量比较大。它通过 GPU 的实例化渲染多个对象，减少了 CPU 的绘制调用。</li><li>静态合批处理 是一种在场景初始化时优化静态场景的技术，适合不发生变化的场景。它通过将对象合并成一个大网格，减少了 Draw Call。</li><li>动态合批处理 适合小型、移动频繁的对象，可以在每一帧合批，但会增加 CPU 的计算负担。</li></ul></li></ul><h4 id="为什么需要合批"><a href="#为什么需要合批" class="headerlink" title="为什么需要合批"></a>为什么需要合批</h4><ul><li>合批是为了减少渲染时的 Draw Call 数量，优化性能。每个 Draw Call 都会在 CPU 和 GPU 之间进行数据交换和指令传递，频繁的调用会增加 CPU 负担并降低帧率。合批将多个相似或相同材质的物体合并为一个批次发送到 GPU，减少 Draw Call 次数，从而提升渲染效率、降低系统资源消耗，使得游戏在不同设备上运行更加流畅。</li></ul><h4 id="静态合批与动态合批"><a href="#静态合批与动态合批" class="headerlink" title="静态合批与动态合批"></a>静态合批与动态合批</h4><ul><li><strong>静态合批</strong>和<strong>动态合批</strong>是 Unity 优化 Draw Call 的两种方法。静态合批用于不移动的静态物体，将共享材质的静态物体在编译时合并为一个大网格，减少 Draw Call 数量。动态合批用于小型动态物体，在运行时将共享材质的动态对象合并为批次并发送到 GPU，降低 CPU 与 GPU 之间的通信开销。静态合批适合固定场景，动态合批适合需要频繁移动的小型对象。</li><li>动态合批 适合少量小型动态对象的优化。</li><li>静态合批 适合场景中不移动的静态对象，节省 CPU 资源。</li><li>GPU Instancing 是适合大量相同物体的高效渲染技术，特别适用于需要大量重复对象的场景。</li><li>SRP Batcher 通过减少 CPU 设置 GPU 渲染状态的开销，适用于基于 SRP 的管线，提升大型场景的渲染效率。</li></ul><h4 id="阴影渲染相关"><a href="#阴影渲染相关" class="headerlink" title="阴影渲染相关"></a>阴影渲染相关</h4><ul><li>阴影贴图（Shadow Mapping）在 Unity 和其他现代渲染引擎中通常是实时渲染的。阴影贴图的工作流程是基于光源的视角实时生成深度贴图，然后在物体渲染时比较物体到光源的距离，决定物体是否处于阴影中。它与预处理的光照贴图（Lightmap）不同，光照贴图是预先计算好的静态阴影，而阴影贴图适用于动态场景和移动的光源。</li><li>阴影贴图是实时渲染技术，生成动态场景中的阴影，但可能出现阴影抖动问题。常见原因包括深度计算精度不足、纹理分辨率低、摄像机移动等。解决方案包括调整 Shadow Bias 和 Normal Bias 来修正深度偏移，提高阴影贴图的分辨率，使用 级联阴影贴图（CSM） 分级处理远近阴影，及启用软阴影或 PCF 过滤技术来平滑阴影边缘，从而减少抖动并提升渲染质量。</li><li>硬阴影：边缘清晰且过渡突变，适用于简单光照场景，计算性能高但不自然，通常用于模拟点光源的效果。</li><li>软阴影：边缘渐变过渡，模拟面积光源和多点光源，更加逼真但计算开销较大，常用于复杂光照场景，接近现实世界中的光影表现。</li><li>PCF（Percentage Closer Filtering）：通过对阴影贴图多个临近像素深度值进行多次采样来平滑阴影边缘，生成软阴影效果，性能开销取决于采样次数，在视觉效果和性能之间提供了平衡。</li><li>Shadow Bias 是为了防止阴影贴图中的阴影出现“自阴影”或“阴影漏斗”现象而引入的一个小的深度偏移值。</li><li>Normal Bias 是基于表面法线的偏移，常用于解决光照和阴影计算中由于表面倾斜导致的深度问题。</li></ul><h4 id="光追相关"><a href="#光追相关" class="headerlink" title="光追相关"></a>光追相关</h4><ul><li>光线追踪的核心思想是逆向追踪光线。传统的物理光线从光源发出，经过场景中的物体，最后到达摄像机。然而，在光线追踪中，从摄像机出发追踪光线，反向追踪每一条光线的路径直到光源，计算光线与场景中物体的相互作用，确定像素的颜色。</li></ul><h4 id="前向渲染与延迟渲染"><a href="#前向渲染与延迟渲染" class="headerlink" title="前向渲染与延迟渲染"></a>前向渲染与延迟渲染</h4><ul><li>前向渲染和延迟渲染是两种常见的渲染技术。前向渲染在每个物体渲染时直接计算光照，适合少量光源的场景，处理简单且对透明物体友好，但在多光源情况下性能下降明显。延迟渲染先渲染几何信息，再统一计算光照，适合处理大量光源，特别是复杂的光照场景，性能更高，但对显存要求大，且处理透明物体较复杂。</li></ul><h4 id="伽马空间和Z空间"><a href="#伽马空间和Z空间" class="headerlink" title="伽马空间和Z空间"></a>伽马空间和Z空间</h4><p><strong>区别总结</strong></p><table><thead><tr><th>特性</th><th>伽马空间（Gamma Space）</th><th>Z 空间（Z Space）</th></tr></thead><tbody><tr><td><strong>概念</strong></td><td>颜色空间，涉及颜色校正</td><td>深度空间，涉及物体到相机的深度</td></tr><tr><td><strong>应用</strong></td><td>控制图像在屏幕上的显示效果</td><td>确定物体在 3D 场景中的深度和遮挡关系</td></tr><tr><td><strong>处理</strong></td><td>颜色值经过伽马校正</td><td>深度值存储在深度缓冲区，进行深度测试</td></tr><tr><td><strong>用途</strong></td><td>匹配人眼视觉特性，呈现自然的图像</td><td>确定物体的前后关系，进行正确的渲染遮挡</td></tr><tr><td><strong>非线性</strong></td><td>伽马空间通常是非线性的</td><td>Z 空间经过投影矩阵转换后深度也是非线性的</td></tr></tbody></table><ul><li><strong>伽马空间</strong> 主要用于颜色的显示与存储，经过伽马校正使得图像显示更加符合人眼的感知特性。</li><li><strong>Z 空间</strong> 主要用于深度的处理，决定了物体在三维空间中的前后关系，确保正确的遮挡与显示顺序。</li></ul><h4 id="如何描边"><a href="#如何描边" class="headerlink" title="如何描边"></a>如何描边</h4><ul><li>在 Unity 中，实现描边效果的常用方法是通过 Shader 进行背面剔除和几何体扩展。具体是剔除模型的正面，渲染背面并沿法线方向放大模型，从而生成描边轮廓。通过调整描边的颜色和宽度，可以灵活控制描边效果。此外，还可以通过几何体扩展和法线反转的方式实现描边，但 Shader 方式更为高效和灵活，适合实时渲染场景。</li></ul><h3 id="7-C-相关"><a href="#7-C-相关" class="headerlink" title="7. C++相关"></a>7. C++相关</h3><h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><ul><li>在 C++ 中，内存对齐（Memory Alignment）是指在内存中分配数据时，将数据放置在特定的内存地址上，以优化 CPU 的访问速度。内存对齐主要是为了提高性能，减少 CPU 访问内存时的额外开销。</li><li>union的内存大小为其内部最大变量的内存大小</li><li>static变量存储在全局或静态存储区，而不是结构体的对象内，因此它们不参与对象的内存布局和对齐</li><li>long long是8字节</li><li>在 C++ 中，内存对齐并不是硬性规定，但通常会由编译器进行自动优化，同时也可以由开发者手动控制<img src="/img/总结/C++类型大小.png" height=300 /></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Example1</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;           <span class="comment">// 1 字节</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s;</span><br><span class="line">    <span class="type">double</span> b;         <span class="comment">// 8 字节</span></span><br><span class="line">    <span class="type">short</span> c;          <span class="comment">// 2 字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example2</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example3</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">D</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Example1) <span class="comment">// 24字节，静态变量，不参与内存对齐</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Example2) <span class="comment">// 24字节，因为有虚表指针在最前面</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Example3) <span class="comment">// 24字节，会对齐</span></span><br></pre></td></tr></table></figure><h4 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name1[<span class="number">10</span>];</span><br><span class="line">name1 = <span class="string">&quot;aaaaa&quot;</span>;<span class="comment">//错误，表达式必须是可修改的左值</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *name2 ;</span><br><span class="line">name2 = <span class="string">&quot;aaaaa&quot;</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><ul><li>C++中，用双引号括起来的字符就是字符串常量，如“abc”，“hello”，“a+b”都是字符串常量。存储在常量存储区</li><li>双引号做了3件事：<ol><li>申请了空间(在常量区)，存放了字符串</li><li>在字符串尾加上了’&#x2F;0’</li><li>返回地址</li></ol></li></ul><h4 id="客户端和服务端时钟同步："><a href="#客户端和服务端时钟同步：" class="headerlink" title="客户端和服务端时钟同步："></a>客户端和服务端时钟同步：</h4><p>这是 <strong>时钟同步算法</strong>的例子，类似于 <strong>NTP 协议</strong>的工作方式，通过交换时间戳来估算客户端和服务器之间的时钟偏差。具体解释如下：</p><ol><li><strong>四个时间戳</strong>：<ul><li><strong>T1</strong>：客户端发起同步请求时的时间戳（客户端时间）。</li><li><strong>T2</strong>：服务器接收到同步请求时的时间戳（服务器时间）。</li><li><strong>T3</strong>：服务器发送响应时的时间戳（服务器时间）。</li><li><strong>T4</strong>：客户端接收到服务器响应时的时间戳（客户端时间）。</li></ul></li><li><strong>计算公式</strong>：<ul><li>公式 <code>((T2 - T1) + (T3 - T4)) / 2</code> 的作用是估算客户端和服务器之间的 <strong>时间差</strong>。</li><li><strong>(T2 - T1)</strong> 表示客户端到服务器的网络传输延迟。</li><li><strong>(T4 - T3)</strong> 表示服务器到客户端的网络传输延迟。</li><li>将两个延迟相加再除以 2，可以得出平均延迟值，进而通过这个值来调整客户端时钟。</li></ul></li><li><strong>大致计算</strong>：<ul><li>客户端最终可以用这个偏差值来调整本地时间，以实现时钟同步。</li></ul></li></ol><h4 id="静态链接和动态链接的区别和优缺点"><a href="#静态链接和动态链接的区别和优缺点" class="headerlink" title="静态链接和动态链接的区别和优缺点"></a>静态链接和动态链接的区别和优缺点</h4><ul><li>静态链接在编译时将库代码直接嵌入可执行文件，使程序独立、运行速度快，但文件体积大、更新困难；动态链接在运行时加载库，多个程序可以共享库文件，节省存储空间且易于更新，但依赖库文件存在，有一定运行时开销。</li></ul><h4 id="inline和-define的区别"><a href="#inline和-define的区别" class="headerlink" title="inline和#define的区别"></a>inline和#define的区别</h4><ul><li>inline 函数和 #define 都用于减少调用开销，但 inline 更安全，有类型检查、作用域控制和调试支持，适合复杂逻辑；而 #define 仅做文本替换，无类型检查，调试和错误处理能力较弱，因此 inline 是 #define 的更安全替代。</li></ul><h4 id="模板函数的概念"><a href="#模板函数的概念" class="headerlink" title="模板函数的概念"></a>模板函数的概念</h4><ul><li>模板函数是 C++ 中的一种函数，它允许函数定义使用类型参数，使得函数可以在编译时根据传入的实际类型生成相应的代码，从而实现泛型编程。模板函数避免了重复代码，适用于操作不同数据类型的通用函数。</li></ul><h4 id="特化的概念"><a href="#特化的概念" class="headerlink" title="特化的概念"></a>特化的概念</h4><ul><li>特化（Template Specialization）是 C++ 模板的一种功能，允许为特定类型定制模板函数或模板类的实现。通过特化，可以为特定数据类型提供专门的实现方式，而不是使用通用的模板版本。特化分为全特化和偏特化，其中全特化是为具体类型提供完全不同的实现，偏特化则是在部分模板参数特定化时实现。<br>下面是一个模板特化的简单例子，展示如何为特定类型提供不同实现：</li></ul><ol><li>通用模板定义<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;General template: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>特化模板定义，假设我们想要对 <code>int</code> 类型进行特化，可以这样写：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">printType</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized template for int: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用模板和模板特化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printType</span>(<span class="number">3.14</span>);    <span class="comment">// 调用通用模板，输出 &quot;General template: 3.14&quot;</span></span><br><span class="line">    <span class="built_in">printType</span>(<span class="number">42</span>);      <span class="comment">// 调用特化模板，输出 &quot;Specialized template for int: 42&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这个例子中，<code>printType</code> 是一个通用模板，但对 <code>int</code> 类型进行了特化。因此，当调用 <code>printType(42)</code> 时，会使用特化版本，而其他类型如 <code>double</code> 会使用通用版本。</li></ol><h4 id="NULL和nullptr的区别"><a href="#NULL和nullptr的区别" class="headerlink" title="NULL和nullptr的区别"></a>NULL和nullptr的区别</h4><ul><li>NULL 是 C 语言中的空指针常量，通常定义为 0，在 C++ 中也沿用，但存在类型不明确的问题；nullptr 是 C++11 引入的关键字，专用于表示空指针，类型安全且支持重载，因此 nullptr 更推荐用于指针操作。</li></ul><h4 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h4><ul><li>堆和栈都是内存分配区域，但用途不同：栈用于存储局部变量和函数调用信息，分配速度快、自动管理，但空间有限；堆用于动态分配内存，需要手动管理（如 new&#x2F;delete），空间较大但分配速度慢，适合需要灵活大小和生命周期的对象。</li></ul><h4 id="空类的大小以及为什么"><a href="#空类的大小以及为什么" class="headerlink" title="空类的大小以及为什么"></a>空类的大小以及为什么</h4><ul><li>一个空类的大小在 C++ 中通常为 1 字节。这是因为 C++ 要求每个对象在内存中都有唯一的地址，即使它不包含任何数据成员。为了满足这一要求，编译器会为空类分配 1 字节的内存空间，使得它的实例能够在内存中拥有唯一的地址，便于指针和引用操作。</li></ul><h4 id="C-内存泄漏"><a href="#C-内存泄漏" class="headerlink" title="C++ 内存泄漏"></a>C++ 内存泄漏</h4><ul><li>C++ 中，内存泄漏是指程序分配的内存没有被正确释放，通常由于忘记释放动态分配的内存或循环引用引起。内存泄漏会导致内存消耗持续增加，影响程序性能并可能导致崩溃。</li></ul><h4 id="C-实现-GC-的方式"><a href="#C-实现-GC-的方式" class="headerlink" title="C++ 实现 GC 的方式"></a>C++ 实现 GC 的方式</h4><ul><li>C++ 中常用的 GC 实现方式包括引用计数、智能指针（如 <code>std::shared_ptr</code>）、标记清除和分代收集等。引用计数通过追踪对象引用次数自动回收，智能指针则通过 RAII 管理内存，标记清除和分代收集则较少使用，通常在特定库或引擎中实现。</li></ul><h4 id="vector的扩容与缩容"><a href="#vector的扩容与缩容" class="headerlink" title="vector的扩容与缩容"></a>vector的扩容与缩容</h4><ul><li><code>vector</code> 在元素增加超过当前容量时会自动扩容，通常按 1.5 或 2 倍的增长比例分配更大内存，将原有元素移动到新位置；扩容是为了减少频繁的内存分配操作，提升性能。缩容则在元素删除较多时将内存减小到合理大小，通常使用 <code>shrink_to_fit()</code> 或重新赋值方式完成，以节省内存。</li></ul><h4 id="多继承问题"><a href="#多继承问题" class="headerlink" title="多继承问题"></a>多继承问题</h4><ul><li>多继承两个父类有相同的虚函数， 子类重写的是哪个 – 都重写，如果重写调用的是子类函数，未重写会导致二义性</li><li>A类是基类，B继承A，C继承A，D继承B和C，现在A里面有一个成员x，问D里有几个x。如果我只想留一份x怎么办<ul><li>在这种多重继承结构中，D 会继承两份 A 类的成员 x，因为 B 和 C 各自继承了 A</li><li>如果只想在 D 中保留一份 x，可以通过虚继承来解决<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">public</span>: <span class="type">int</span> x; &#125;;</span><br><span class="line"><span class="comment">// 虚拟继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line">    <span class="comment">// D 继承 B 和 C，但只会保留一份 A 的成员 x</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="重载相关"><a href="#重载相关" class="headerlink" title="重载相关"></a>重载相关</h4><ul><li>同名的函数，一个接受指针一个接受引用， 是不是重载 – 是</li><li>静态方法可以被重载但不能被覆写，因为不属于类的实例不能形成多态</li><li>函数重载的底层实现依赖于编译器的名称修饰（Name Mangling）机制。编译器在编译过程中，会根据重载函数的参数类型、数量、顺序等信息，为每个重载的函数生成唯一的符号名。这样可以在编译和链接时区分这些重载的函数，从而避免冲突。</li><li>运算符重载的本质是将运算符表达式转换为函数调用，编译器会将运算符重载的操作符解释为相应的函数。例如，当你重载 + 运算符时，编译器实际上是将 a + b 这样的表达式转换为 a.operator+(b) 或 operator+(a, b) 的函数调用</li></ul><h4 id="野指针"><a href="#野指针" class="headerlink" title="野指针"></a>野指针</h4><ul><li>野指针是C++中常见的指针错误，通常因未初始化指针、释放后未置空的悬空指针或越界访问导致。野指针可能引发程序崩溃或未定义行为，因此在C++中应谨慎管理指针，使用智能指针（如std::unique_ptr或std::shared_ptr）和严格的指针初始化来避免野指针问题</li></ul><h4 id="开放定址法删除元素"><a href="#开放定址法删除元素" class="headerlink" title="开放定址法删除元素"></a>开放定址法删除元素</h4><ul><li>直接删除会影响后续查找操作，因为空位会中断查找过程。因此标记为“已删除”状态，而不是清空该位置，此外可在适当时机重建哈希表以清除标记的删除位。</li></ul><h4 id="移动语义相关"><a href="#移动语义相关" class="headerlink" title="移动语义相关"></a>移动语义相关</h4><ol><li><strong>移动构造</strong>：移动构造函数通过“窃取”资源而非复制，实现将临时对象的资源转移给新对象，避免了昂贵的深拷贝操作。</li><li><strong>移动赋值</strong>：移动赋值运算符将一个对象的资源转移给另一个已存在的对象，释放源对象资源，提升赋值效率。</li><li><strong>性能优化</strong>：移动语义减少了不必要的内存分配和数据复制，大幅提升程序在处理临时对象和大数据结构时的性能。</li><li><strong>原理分析</strong>：移动语义通过右值引用 (<code>T&amp;&amp;</code>) 实现，将源对象的资源指针转移到目标对象，实现高效的资源管理和避免重复分配。</li></ol><h4 id="STL二级分配器"><a href="#STL二级分配器" class="headerlink" title="STL二级分配器"></a>STL二级分配器</h4><ul><li>小于128字节的内存请求使用内存池（避免内存空间碎片） – 链表头指针为第一个空闲块</li><li>大于的话使用malloc或new来分配内存</li></ul><h4 id="初始化列表方式初始化"><a href="#初始化列表方式初始化" class="headerlink" title="初始化列表方式初始化"></a>初始化列表方式初始化</h4><ul><li>C++的构造函数可能会用初始化列表的方式去初始化，他和正常的方式有什么区别 – 避免产生临时变量</li></ul><h4 id="指针和引用使用"><a href="#指针和引用使用" class="headerlink" title="指针和引用使用"></a>指针和引用使用</h4><ul><li>当需要绑定一个不变对象且无需空值时选用引用，而在需要灵活指向不同对象或表示空值时选用指针。</li></ul><h4 id="malloc和new区别"><a href="#malloc和new区别" class="headerlink" title="malloc和new区别"></a>malloc和new区别</h4><ul><li>C用malloc申请内存，C++用new申请内存。</li><li>malloc需要自己指定申请多少内存，new会自动计算申请多少内存</li><li>malloc返回的是void*，new返回的是指定类型的指针</li><li>malloc不会初始化，new会调用构造函数进行初始化。</li></ul><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><ul><li>32位系统，程序最多使用多少内存<ul><li>2^32 字节，就是4G。但是内核要分去2G，剩下的才是应用程序的，所以最多是2G。</li></ul></li></ul><h4 id="智能指针相关"><a href="#智能指针相关" class="headerlink" title="智能指针相关"></a>智能指针相关</h4><ul><li>shared ptr是共享指针，可以有多个指针指向同一个对象，内部维护了一个引用计数，当引用计数为0时会自动释放对象<ul><li>引用计数增减：线程安全。</li><li>shared_ptr实例的读写：非线程安全。</li><li>被管理对象的访问：非线程安全，需要自行加锁或确保对象是线程安全的。</li></ul></li><li>unique_ptr是独占指针，只能有一个指针指向对象，它不能被拷贝，只能被移动</li><li>weak_ptr不占用引用计数，只作为对象的观察者，不能操作对象。</li></ul><h4 id="数组和链表的遍历效率"><a href="#数组和链表的遍历效率" class="headerlink" title="数组和链表的遍历效率"></a>数组和链表的遍历效率</h4><ul><li>数组的遍历效率更高，因为数组在内存中是连续存储的，CPU 可以高效地利用缓存（Cache）预取数据，减少内存访问的延迟</li><li>链表在内存中是非连续存储的，每次访问节点需要通过指针找到下一个节点，容易导致缓存命中率低、内存访问不连续</li></ul><h4 id="编译型和解释型语言"><a href="#编译型和解释型语言" class="headerlink" title="编译型和解释型语言"></a>编译型和解释型语言</h4><ol><li><strong>执行方式</strong>：编译型语言在执行前将源代码编译成机器码，而解释型语言逐行解释执行源代码。</li><li><strong>运行速度</strong>：编译型语言通常运行速度较快，因其执行的是机器码；解释型语言一般较慢，因为需要实时解释。</li><li><strong>错误检测</strong>：编译型语言在编译时进行语法检查，而解释型语言的错误通常在运行时才被发现。</li><li><strong>开发过程</strong>：编译型语言的编译过程较慢，开发周期更长；解释型语言支持快速开发和即时测试。</li><li><strong>平台依赖性</strong>：编译型语言生成的机器码与特定平台相关，需为不同平台编译；解释型语言通常更具跨平台性。</li><li><strong>内存管理</strong>：编译型语言可能需要手动管理内存，解释型语言通常具有自动垃圾回收机制。</li></ol><h4 id="stringstream相关"><a href="#stringstream相关" class="headerlink" title="stringstream相关"></a>stringstream相关</h4><ul><li><code>ss &gt;&gt; word</code>，从 ss 中逐个提取字符串，遇到空格会自动跳过，提取到的单词存入 word<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建一个 stringstream 对象 ss，并将字符串 s 传入</span></span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;  <span class="comment">// 将字符串 s 放入 stringstream 中</span></span><br><span class="line">    string word;</span><br><span class="line">    vector&lt;string&gt; words;</span><br><span class="line">    <span class="comment">// 2. 利用 stringstream 来提取单词</span></span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; word) &#123;  <span class="comment">// 逐个读取单词，跳过多余的空格</span></span><br><span class="line">        words.<span class="built_in">push_back</span>(word);  <span class="comment">// 将每个单词存入 vector 中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="memset相关"><a href="#memset相关" class="headerlink" title="memset相关"></a>memset相关</h4><ul><li>memset 是 C&#x2F;C++ 标准库中的一个函数，用于将一块内存中的字节设置为指定的值。它通常用于对数组或内存区域进行初始化或重置</li><li>对子类内存清零时如果有虚指针的话会报错<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr));  <span class="comment">// 将数组初始化为 0</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="memcpy和memmove"><a href="#memcpy和memmove" class="headerlink" title="memcpy和memmove"></a>memcpy和memmove</h4><ul><li>memcpy 更快，但只适用于不重叠的内存区域。</li><li>memmove 更灵活，可以安全处理重叠的内存区域，但速度相对较慢。</li><li>在内存重叠的情况下，memmove 会确保正确地复制数据。它会根据 src 和 dest 的相对位置选择从前往后复制或从后往前复制，以避免重叠时的数据覆盖问题</li></ul><h4 id="erase函数"><a href="#erase函数" class="headerlink" title="erase函数"></a>erase函数</h4><ul><li>erase(key)：根据键值删除元素。返回被删除元素的数量（0 或 1），表示是否成功删除了元素</li><li>erase(iterator)：通过迭代器删除单个元素。返回删除元素之后的下一个迭代器</li><li>erase(iterator_first, iterator_last)：删除迭代器范围内的元素。</li><li>clear()：清空整个 map。</li></ul><h4 id="堆栈相关"><a href="#堆栈相关" class="headerlink" title="堆栈相关"></a>堆栈相关</h4><ul><li>进程如何管理堆和栈： 进程的堆和栈由操作系统通过虚拟内存管理系统进行管理。栈是自动分配的内存，用于存储局部变量、函数参数等，分配和释放由系统自动完成。堆是动态分配的内存，程序员通过 malloc 或 new 来分配，手动通过 free 或 delete 释放。栈的大小固定，而堆的大小可以根据需求动态扩展，堆和栈的内存增长方向相反。</li><li>堆内存用完时的管理： 当堆内存用完时，操作系统无法再分配更多内存，程序会遇到内存分配失败的情况。此时，malloc 会返回 NULL，new 在 C++ 中可能抛出异常。程序员需要对内存分配结果进行检查并处理，如释放不再使用的内存或减少内存分配需求，以避免程序崩溃。</li><li>栈内存用完时的管理： 栈内存用完通常导致栈溢出（Stack Overflow），进而引发程序崩溃。栈溢出多发生于递归层数过深、局部变量过大或函数调用嵌套过深的情况下。操作系统通过设置固定的栈大小，并在超出限制时发出异常信号终止程序运行。为防止栈溢出，程序员应控制递归深度，避免使用过大的局部数组，或在必要时增大栈的大小。</li><li>导致栈用完的情况： 栈用完的常见原因包括递归深度过大、局部变量过大或函数调用嵌套过深。递归函数每次调用都会消耗栈空间，而过大的局部数组会迅速占用栈内存，导致栈空间不足。栈溢出后，操作系统会终止程序的运行，因此程序员需要优化递归算法，使用堆内存分配大数据，或调整栈大小来避免此类问题。</li></ul><h4 id="虚函数表存放在哪个内存区"><a href="#虚函数表存放在哪个内存区" class="headerlink" title="虚函数表存放在哪个内存区"></a>虚函数表存放在哪个内存区</h4><ul><li>虚函数表本身一般存储在全局内存区（通常是程序的数据段，或者在有些编译器实现中放在只读数据段）。由于虚函数表是类级别的（每个类只有一个虚表），而不是对象级别的，因此不会随着对象而频繁创建或销毁。</li></ul><h4 id="C-11-新特性总结"><a href="#C-11-新特性总结" class="headerlink" title="C++11 新特性总结"></a>C++11 新特性总结</h4><ol><li><strong><code>auto</code> 类型推导</strong>：编译器自动推导变量类型，简化代码。</li><li><strong><code>nullptr</code> 空指针</strong>：替代 <code>NULL</code>，更安全的空指针表示。</li><li><strong>基于范围的 <code>for</code> 循环</strong>：简化容器遍历，避免手动迭代器。</li><li><strong>智能指针</strong>：<code>std::unique_ptr</code> 和 <code>std::shared_ptr</code> 自动管理内存，防止内存泄漏。</li><li><strong><code>lambda</code> 表达式</strong>：匿名函数，简洁地定义和传递小型函数。</li><li>**移动语义与 <code>std::move</code>**：右值引用实现资源转移，提升性能。</li><li><strong>哈希表容器</strong>：如 <code>std::unordered_map</code>，基于哈希的高效键值存储。</li></ol><h3 id="8-操作系统相关"><a href="#8-操作系统相关" class="headerlink" title="8. 操作系统相关"></a>8. 操作系统相关</h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><ul><li>死锁是指多个线程或进程在持有资源的同时相互等待对方释放资源，导致系统永久等待、无法继续执行的状态。死锁通常在并发编程中发生，满足<strong>互斥、持有并等待、不可抢占、循环等待</strong>四个条件时容易产生，比如线程同时竞争多个共享资源时或在嵌套锁情况下未按顺序释放锁。</li></ul><h4 id="进程线程区别"><a href="#进程线程区别" class="headerlink" title="进程线程区别"></a>进程线程区别</h4><ul><li>线程是进程中的最小执行单元，多个线程共享进程的内存空间和资源，切换速度快、内存开销小；而进程是操作系统分配资源的基本单位，进程间相互独立、资源隔离更强，但切换速度较慢、资源开销较大。</li></ul><h4 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h4><ul><li>管道，信号，信号量，消息队列，共享内存，Socket<ul><li>轻量、单向通信：适合使用管道。(开辟一块内存缓冲区)</li><li>异步、多进程通信：适合使用消息队列。</li><li>高性能数据传输：共享内存是最佳选择。（需要锁）</li><li>简单通知或控制：信号（向进程发送通知信号，PV操作）和信号量（控制多个进程对共享资源的访问权限）适用。</li><li>跨主机&#x2F;跨网络通信：Socket 和 RPC 是主要选择。</li></ul></li></ul><h4 id="进-线程间同步方式"><a href="#进-线程间同步方式" class="headerlink" title="进&#x2F;线程间同步方式"></a>进&#x2F;线程间同步方式</h4><ul><li>临界区，互斥量，信号量，管程（monitor，内部封装互斥同步提供接口），事件，条件变量</li><li>条件变量：当一个进程进入管程后被阻塞，直到阻塞的原因解除时，在此期间，如果该进程还不释放管程，那么 其他进程无法进入管程。(同一时刻，管程中只能有一个进程在执行)为此，将阻塞原因定义为 条件变量 condition;<ul><li>通常，一个进程被阻塞的原因可以有多个，因此在管程中设置了多个条件变量；</li><li>每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作：<ul><li>x.wait：当x对应的条件不满足时，正在调用管程的进程调用 x.wait，将自己插入x条件的等待队列，并释放管程。此时其他进程可以使用该管程。</li><li>x.signal：x对应的条件发生了变化，则调用 x.signal，唤醒一个因x条件而阻塞的进程。（进程离开管程时才能调用）</li></ul></li><li>和信号量的区别：条件变量是没有值的，仅实现了排队等待功能；信号量是有值的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者消费者模型</span></span><br><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition isFull, isEmpty;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == N) <span class="built_in">wait</span>(isFull); <span class="comment">// 阻塞，等待isFull=0再插入</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="built_in">insert_item</span>(item);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="built_in">signal</span>(isEmpty); <span class="comment">// 释放，让isEmpty=0即表示有数据了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Item <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>) <span class="built_in">wait</span>(isEmpty); <span class="comment">// 阻塞，等待isEmpty=0再删除</span></span><br><span class="line">        cnt--;</span><br><span class="line">        <span class="keyword">if</span> (cnt == N<span class="number">-1</span>) <span class="built_in">signal</span>(isFull); <span class="comment">// 释放，让isFull=0表示队列没满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">remove_item</span>();</span><br><span class="line">    &#125;</span><br><span class="line">end monitor</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="典型调度算法"><a href="#典型调度算法" class="headerlink" title="典型调度算法"></a>典型调度算法</h4><img src="/img/总结/调度算法.png" height=300 /><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><img src="/img/总结/动态分区分配算法.png" height=400 /><ul><li>固定分区会导致内部碎片，动态分区导致外部碎片</li></ul><h4 id="存储相关"><a href="#存储相关" class="headerlink" title="存储相关"></a>存储相关</h4><ul><li>速度：缓存 &gt; 内存 &gt; 外存（虚拟内存 – 预加载）</li><li>虚拟内存好处：<ul><li>内存扩展，把不常用的数据存在硬盘中优化内存利用率</li><li>内存隔离，为每个进程提供独立的地址空间防止相互干扰提供系统稳定性</li></ul></li><li>什么时候诱发缺页中断，问是不是每次访存都要经过操作系统，问知不知道MMU(内存管理单元)<ul><li>缺页中断在程序访问未加载到物理内存的虚拟页时发生，此时系统暂停该进程并将所需页面加载到内存。因此，并非每次访存都需要经过操作系统，仅在发生缺页中断时操作系统才介入。</li><li>（MMU）负责虚拟地址到物理地址的转换，它通过页表来快速定位物理地址，大多数情况下使访存速度接近直接访问物理内存，从而减少对操作系统的依赖。</li></ul></li><li>什么是空间局部性，对编程有什么启发<ul><li>空间局部性：在访问某个存储位置时，其附近的存储位置也可能在短时间内被访问</li><li>将相关数据存储在相邻的内存位置：使用连续数组而非链表存储、减少随机内存访问</li><li>时间局部性: 如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)</li></ul></li><li>为什么32位整型数可以直接做加减法<ul><li>因为现代处理器的寄存器通常为32位或更大，支持直接对32位数据进行算术运算，无需分段处理</li></ul></li></ul><h4 id="虚拟内存相关"><a href="#虚拟内存相关" class="headerlink" title="虚拟内存相关"></a>虚拟内存相关</h4><img src="/img/总结/虚拟内存.png" height=400 /><ul><li>虚存的容量要满足以下两个条件：<ul><li>虚存的实际容量 ≤ 内存容量和外存容量之和，这是硬件的硬性条件规定的，若虚存的实际容量超过了这个容量，则没有相应的空间来供虚存使用；</li><li>虚存的最大容量 ≤ 计算机的地址位数能容纳的最大容量；</li></ul></li></ul><h4 id="多线程与多进程"><a href="#多线程与多进程" class="headerlink" title="多线程与多进程"></a>多线程与多进程</h4><ul><li>多线程：适合 IO 密集型任务，方便资源共享与快速通信。</li><li>多进程：适合 CPU 密集型任务，充分利用多核 CPU，适合独立的计算密集型操作。（100个jpg转png需要解码与编码所以是CPU密集型任务）</li></ul><h3 id="9-数学相关"><a href="#9-数学相关" class="headerlink" title="9. 数学相关"></a>9. 数学相关</h3><h4 id="判断直线与空间三角形是否相交"><a href="#判断直线与空间三角形是否相交" class="headerlink" title="判断直线与空间三角形是否相交"></a>判断直线与空间三角形是否相交</h4><ul><li>判断直线与空间三角形是否相交，可以先将直线参数化为点和方向向量，通过射线与三角形所在平面的交点求解潜在相交点。若交点存在，再进一步判断该点是否在三角形内部（通常用重心坐标或边向量叉积法验证）。若交点位于三角形内，则直线与三角形相交。</li></ul><h4 id="三角形重心"><a href="#三角形重心" class="headerlink" title="三角形重心"></a>三角形重心</h4><ul><li>三角形的重心是三角形三个顶点的平均位置</li></ul><h3 id="10-C-相关"><a href="#10-C-相关" class="headerlink" title="10. C#相关"></a>10. C#相关</h3><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><ul><li>产生原因：<ul><li>内存泄漏通常是指未被使用但无法被垃圾回收器清除的对象占用的内存</li><li>意外的引用（如事件处理器、静态引用、未移除的委托）</li></ul></li><li>如何避免<ul><li>应确保及时释放事件处理器的绑定，尤其是在对象生命周期结束时使用-&#x3D; EventHandler解除事件绑定</li><li>对于文件、流等非托管资源，使用using语句或实现IDisposable接口，以便在使用后释放资源</li><li>减少对静态对象的引用，避免不必要的对象缓存</li><li>使用内存分析工具检测潜在的内存泄漏可以帮助识别和优化内存管理</li></ul></li><li>与C++区别：<ul><li>C++没有GC需要自己管理资源的释放</li><li>C#有GC但需要管理非托管资源的释放</li></ul></li></ul><h4 id="托管资源与非托管资源"><a href="#托管资源与非托管资源" class="headerlink" title="托管资源与非托管资源"></a>托管资源与非托管资源</h4><ul><li>托管资源：由.NET运行时和垃圾回收器（GC）自动管理的资源，主要包括在托管堆上分配的内存，如类实例、字符串、数组和其他引用类型的对象</li><li>非托管资源：是指.NET运行时和垃圾回收器无法自动管理的资源，通常包括文件句柄、数据库连接、网络连接等</li><li>非托管资源通常通过实现IDisposable接口，并在Dispose方法中进行清理。using语句可以帮助自动调用Dispose方法，从而简化非托管资源的管理</li></ul><h4 id="C-与C-的引用区别"><a href="#C-与C-的引用区别" class="headerlink" title="C++与C#的引用区别"></a>C++与C#的引用区别</h4><ul><li>C++引用是对象的别名（共享同一内存地址），不能重新绑定；C#中的引用类型变量可以指向不同对象。（引用类型变量存储的是对象的内存地址，对象在堆中）</li><li>C++引用主要函数参数传递（按引用传递），C#还支持通过ref和out关键字实现按引用传递（函数参数）</li><li>C++对引用类型和值类型没有明确区分，C#则明确区分，并通过垃圾回收管理引用类型的内存。</li><li>C++的引用管理灵活但存在风险（悬空引用、野指针），C#的垃圾回收机制提升了引用的安全性，但仍需避免事件绑定未解除导致的泄漏。</li></ul><h4 id="怎么去判断一个类型（自定义或内置类型）是否包含某个方法"><a href="#怎么去判断一个类型（自定义或内置类型）是否包含某个方法" class="headerlink" title="怎么去判断一个类型（自定义或内置类型）是否包含某个方法"></a>怎么去判断一个类型（自定义或内置类型）是否包含某个方法</h4><ul><li>使用反射来判断一个类型是否包含某个方法。反射可以帮助我们在运行时获取类型的详细信息，包括属性、方法</li><li>获取类型对象：通过typeof()获取目标类型的Type对象，或通过object.GetType()获取实例的Type</li><li>使用GetMethod()方法：Type类提供了GetMethod()方法，可以查找指定名称的方法</li></ul><h3 id="11-设计模式相关"><a href="#11-设计模式相关" class="headerlink" title="11. 设计模式相关"></a>11. 设计模式相关</h3><h4 id="面向对象设计六原则"><a href="#面向对象设计六原则" class="headerlink" title="面向对象设计六原则"></a>面向对象设计六原则</h4><ul><li>面向对象设计原则主要包括以下六大原则，它们简称为SOLID原则：</li></ul><ol><li>单一职责原则（Single Responsibility Principle, SRP）<ul><li>一个类应该只有一个引起它变化的原因，即每个类只负责一个职责。这样设计可以减少类的复杂性，提升代码的可读性和可维护性。</li><li>例如，一个用户类不应该既负责用户数据管理又负责UI显示，应该将这两个职责分开。</li></ul></li><li>开闭原则（Open&#x2F;Closed Principle, OCP）<ul><li>软件实体（类、模块、函数）应该对扩展开放，对修改关闭。这意味着应该通过增加新代码来扩展功能，而不影响现有代码，从而减少因修改带来的错误风险。</li><li>例如，新增一种支付方式时不修改原有支付类，而是通过继承或接口实现新支付方式。</li></ul></li><li>里氏替换原则（Liskov Substitution Principle, LSP）<ul><li>子类应该能够替换父类，并且确保原有程序逻辑的正确性不受影响。换言之，子类应尽量保持与父类相似的行为。</li><li>例如，矩形类的子类不应破坏矩形的面积计算逻辑，否则将违反里氏替换原则。</li></ul></li><li>接口隔离原则（Interface Segregation Principle, ISP）<ul><li>应该将庞大的接口拆分成多个小接口，使得实现类只需关心与自己相关的接口。这可以减少类与类之间的耦合，避免不必要的代码依赖。</li><li>例如，为不同操作设备定义各自独立的接口，而不是让所有设备实现一个大而全的接口。</li></ul></li><li>依赖倒置原则（Dependency Inversion Principle, DIP）<ul><li>高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。这样可以降低模块之间的耦合性。</li><li>例如，应用程序依赖于抽象的数据库接口，而不是具体的数据库实现，方便日后替换不同的数据库系统。</li></ul></li><li>迪米特法则（Law of Demeter, LoD）<ul><li>一个对象应尽量少地了解其他对象。即对象间通信尽量通过有限的接口来完成，避免直接依赖其他类的内部细节，减少类之间的耦合度。</li><li>例如，不应直接访问其他对象的子成员，应通过方法提供服务。</li></ul></li></ol><h4 id="ECS架构比OOP好在哪"><a href="#ECS架构比OOP好在哪" class="headerlink" title="ECS架构比OOP好在哪"></a>ECS架构比OOP好在哪</h4><ul><li>性能优化：<ul><li>内存布局：由于数据导向设计，ECS中的组件通常以连续数组的形式存储，能充分利用CPU缓存（空间局部性），提高访问和计算效率</li><li>并行处理：允许并行处理多个实体的组件，利用多核 CPU 的优势</li></ul></li><li>逻辑与数据分离：ECS将数据（组件）与处理逻辑（系统）分开，使得系统更加专注于特定功能，提升可维护性和可重用性</li><li>动态组合：ECS允许动态创建和组合组件，开发者可以轻松添加、删除或替换组件，增强了系统的灵活性</li></ul><h4 id="单例模式优缺点"><a href="#单例模式优缺点" class="headerlink" title="单例模式优缺点"></a>单例模式优缺点</h4><ul><li>单例模式用于确保一个类在应用程序中只有一个实例，并提供全局访问点，适合场景包括管理共享资源（如配置管理、日志记录、线程池等）。缺点是违背了单一职责原则，增加了代码的耦合性，难以进行单元测试，还可能导致隐藏的依赖和并发问题。使用时需要注意线程安全、延迟初始化、避免过度使用，以免影响代码的灵活性和可维护性。</li><li>饿汉式单例的对象分配在静态内存区，因为它的生命周期从程序启动时就开始，并且会在程序结束时释放。</li><li>懒汉式单例的对象分配在堆内存区，因为它使用动态分配，只有在首次调用 getInstance() 时才会创建，生命周期根据实现决定，通常手动管理释放。</li></ul><h4 id="观察者模式-使用场景"><a href="#观察者模式-使用场景" class="headerlink" title="观察者模式 使用场景"></a>观察者模式 使用场景</h4><ul><li>适用于在对象间建立一对多依赖关系的场景</li><li>事件驱动系统：如 GUI 组件中的事件监听器（按钮点击、键盘输入等），可以注册多个观察者来响应不同的事件</li><li>模型-视图-控制器（MVC）架构：模型发生变化时自动通知视图进行更新</li><li>状态同步：多个系统或对象需要同步状态，当一个状态改变时通知其他对象更新</li></ul><h4 id="组合模式相关"><a href="#组合模式相关" class="headerlink" title="组合模式相关"></a>组合模式相关</h4><ul><li>组合模式（Composite Pattern）是一种结构型设计模式，它通过将对象组合成树形结构来表示部分-整体的层次关系，使得客户端可以以一致的方式处理单个对象和组合对象。</li><li>相较于继承，组合模式的优点是更灵活，它允许通过组合对象来动态扩展功能，减少了类层次的复杂性，也避免了继承带来的强耦合。</li><li>缺点是设计和实现可能较复杂，尤其是在管理对象的生命周期和依赖关系时，需要更多的代码和维护成本。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.矩阵</title>
      <link href="/posts/f19ca8e2.html"/>
      <url>/posts/f19ca8e2.html</url>
      
        <content type="html"><![CDATA[<h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36-有效的数独"></a>36-有效的数独</h3><ul><li>判断数独是否有效</li><li>使用<font color=red><strong>二维数组</strong></font>分别存储行，列和九宫格该数字出现的次数</li><li>注意<font color=red><strong>box[i &#x2F; 3 * 3 + j &#x2F; 3]</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> row[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">// 行   </span></span><br><span class="line">        <span class="type">int</span> col[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">// 列</span></span><br><span class="line">        <span class="type">int</span> box[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;;    <span class="comment">// 九宫格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> num = board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (row[i][num] || col[j][num] || box[i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>][num]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                row[i][num] = col[j][num] = box[i / <span class="number">3</span> * <span class="number">3</span> + j / <span class="number">3</span>][num] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54-螺旋矩阵"></a>54-螺旋矩阵</h3><ul><li>给定一个m*n的矩阵，返回该矩阵的螺旋顺序</li><li>方法一：按层遍历，注意各个边界条件且需要再判断<font color=red><b>left &lt; right &amp;&amp; top &lt; bottom</b></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, top = <span class="number">0</span>, bottom = m - <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right &amp;&amp; top &lt;= bottom) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; top &lt; bottom) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = bottom - <span class="number">1</span>; i &gt; top; i--) &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 收缩边界进入下一层</span></span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            top++;</span><br><span class="line">            bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：模拟输出，时间复杂度 O(mn)，空间复杂度 O(mn)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方向数组：右→下→左→上（顺时针方向）</span></span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>, dir = <span class="number">0</span>; <span class="comment">// 初始位置(0,0)，方向向右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m * n; i++) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(matrix[row][col]);</span><br><span class="line">            visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 计算下一个位置</span></span><br><span class="line">            <span class="type">int</span> nextRow = row + dx[dir];</span><br><span class="line">            <span class="type">int</span> nextCol = col + dy[dir];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 需要转向的两种情况：越界或已访问</span></span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= m || </span><br><span class="line">                nextCol &lt; <span class="number">0</span> || nextCol &gt;= n ||</span><br><span class="line">                visited[nextRow][nextCol]) &#123;</span><br><span class="line">                dir = (dir + <span class="number">1</span>) % <span class="number">4</span>; <span class="comment">// 顺时针转向</span></span><br><span class="line">            &#125;</span><br><span class="line">            row += dx[dir];</span><br><span class="line">            col += dy[dir];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48-旋转图像"></a>48-旋转图像</h3><ul><li>给定一个n*n的二维矩阵，顺时针旋转90度</li><li>方法一：使用辅助数组，时间复杂度 O(n^2)，空间复杂度 O(n^2)</li><li>注意<font color=red><strong>(i, j) -&gt; (j, n - 1 - i)</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                res[j][n - <span class="number">1</span> - i] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        matrix = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：原地旋转，时间复杂度 O(n^2)，空间复杂度 O(1)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 先沿主对角线翻转，转置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再进行水平翻转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[i][n - <span class="number">1</span> - j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法三：将矩阵四分后再按四个角旋转</li><li>注意写公式时看j和谁一起动来确定j，另一个则就是i</li><li>考虑n为奇数情况，i&#x2F;j任意一个考虑即可需要<font color=red><b>(n + 1) &#x2F; 2</b></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; j++) &#123;                     <span class="comment">// 考虑n为奇数情况，i/j任意一个考虑即可</span></span><br><span class="line">                <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - <span class="number">1</span> - j][i];                    <span class="comment">// 左下-&gt;左上，因为行和j，列和i一起动</span></span><br><span class="line">                matrix[n - <span class="number">1</span> - j][i] = matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j];    <span class="comment">// 右下-&gt;左下，因为行和i，列和j一起动</span></span><br><span class="line">                matrix[n - <span class="number">1</span> - i][n - <span class="number">1</span> - j] = matrix[j][n - <span class="number">1</span> - i];    <span class="comment">// 右上-&gt;右下，因为行和j，列和i一起动</span></span><br><span class="line">                matrix[j][n - <span class="number">1</span> - i] = temp;                            <span class="comment">// 左上-&gt;右上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73-矩阵置零"></a>73-矩阵置零</h3><ul><li>给定一个m*n的矩阵，如果一个元素为0，则将其所在行和列的所有元素都设为0</li><li>方法一：使用标记数组，时间复杂度 O(mn)，空间复杂度 O(m + n)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(m)</span>, <span class="title">col</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    row[i] = col[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：<font color=red><b>用第一行和第一列来作为当前行列是否有零的标记</b></font>，时间复杂度 O(mn)，空间复杂度 O(1)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> flagCol0 = <span class="literal">false</span>, flagRow0 = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查第一列是否有0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) flagCol0 = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查第一行是否有0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) flagRow0 = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用第一行和第一列记录状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 标记行</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">// 标记列</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据标记设置零值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理第一行</span></span><br><span class="line">        <span class="keyword">if</span> (flagRow0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理第一列</span></span><br><span class="line">        <span class="keyword">if</span> (flagCol0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="289-生命游戏"><a href="#289-生命游戏" class="headerlink" title="289-生命游戏"></a>289-生命游戏</h3><ul><li>给定一个由0和1组成的m*n的矩阵，每个元素都可以有八个相邻的元素</li><li>规则：<ol><li>任何活细胞，如果周围八个位置有两个或三个活细胞，则继续存活，否则死亡</li><li>任何死细胞，如果周围八个位置有三个活细胞，则复活</li></ol></li><li>方法一：复制原本数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameOfLife</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">copy</span>(board); <span class="comment">// 创建原始矩阵的副本</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 八个方向的坐标偏移量</span></span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> live = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 统计周围活细胞数量</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> x = i + dx[k];</span><br><span class="line">                    <span class="type">int</span> y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n &amp;&amp; copy[x][y]) &#123;</span><br><span class="line">                        live++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 应用生存规则</span></span><br><span class="line">                <span class="keyword">if</span> (copy[i][j]) &#123; <span class="comment">// 当前细胞存活</span></span><br><span class="line">                    <span class="keyword">if</span> (live &lt; <span class="number">2</span> || live &gt; <span class="number">3</span>) board[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前细胞死亡</span></span><br><span class="line">                    <span class="keyword">if</span> (live == <span class="number">3</span>) board[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：用末位表示当前状态，倒数第二位表示下一时刻状态<font color=red><b>00:死 01:活变死 10:死变活 11:活</b></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">gameOfLife</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = board.<span class="built_in">size</span>(), n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> live = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 统计原始状态中的活细胞</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">8</span>; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> x = i + dx[k], y = j + dy[k];</span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n) &#123;</span><br><span class="line">                        live += board[x][y] &amp; <span class="number">1</span>; <span class="comment">// 取最后一位的原始状态</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用第二位存储新状态</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] &amp; <span class="number">1</span>) &#123; <span class="comment">// 当前是活细胞</span></span><br><span class="line">                    <span class="keyword">if</span> (live == <span class="number">2</span> || live == <span class="number">3</span>) board[i][j] |= <span class="number">2</span>; <span class="comment">// 标记为存活</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前是死细胞</span></span><br><span class="line">                    <span class="keyword">if</span> (live == <span class="number">3</span>) board[i][j] |= <span class="number">2</span>; <span class="comment">// 标记为复活</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 右移一位得到最终状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                board[i][j] &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-动画系统</title>
      <link href="/posts/db9b2a13.html"/>
      <url>/posts/db9b2a13.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-2D动画技术"><a href="#1-2D动画技术" class="headerlink" title="1. 2D动画技术"></a>1. 2D动画技术</h3><ul><li>Sprite动画，序列帧（2D角色，粒子系统中使用）</li><li>Live2D技术：<ul><li>将图片分模块并分层，每层设置不同深度</li><li>对每个由顶点、边和多边形定义的部分可以自动生成ArtMesh，然后通过控制顶点来变换ArtMesh实现图片变换</li><li>设置key frame来插值实现动画</li></ul></li><li>Spine技术：~</li></ul><h3 id="2-3D动画技术"><a href="#2-3D动画技术" class="headerlink" title="2. 3D动画技术"></a>2. 3D动画技术</h3><ul><li>Rigid Hierarchical Animation - 刚性层次动画</li><li>Per-vertex Animation - 逐顶点动画</li><li>Morph Target Animation - 变形目标动画（面部）</li><li>Skinned Animation - 蒙皮动画</li><li>Physics-based Animation - 物理动画<ul><li>Ragdoll</li><li>布料和流体模拟</li><li>反向运动学（IK）</li></ul></li><li>K帧和动捕</li></ul><h3 id="3-Joint插值"><a href="#3-Joint插值" class="headerlink" title="3. Joint插值"></a>3. Joint插值</h3><ul><li>需要在local空间下插值，因为是对旋转插值如果在model空间下会插值成直线<img src="/img/GAMES104/1-动画系统/Joint插值.png" height=400 /></li></ul><h3 id="4-蒙皮矩阵"><a href="#4-蒙皮矩阵" class="headerlink" title="4. 蒙皮矩阵"></a>4. 蒙皮矩阵</h3><ul><li><p>蒙皮：将顶点附加到已设置Pose的骨骼上</p></li><li><p>仿射矩阵</p><img src="/img/GAMES104/1-动画系统/AffineMatrix.png" height=400 /></li><li><p>Pose可以理解为一组骨骼的位置和旋转缩放（仿射矩阵）</p></li><li><p>Joint在model空间中的仿射矩阵是从根节点开始的local空间下的仿射矩阵累乘得到的</p><img src="/img/GAMES104/1-动画系统/JointPose.png" height=400 /></li><li><p>顶点相对于绑定的骨骼local空间下位置不变</p></li><li><p>要区分概念Bind Pose和当前t时间下的Pose</p><img src="/img/GAMES104/1-动画系统/蒙皮矩阵1.png" height=300 /></li><li><p>蒙皮矩阵：即将当前Bind Pose下Model空间的顶点位置变换到当前t时间Pose下的Model空间中的顶点位置</p></li><li><p>蒙皮矩阵&#x3D;当前t时间Pose下Joint的Model空间下的仿射矩阵乘以Bind Pose下Model空间的逆仿射矩阵</p><img src="/img/GAMES104/1-动画系统/蒙皮矩阵2.png" height=400 /></li><li><p>蒙皮矩阵调色板：因为顶点数太多而骨骼很少，因此可以先把骨骼变换后统一计算出所有的蒙皮矩阵即蒙皮矩阵调色板，这里需注意加上model空间变换成world空间</p><img src="/img/GAMES104/1-动画系统/蒙皮矩阵调色板.png" height=300 /></li><li><p>加权蒙皮混合：由于一个顶点可以受多个骨骼影响，因此需要加权混合，即算出顶点所有绑定骨骼变换后的model空间位置，然后加权求和，权重值和需要为1（此处需要在model空间插值而不能在local空间）</p><img src="/img/GAMES104/1-动画系统/加权蒙皮混合.png" height=300 /></li><li><p>LERP插值，NLERP（归一化）插值[四元数，角速度不定]，SLERP（球面）插值[四元数，角速度恒定，计算量较大]：θ大时用SLERP，θ接近零时用NLERP</p><img src="/img/GAMES104/1-动画系统/NLERP_SLERP.png" height=300 /></li><li><p>简单的动画实时管线：</p></li></ul><ol><li>首先CPU侧获取提取出动画Clip（即Pose）</li><li>然后根据前一帧和下一帧的Clip插值计算出当前时间的Pose（Local空间下）[用NLEPR&#x2F;SLERP]</li><li>接着将Pose转换到Model空间下，同时也计算蒙皮矩阵调色板</li><li>最后在GPU侧根据蒙皮矩阵调色板计算出顶点的Model空间下的位置并转换到World空间下（同时进行顶点权重混合）<img src="/img/GAMES104/1-动画系统/SimpleAnimationRuntimePipeline.png" height=400 /></li></ol><h3 id="5-动画数据压缩"><a href="#5-动画数据压缩" class="headerlink" title="5. 动画数据压缩"></a>5. 动画数据压缩</h3><ul><li>DoF减少：Scale一般可以丢弃，Translate可以只存储部分骨骼</li><li>关键帧提取：删除可以使用相邻帧线性插值来拟合的帧（可以用Catmull-Rom曲线来拟合：解决线性插值带来的旋转不自然问题）</li><li>浮点数量化：通常16位可以覆盖pose在游戏引擎中的浮点范围和精度要求（将32位浮点数线性量化为16位无符号整数）</li><li>四元数量化：3 个数字足以表示一个单位四元数（舍弃其中一个最大的值，其他值可以限定住范围从而最终由128bit -&gt; 48bit）<img src="/img/GAMES104/1-动画系统/四元数量化1.png" height=350 /><img src="/img/GAMES104/1-动画系统/四元数量化2.png" height=350 /></li></ul><h3 id="6-误差补偿"><a href="#6-误差补偿" class="headerlink" title="6. 误差补偿"></a>6. 误差补偿</h3><ul><li><p>插值误差：</p><ul><li>关键帧压缩导致相邻帧间的插值路径与原始动画存在偏差</li><li>解决方案：在关键帧之间添加误差补偿曲线（补偿位移&#x2F;旋转的残差）</li><li>通过后处理调整插值权重，优先保证关节点轨迹端点匹配</li></ul></li><li><p>量化误差补偿：</p><ul><li>浮点数量化导致关键帧姿态偏移</li><li>建立误差传递模型，在父节点姿态量化后补偿子节点local空间坐标</li><li>对旋转分量采用双重量化：先量化父关节，再基于父关节姿态量化子关节</li></ul></li><li><p>骨骼间误差传递：</p><ul><li>使用Forward Kinematics（FK）验证误差传播</li><li>对末端效应器（如手、脚）设置误差阈值，反向进行Inverse Kinematics（IK）补偿</li><li>动态调整骨骼链权重，优先保证视觉关键部位精度</li></ul></li><li><p>视觉误差掩蔽：</p><ul><li>利用运动模糊特性，在高速运动帧允许较大误差</li><li>针对面部动画：保持眼部周围区域高精度，放松脸颊区域精度要求</li><li>根据摄像机视角动态调整LOD，背对镜头时使用低精度补偿</li></ul></li></ul><h3 id="7-混合树"><a href="#7-混合树" class="headerlink" title="7. 混合树"></a>7. 混合树</h3><h3 id="8-动作状态机ASM"><a href="#8-动作状态机ASM" class="headerlink" title="8. 动作状态机ASM"></a>8. 动作状态机ASM</h3><h3 id="9-IK"><a href="#9-IK" class="headerlink" title="9. IK"></a>9. IK</h3>]]></content>
      
      
      <categories>
          
          <category> GAMES104 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>备忘录</title>
      <link href="/posts/27d394ca.html"/>
      <url>/posts/27d394ca.html</url>
      
        <content type="html"><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>看大话Unity公众号 – 网络同步（延迟补偿，预测），书</li><li>unity GAS复现 – 实现一个简单的技能demo</li><li>碰撞检测算法</li><li>navmesh寻路算法原理源码</li><li>项目难点可以写资源导入批处理</li><li>实习项目源码可以看看github上源码工具类相关，比如json文件读取处理</li><li>GAMES101，tiny renderer实现</li><li>GAMES104</li><li>kitchenchoas项目 – 网络同步netcode</li><li>空洞骑士RPG复现boss战斗，行为树，用GAS实现一个小技能</li><li>背包系统实现</li><li>AB打包框架</li></ul><p>急：</p><ul><li><p>GAMES101, 104</p></li><li><p>背包系统</p></li><li><p>NavMesh</p></li><li><p>行为树</p></li><li><p>常见Shader实现</p></li><li><p>Playable动画系统</p></li><li><p>碰撞检测</p></li><li><p>网络同步（延迟补偿，预测）</p></li><li><p>游戏框架</p></li><li><p>游戏设计模式</p></li><li><p>操作系统：内存管理，页，虚拟内存，进程线程，多核CPU，缓存</p></li><li><p>C++：智能指针，内存管理，STL，多线程，deque（b站视频面试题总结）</p></li><li><p>C#：多线程，异步，协程</p></li><li><p>游戏框架：UI框架设计</p></li><li><p>BVH&#x2F;八叉树</p></li><li><p>NavMesh，NetworkTransform源码</p></li><li><p>刷题</p></li><li><p>面经</p></li><li><p>其他人面经</p></li><li><p>操作系统，C++，C#，刷题和面经</p></li><li><p>早上：C++，C#，操作系统</p></li><li><p>下午：操作系统，面经</p></li><li><p>晚上：刷题</p></li><li><p>C++: STL基础全部</p></li><li><p>C#：基础全部</p></li><li><p>AB包</p></li></ul><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><table><thead><tr><th align="center">序号</th><th align="center">算法&#x2F;数据结构</th><th align="center">数量</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Kadane算法</td><td align="center">2</td></tr><tr><td align="center">2</td><td align="center">二叉搜索树</td><td align="center">3</td></tr><tr><td align="center">3</td><td align="center">图的广度优先搜索</td><td align="center">3</td></tr><tr><td align="center">4</td><td align="center">字典树</td><td align="center">3</td></tr><tr><td align="center">5</td><td align="center">二叉树层次遍历</td><td align="center">4</td></tr><tr><td align="center">6</td><td align="center">堆</td><td align="center">4</td></tr><tr><td align="center">7</td><td align="center">滑动窗口*</td><td align="center">4</td></tr><tr><td align="center">8</td><td align="center">区间</td><td align="center">4</td></tr><tr><td align="center">9</td><td align="center">分治</td><td align="center">4</td></tr><tr><td align="center">10</td><td align="center">栈</td><td align="center">5</td></tr><tr><td align="center">11</td><td align="center">一维动态规划</td><td align="center">5</td></tr><tr><td align="center">12</td><td align="center">双指针*</td><td align="center">5</td></tr><tr><td align="center">13</td><td align="center">矩阵*</td><td align="center">5</td></tr><tr><td align="center">14</td><td align="center">图</td><td align="center">6</td></tr><tr><td align="center">15</td><td align="center">位运算</td><td align="center">6</td></tr><tr><td align="center">16</td><td align="center">数学</td><td align="center">6</td></tr><tr><td align="center">17</td><td align="center">回溯</td><td align="center">7</td></tr><tr><td align="center">18</td><td align="center">二分查找</td><td align="center">7</td></tr><tr><td align="center">19</td><td align="center">哈希表</td><td align="center">9</td></tr><tr><td align="center">20</td><td align="center">多维动态规划</td><td align="center">9</td></tr><tr><td align="center">21</td><td align="center">链表*</td><td align="center">11</td></tr><tr><td align="center">22</td><td align="center">二叉树</td><td align="center">14</td></tr><tr><td align="center">23</td><td align="center">数组&#x2F;字符串</td><td align="center">24</td></tr></tbody></table><h3 id="公司"><a href="#公司" class="headerlink" title="公司"></a>公司</h3><ol><li>-沐瞳游戏</li><li>*腾讯IEG</li><li>*米哈游</li><li>*叠纸</li><li>*网易互娱&#x2F;雷火</li><li>-完美世界</li><li>-莉莉丝</li><li>*吉比特</li><li>-无端科技</li><li>-大龙梦途</li><li>-b站</li><li>*鹰角</li><li>*字节朝夕光年</li><li>*英雄游戏</li><li>*星辉游戏（广州）</li><li>-游卡</li><li>-延趣游戏</li><li>-友塔</li><li>-柠檬微趣</li><li>诗悦网络</li><li>-4399</li><li>*巨人网络</li><li>盛趣</li><li>搜狐畅游</li></ol><p>第一周：</p><ol><li>沐瞳游戏</li><li>莉莉丝</li><li>完美世界</li><li>大龙梦途</li><li>b站</li><li>游卡  </li><li>灵犀互娱</li><li>友塔<!-- 9. 柠檬微趣 --></li><li>4399</li></ol><p>第二周：</p><ol><li>腾讯IEG</li><li>米哈游<!-- 3. 叠纸 --><!-- 4. 网易互娱/雷火 --></li><li>吉比特<!-- 6. 星辉游戏（广州） --><!-- 7. 英雄游戏 --></li><li>鹰角</li><li>字节朝夕光年</li><li>巨人网络</li><li>库洛</li></ol><p>第三周：</p><ol><li>诗悦网络</li><li>盛趣</li><li>无端科技</li><li>搜狐畅游<!-- 5. 延趣游戏 --></li></ol><hr><p>3&#x2F;25周二 10:45 游卡二面<br>3&#x2F;25周二 15:30 B站一面<br>3&#x2F;26周三 19:00 4399一面</p>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.链表</title>
      <link href="/posts/2167c702.html"/>
      <url>/posts/2167c702.html</url>
      
        <content type="html"><![CDATA[<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160-相交链表"></a>160-相交链表</h3><ul><li>两个链表相交，返回相交节点，否则返回null</li><li>方法一：哈希</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="line">        ListNode *temp = headA;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            visited.<span class="built_in">insert</span>(temp);</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = headB;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(temp)) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：双指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：算两个链表差然后保证两个指针一起移动</span></span><br><span class="line"><span class="comment">// 方式二：两个指针交替移动走相同路程从而相交</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *p = headA, *q = headB;</span><br><span class="line">        <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">            p = p != <span class="literal">nullptr</span> ? p-&gt;next : headB;</span><br><span class="line">            q = q != <span class="literal">nullptr</span> ? q-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234-回文链表"></a>234-回文链表</h3><ul><li>判断是否是回文链表</li><li>方法一：复制到数组中，然后判断数组是否是回文</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vals.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = (<span class="type">int</span>)vals.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vals[i] != vals[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：<font color=red><strong>反转链表</strong></font>：分为两段将后半反转再逐一比较，空间复杂度为O(1)</li></ul><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141-环形链表"></a>141-环形链表</h3><ul><li>判断是否有环</li><li><font color=red><strong>快慢指针</strong></font>，注意快指针边界判断</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *slow = head, *fast = head-&gt;next;</span><br><span class="line">        <span class="comment">// 此处注意两个判断</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2-两数相加"></a>2-两数相加</h3><ul><li>两个逆序非空链表相加求和，每个节点代表一位数</li><li>进位相加，注意使用<font color=red><strong>dummy头节点</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x = l1 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l1-&gt;val;</span><br><span class="line">            <span class="type">int</span> y = l2 == <span class="literal">nullptr</span> ? <span class="number">0</span> : l2-&gt;val;</span><br><span class="line">            <span class="type">int</span> sum = x + y + carry;</span><br><span class="line">            <span class="comment">// 此处carry和sum注意顺序不能反</span></span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry) cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21-合并两个有序链表"></a>21-合并两个有序链表</h3><ul><li>直接比较，注意使用<font color=red><strong>dummy头节点</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        ListNode *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(list1 &amp;&amp; list2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &gt; list2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = list1 ? list1 : list2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138-随机链表的复制"></a>138-随机链表的复制</h3><ul><li>对一个有random指针的链表进行深拷贝，要注意不能修改原链表</li><li><font color=red><strong>用复制拼接 + 拆开(N, 1); 用哈希(N, N)</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        Node *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            node-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = node;</span><br><span class="line">            cur = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="comment">// 关键步骤</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;random)</span><br><span class="line">                cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = head-&gt;next;</span><br><span class="line">        <span class="comment">// 此处注意要还原原链表</span></span><br><span class="line">        Node *pre = head, *res = cur;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="92-反转链表II"><a href="#92-反转链表II" class="headerlink" title="92-反转链表II"></a>92-反转链表II</h3><ul><li>对指定left和right部分进行反转</li><li>方法一：<font color=red><strong>dummy, pre, left, right, succ</strong></font> ，缺点在于需要遍历两次</li></ul><img src="/img/1-链表/1-92.1.png" height=200 /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseLinkedList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode *next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (head == nullptr || left == right) return head;</span></span><br><span class="line">        <span class="comment">// 1. 声明dummy节点</span></span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 指定pre节点</span></span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 指定left_node和right_node</span></span><br><span class="line">        ListNode* left_node = pre-&gt;next, *right_node = left_node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            right_node = right_node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 指定succ节点并反转(记得断开否则不能反转)</span></span><br><span class="line">        ListNode *succ = right_node-&gt;next;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        right_node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">reverseLinkedList</span>(left_node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 重新连接</span></span><br><span class="line">        pre-&gt;next = right_node;</span><br><span class="line">        left_node-&gt;next = succ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：原地反转, <font color=red><strong>dummy, pre, cur, next</strong></font></li></ul><img src="/img/1-链表/1-92.2.png" height=200 /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意此处循环次数</span></span><br><span class="line">        ListNode *cur = pre-&gt;next, *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25-K个一组翻转链表"></a>25-K个一组翻转链表</h3><ul><li>对链表每k组元素进行一次反转</li><li>方法一：<font color=red><strong>用92-反转链表II的解法拓展</strong></font>，O(N)&#x2F;O(1)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next, *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; len; i = i + k) &#123;</span><br><span class="line">            head = <span class="built_in">reverseBetween</span>(head, i - k + <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：<font color=red><strong>递归</strong></font>，注意每次递归一次后head, pre, cur, O(N)&#x2F;O(n&#x2F;k)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; k) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = head, *cur = head-&gt;next, *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// head连接后续部分，cur作为下一部分的头节点，pre作为当前头节点返回</span></span><br><span class="line">        head-&gt;next = <span class="built_in">reverseKGroup</span>(cur, k);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148-排序链表"></a>148-排序链表</h3><ul><li>给链表排序</li><li>方法一：<font color=red><strong>自顶向下归并排序</strong></font>，O(NlogN)&#x2F;O(logN)</li><li>注意<font color=red><strong>双指针找中点</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeHelper</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node || !node-&gt;next) <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        ListNode* mid_node = <span class="built_in">getMiddle</span>(node);</span><br><span class="line">        ListNode* next_node = mid_node-&gt;next;</span><br><span class="line">        mid_node-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        ListNode* left = <span class="built_in">mergeHelper</span>(node);             <span class="comment">// 注意此处递归开始</span></span><br><span class="line">        ListNode* right = <span class="built_in">mergeHelper</span>(next_node);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">getMiddle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head, *fast = head-&gt;next;      <span class="comment">// 注意fast = head-&gt;next</span></span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;                     <span class="comment">// 注意此处判断条件</span></span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* a, ListNode* b)</span></span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* temp = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (a &amp;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;val &lt;= b-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = a;</span><br><span class="line">                a = a-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;next = b;</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp-&gt;next = a ? a : b;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;                              <span class="comment">// 此处不是指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeHelper</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：<font color=red><strong>自底向上归并排序</strong></font>，O(NlogN)&#x2F;O(1)</li><li>注意mergeHelper写法，定义<font color=red><strong>dummy, cur, tail和left, right, size</strong></font></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeHelper</span><span class="params">(ListNode* head, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode* cur, *tail;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> size = <span class="number">1</span>; size &lt; len; size *= <span class="number">2</span>) &#123;</span><br><span class="line">            cur = dummy.next;</span><br><span class="line">            tail = &amp;dummy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">                ListNode* left = cur;</span><br><span class="line">                ListNode* right = <span class="built_in">getSegment</span>(left, size);</span><br><span class="line">                cur = <span class="built_in">getSegment</span>(right, size);          <span class="comment">// 必须写在merge前面</span></span><br><span class="line">                tail-&gt;next = <span class="built_in">merge</span>(left, right);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tail-&gt;next) &#123;</span><br><span class="line">                    tail = tail-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">getSegment</span><span class="params">(ListNode* head, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size &amp;&amp; head-&gt;next; i++) &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* next_node = head-&gt;next;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;                               <span class="comment">// 记得需要断开</span></span><br><span class="line">        <span class="keyword">return</span> next_node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* temp = &amp;dummy;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (a &amp;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a-&gt;val &lt;= b-&gt;val) &#123;</span><br><span class="line">                temp-&gt;next = a;</span><br><span class="line">                a = a-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp-&gt;next = b;</span><br><span class="line">                b = b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        temp-&gt;next = a ? a : b;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算长度</span></span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeHelper</span>(head, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19-删除链表的倒数第N个节点"></a>19-删除链表的倒数第N个节点</h3><ul><li>给定一个链表，删除链表的倒数第n个节点，返回链表的头节点</li><li><font color=red><strong>双指针</strong></font>，O(N)&#x2F;O(1)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode *slow = &amp;dummy, *fast = dummy.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146-LRU缓存"></a>146-LRU缓存</h3><ul><li>实现LRU缓存，O(1)</li><li>方法一：<font color=red><strong>哈希表+双向链表</strong></font>，O(1)&#x2F;O(capacity)</li><li>注意<font color=red><strong>双向链表的插入和删除</strong></font></li><li>C++中list中元素被删除了只会使当前迭代器失效，不会使其他迭代器失效</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; lru_list;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, list&lt;<span class="type">int</span>&gt;::iterator&gt;&gt; kv_map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) : <span class="built_in">capacity</span>(capacity) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!kv_map.<span class="built_in">count</span>(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新链表位置</span></span><br><span class="line">        lru_list.<span class="built_in">erase</span>(kv_map[key].second);</span><br><span class="line">        lru_list.<span class="built_in">push_front</span>(key);</span><br><span class="line">        kv_map[key].second = lru_list.<span class="built_in">begin</span>();  <span class="comment">// 更新迭代器</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> kv_map[key].first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (kv_map.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            <span class="comment">// 更新现有键值</span></span><br><span class="line">            lru_list.<span class="built_in">erase</span>(kv_map[key].second);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行淘汰策略</span></span><br><span class="line">            <span class="keyword">if</span> (kv_map.<span class="built_in">size</span>() &gt;= capacity) &#123;</span><br><span class="line">                <span class="type">int</span> last = lru_list.<span class="built_in">back</span>();</span><br><span class="line">                kv_map.<span class="built_in">erase</span>(last);</span><br><span class="line">                lru_list.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 插入/更新数据</span></span><br><span class="line">        lru_list.<span class="built_in">push_front</span>(key);</span><br><span class="line">        kv_map[key] = &#123;value, lru_list.<span class="built_in">begin</span>()&#125;;  <span class="comment">// 存储值和迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二：自己构建双向链表</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 需要包含key和val还有前后指针</span></span><br><span class="line"><span class="comment">// 2. 双向链表的头节点插入和删除删除函数构造</span></span><br><span class="line"><span class="comment">// 3. 注意在LRU类中初始化双向链表的头节点和尾节点</span></span><br><span class="line"><span class="comment">// 4. 记得put操作在满时要删除kv中的节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key, val;</span><br><span class="line">    DLinkedNode* pre, *next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="type">int</span> _key, <span class="type">int</span> _val) : <span class="built_in">key</span>(_key), <span class="built_in">val</span>(_val), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> capacity, size;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, DLinkedNode*&gt; kv;</span><br><span class="line">    DLinkedNode* head, *tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddNodeToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        node-&gt;pre = head;</span><br><span class="line">        node-&gt;next-&gt;pre = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RemoveNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> _capacity) : <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!kv.<span class="built_in">count</span>(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        DLinkedNode* cur_node = kv[key];</span><br><span class="line">        <span class="built_in">RemoveNode</span>(cur_node);</span><br><span class="line">        <span class="built_in">AddNodeToHead</span>(cur_node);</span><br><span class="line">        <span class="keyword">return</span> kv[key]-&gt;val; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (kv.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            DLinkedNode* cur_node = kv[key];</span><br><span class="line">            cur_node-&gt;val = value;</span><br><span class="line">            <span class="built_in">RemoveNode</span>(cur_node);</span><br><span class="line">            <span class="built_in">AddNodeToHead</span>(cur_node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (size &lt; capacity) size++; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                DLinkedNode* last_node = tail-&gt;pre;</span><br><span class="line">                kv.<span class="built_in">erase</span>(last_node-&gt;key);</span><br><span class="line">                <span class="built_in">RemoveNode</span>(last_node);</span><br><span class="line">            &#125;</span><br><span class="line">            DLinkedNode* new_node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            kv[key] = new_node;</span><br><span class="line">            <span class="built_in">AddNodeToHead</span>(new_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="环问题"><a href="#环问题" class="headerlink" title="环问题"></a>环问题</h3><ul><li>链表确定是否存在环和确定环的长度 – 可以使用<strong>快慢指针法</strong>（Floyd 判圈算法）。具体思路如下：</li></ul><ol><li><strong>检测环的存在</strong>：<ul><li>使用两个指针，<strong>慢指针</strong>每次移动一步，<strong>快指针</strong>每次移动两步。</li><li>如果链表存在环，快慢指针最终会在环内相遇；若不存在环，快指针会先到达链表末尾（<code>NULL</code>），从而终止循环。</li></ul></li><li><strong>确定环的长度</strong>：<ul><li>当快慢指针在环内相遇时，记录相遇点并让其中一个指针继续环内循环，直到再次到达相遇点。每移动一步计数一次，最终计数结果即为环的长度。</li></ul></li><li>这种方法能在 <strong>O(n)</strong> 时间内检测并计算环的长度，且只需要 <strong>O(1)</strong> 的额外空间。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *slow = head-&gt;next, *fast = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *find = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != find) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            find = find-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者哈希</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.<span class="built_in">insert</span>(head);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @font-face {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: lighter;}div#menus {    font-family: "ZhuZiAYuanJWD";}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: "iconfont" !important;    font-size: 3em;    /* 可以定义图标大小 */    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}/* 时间轴生肖icon */svg.icon {    /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */    width: 1em;    height: 1em;    /* width和height定义图标的默认宽度和高度*/    vertical-align: -0.15em;    fill: currentColor;    overflow: hidden;}.icon-zhongbiao::before {    color: #f7c768;}/* bilibli番剧插件 */#article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;}a.bangumi-tab:hover {    text-decoration: none !important;}.bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;}.bangumi-button {    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size: 1.1em;}.bangumi-info-item {    border-right: 1px solid #f2b94b;}.bangumi-info-item span {    color: #f2b94b;}.bangumi-info-item em {    color: #f2b94b;}/* 解决artitalk的图标问题 */#uploadSource>svg {    width: 1.19em;    height: 1.5em;}/*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */#page-header:not(.not-top-img):before {    background-color: transparent !important;}/* 首页文章卡片 */#recent-posts>.recent-post-item {    background: rgba(255, 255, 255, 0.9);}/* 首页侧栏卡片 */#aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);}/* 文章页面正文背景 */div#post {    background: rgba(255, 255, 255, 0.9);}/* 分页页面 */div#page {    background: rgba(255, 255, 255, 0.9);}/* 归档页面 */div#archive {    background: rgba(255, 255, 255, 0.9);}/* 标签页面 */div#tag {    background: rgba(255, 255, 255, 0.9);}/* 分类页面 */div#category {    background: rgba(255, 255, 255, 0.9);}/*夜间模式伪类遮罩层透明*/[data-theme="dark"] #recent-posts>.recent-post-item {    background: #121212;}[data-theme="dark"] .card-widget {    background: #121212 !important;}[data-theme="dark"] div#post {    background: #121212 !important;}[data-theme="dark"] div#tag {    background: #121212 !important;}[data-theme="dark"] div#archive {    background: #121212 !important;}[data-theme="dark"] div#page {    background: #121212 !important;}[data-theme="dark"] div#category {    background: #121212 !important;}[data-theme="dark"] div#category {    background: transparent !important;}/* 页脚透明 */#footer {    background: transparent !important;}/* 头图透明 */#page-header {    background: transparent !important;}#rightside>div>button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 10px;    height: 10px;}::-webkit-scrollbar-thumb {    background-color: #3b70fc;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #3b70fc;}/* 音乐播放器 *//* .aplayer .aplayer-lrc {    display: none !important;  } */.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    /* 默认情况下缩进左侧66px，只留一点箭头部分 */}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    /* 鼠标悬停是左侧缩进归零，完全显示按钮 */}.aplayer.aplayer-fixed {    z-index: 999999 !important;}/* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    /* -webkit-line-clamp: 2; */    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
